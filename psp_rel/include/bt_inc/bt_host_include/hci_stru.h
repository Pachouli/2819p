/*---------------------------------------------------------------------------
Module Name:
    hci_stru.h
Abstract:
    This module is generated by hci_gt.c, defines all macros,
    tables, funcs related by spec.
Component:
    Structure: Command Request:                     struct HCI_name_Stru
    Structure: Command Return:                      struct HCI_name_CompStru
    Structure: Event:                               struct HCI_name_EvStru
    Macro[Spec]: Command OpCode:                    HCI_OPC_name[2 octets]
    Macro[UI]: Command Stru Off / Ev & OpCode:      HCI_OPS_name[4 octets]
    Macro[Internal]: Event Index:                   HCI_EVI_name[1 octet]
    Table: Event Gap:                               struct HCI_IndexGapStru hci_table_evgap
    Table: Event for OP patch:                      struct HCI_EventCommandStru hci_table_evop
    Data: Event Coding Offset:                      UINT8 hci_table_codingoff_Event
    Data: Event Coding:                             UINT8 hci_table_coding_Event
    Data: Command Request/Return Coding:            UINT8 hci_table_coding_Command
    Table: Parameter Enum & Macro Defination:       HCI_ParamName_xxx
    Table: Command Support Bitmask & OpCode Gap:    struct HCI_OpCodeGapStru hci_table_supportcmdgap
Generate Date & Time:
    [2013/4/2][Week:2][20:35:53.312]
---------------------------------------------------------------------------*/

#ifndef G_HCI_STRU_H
#define G_HCI_STRU_H

#include "global.h"

#pragma __PRQA_IGNORE_START__


/*---------------------------------------------------------------------------------*/
/*                           Command & Return Structures                           */
/*---------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------*/
/*                              Link Control - 0x0400                              */
/*---------------------------------------------------------------------------------*/
/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 000,[0x0401,OGF:0x01,OCF:0x0001] Command */
/* [Inquiry_Complete][0x01],P:status[1] */
struct HCI_InquiryStru
{
    UINT8 lap[3];                          /* [161],Enum */
    UINT8 inquiry_len;                     /* [003],Time */
    UINT8 num_responses;                   /* [006],Val */
};/* 0x4a,0x15[LenI:2] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 001,[0x0402,OGF:0x01,OCF:0x0002] Return */
struct HCI_Inquiry_CancelCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 002,[0x0403,OGF:0x01,OCF:0x0003] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Periodic_Inquiry_ModeStru
{
    UINT16 max_period_len;                 /* [004],Time */
    UINT16 min_period_len;                 /* [005],Time */
    UINT8 lap[3];                          /* [161],Enum */
    UINT8 inquiry_len;                     /* [003],Time */
    UINT8 num_responses;                   /* [006],Val */
};/* 0x99,0x4a,0x15[LenI:3] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 002,[0x0403,OGF:0x01,OCF:0x0003] Return */
struct HCI_Periodic_Inquiry_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 003,[0x0404,OGF:0x01,OCF:0x0004] Return */
struct HCI_Exit_Periodic_Inquiry_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 004,[0x0405,OGF:0x01,OCF:0x0005] Command */
/* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */
struct HCI_Create_ConnectionStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT16 packet_type;                    /* [010],Mask */
    UINT8 page_scan_repetition_mode;       /* [016],Enum */
    UINT8 reserved;                        /* [017],Fix */
    UINT16 clock_offset;                   /* [019],Mask */
    UINT8 allow_role_switch;               /* [020],Enum */
};/* 0x56,0x56,0x65,0x01[LenI:4] */

/* 1.1,BREDR/LE,[CONNECTION SETUP] */
/* 005,[0x0406,OGF:0x01,OCF:0x0006] Command */
/* [Disconnection_Complete][0x05],P:status[1],connection_handle[2],reason[1] */
struct HCI_DisconnectStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 reason;                          /* [001],Enum */
};/* 0x59,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 006,[0x0407,OGF:0x01,OCF:0x0007] Command */
/* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */
struct HCI_Add_SCO_ConnectionStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 packet_type;                    /* [010],Mask */
};/* 0x99,0x00[LenI:2] */

/* 1.2,BREDR,[CONNECTION SETUP] */
/* 007,[0x0408,OGF:0x01,OCF:0x0008] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Create_Connection_CancelStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 1.2,BREDR,[CONNECTION SETUP] */
/* 007,[0x0408,OGF:0x01,OCF:0x0008] Return */
struct HCI_Create_Connection_CancelCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 008,[0x0409,OGF:0x01,OCF:0x0009] Command */
/* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */
struct HCI_Accept_Connection_RequestStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 role;                            /* [022],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 009,[0x040a,OGF:0x01,OCF:0x000a] Command */
/* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */
struct HCI_Reject_Connection_RequestStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 reason;                          /* [001],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 010,[0x040b,OGF:0x01,OCF:0x000b] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Link_Key_Request_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 link_key[16];                    /* [254],Val */
};/* 0x96,0x0f[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 010,[0x040b,OGF:0x01,OCF:0x000b] Return */
struct HCI_Link_Key_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 011,[0x040c,OGF:0x01,OCF:0x000c] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Link_Key_Request_Negative_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 011,[0x040c,OGF:0x01,OCF:0x000c] Return */
struct HCI_Link_Key_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 012,[0x040d,OGF:0x01,OCF:0x000d] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_PIN_Code_Request_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 pin_code_len;                    /* [011],Val */
    UINT8 pin_code[16];                    /* [012],Val */
};/* 0x56,0xf9,0x00[LenI:3] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 012,[0x040d,OGF:0x01,OCF:0x000d] Return */
struct HCI_PIN_Code_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 013,[0x040e,OGF:0x01,OCF:0x000e] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_PIN_Code_Request_Negative_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 013,[0x040e,OGF:0x01,OCF:0x000e] Return */
struct HCI_PIN_Code_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 1.1,BREDR,[PHYSICAL LINKS] */
/* 014,[0x040f,OGF:0x01,OCF:0x000f] Command */
/* [Connection_Packet_Type_Changed][0x1d],P:status[1],connection_handle[2],packet_type[2] */
struct HCI_Change_Connection_Packet_TypeStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 packet_type;                    /* [010],Mask */
};/* 0x99,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 015,[0x0411,OGF:0x01,OCF:0x0011] Command */
/* [Authentication_Complete][0x06],P:status[1],connection_handle[2] */
struct HCI_Authentication_RequestedStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 016,[0x0413,OGF:0x01,OCF:0x0013] Command */
/* [Encryption_Change][0x08],P:status[1],connection_handle[2],encryption_enable[1] */
struct HCI_Set_Connection_EncryptionStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 encryption_enable;               /* [023],Enum */
};/* 0x59,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 017,[0x0415,OGF:0x01,OCF:0x0015] Command */
/* [Change_Connection_Link_Key_Complete][0x09],P:status[1],connection_handle[2] */
struct HCI_Change_Connection_Link_KeyStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 018,[0x0417,OGF:0x01,OCF:0x0017] Command */
/* [Master_Link_Key_Complete][0x0a],P:status[1],connection_handle[2],key_flag[1] */
struct HCI_Master_Link_KeyStru
{
    UINT8 key_flag;                        /* [025],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[REMOTE INFORMATION] */
/* 019,[0x0419,OGF:0x01,OCF:0x0019] Command */
/* [Remote_Name_Request_Complete][0x07],P:status[1],bd[6],remote_name[248] */
struct HCI_Remote_Name_RequestStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 page_scan_repetition_mode;       /* [016],Enum */
    UINT8 reserved;                        /* [017],Fix */
    UINT16 clock_offset;                   /* [019],Mask */
};/* 0x56,0x55,0x02[LenI:3] */

/* 1.2,BREDR,[REMOTE INFORMATION] */
/* 020,[0x041a,OGF:0x01,OCF:0x001a] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Remote_Name_Request_CancelStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 1.2,BREDR,[REMOTE INFORMATION] */
/* 020,[0x041a,OGF:0x01,OCF:0x001a] Return */
struct HCI_Remote_Name_Request_CancelCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 1.1,BREDR,[REMOTE INFORMATION] */
/* 021,[0x041b,OGF:0x01,OCF:0x001b] Command */
/* [Read_Remote_Supported_Features_Complete][0x0b],P:status[1],connection_handle[2],lmp_features[8] */
struct HCI_Read_Remote_Supported_FeaturesStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.2,BREDR,[REMOTE INFORMATION] */
/* 022,[0x041c,OGF:0x01,OCF:0x001c] Command */
/* [Read_Remote_Extended_Features_Complete][0x23],P:status[1],connection_handle[2],page_number[1],max_page_number[1],extended_lmp_features[8] */
struct HCI_Read_Remote_Extended_FeaturesStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 page_number;                     /* [202],Val */
};/* 0x59,0x00[LenI:2] */

/* 1.1,BREDR/LE,[REMOTE INFORMATION] */
/* 023,[0x041d,OGF:0x01,OCF:0x001d] Command */
/* [Read_Remote_Version_Information_Complete][0x0c],P:status[1],connection_handle[2],lmp_version[1],manufacturer_name[2],lmp_subversion[2] */
struct HCI_Read_Remote_Version_InformationStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[LINK INFORMATION] */
/* 024,[0x041f,OGF:0x01,OCF:0x001f] Command */
/* [Read_Clock_Offset_Complete][0x1c],P:status[1],connection_handle[2],clock_offset[2] */
struct HCI_Read_Clock_OffsetStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.2,BREDR,[LINK INFORMATION] */
/* 025,[0x0420,OGF:0x01,OCF:0x0020] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],lmp_handle[1],reserved[4] */
struct HCI_Read_LMP_HandleStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.2,BREDR,[LINK INFORMATION] */
/* 025,[0x0420,OGF:0x01,OCF:0x0020] Return */
struct HCI_Read_LMP_HandleCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 lmp_handle;                      /* [018],Val */
    UINT32 reserved;                       /* [017],Fix */
};/* 0x95,0xd5,0x00[LenI:3] */

/* 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 026,[0x0428,OGF:0x01,OCF:0x0028] Command */
/* [Synchronous_Connection_Complete][0x2c],P:status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],rx_packet_length[2],tx_packet_length[2],air_mode[1] */
struct HCI_Setup_Synchronous_ConnectionStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT32 transmit_bandwidth;             /* [026],Val */
    UINT32 receive_bandwidth;              /* [027],Val */
    UINT16 max_latency;                    /* [106],Val */
    UINT16 voice_setting;                  /* [109],Mask */
    UINT8 retransmission_effort;           /* [108],Enum */
    UINT16 packet_type;                    /* [010],Mask */
};/* 0xd9,0x9d,0x59,0x09[LenI:4] */

/* 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 027,[0x0429,OGF:0x01,OCF:0x0029] Command */
/* [Synchronous_Connection_Complete][0x2c],P:status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],rx_packet_length[2],tx_packet_length[2],air_mode[1] */
/* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */
struct HCI_Accept_Synchronous_Connection_RequestStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT32 transmit_bandwidth;             /* [026],Val */
    UINT32 receive_bandwidth;              /* [027],Val */
    UINT16 max_latency;                    /* [106],Val */
    UINT16 voice_setting;                  /* [109],Mask */
    UINT8 retransmission_effort;           /* [108],Enum */
    UINT16 packet_type;                    /* [010],Mask */
};/* 0x56,0x77,0x66,0x25[LenI:4] */

/* 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 028,[0x042a,OGF:0x01,OCF:0x002a] Command */
/* [Synchronous_Connection_Complete][0x2c],P:status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],rx_packet_length[2],tx_packet_length[2],air_mode[1] */
/* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */
struct HCI_Reject_Synchronous_Connection_RequestStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 reason;                          /* [001],Enum */
};/* 0x56,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 029,[0x042b,OGF:0x01,OCF:0x002b] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_IO_Capability_Request_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 io_capability;                   /* [112],Enum */
    UINT8 oob_data_present;                /* [113],Enum */
    UINT8 authentication_requirements;     /* [114],Enum */
};/* 0x56,0x55,0x01[LenI:3] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 029,[0x042b,OGF:0x01,OCF:0x002b] Return */
struct HCI_IO_Capability_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 030,[0x042c,OGF:0x01,OCF:0x002c] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_User_Confirmation_Request_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 030,[0x042c,OGF:0x01,OCF:0x002c] Return */
struct HCI_User_Confirmation_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 031,[0x042d,OGF:0x01,OCF:0x002d] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_User_Confirmation_Request_Negative_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 031,[0x042d,OGF:0x01,OCF:0x002d] Return */
struct HCI_User_Confirmation_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 032,[0x042e,OGF:0x01,OCF:0x002e] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_User_Passkey_Request_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT32 numeric_value;                  /* [268],Val */
};/* 0x56,0x03[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 032,[0x042e,OGF:0x01,OCF:0x002e] Return */
struct HCI_User_Passkey_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 033,[0x042f,OGF:0x01,OCF:0x002f] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_User_Passkey_Request_Negative_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 033,[0x042f,OGF:0x01,OCF:0x002f] Return */
struct HCI_User_Passkey_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 034,[0x0430,OGF:0x01,OCF:0x0030] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Remote_OOB_Data_Request_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 c[16];                           /* [173],Val */
    UINT8 r[16];                           /* [174],Val */
};/* 0x96,0xef,0x03[LenI:3] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 034,[0x0430,OGF:0x01,OCF:0x0030] Return */
struct HCI_Remote_OOB_Data_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 035,[0x0433,OGF:0x01,OCF:0x0033] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Remote_OOB_Data_Request_Negative_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 035,[0x0433,OGF:0x01,OCF:0x0033] Return */
struct HCI_Remote_OOB_Data_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 036,[0x0434,OGF:0x01,OCF:0x0034] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_IO_Capability_Request_Negative_ReplyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 reason;                          /* [001],Enum */
};/* 0x56,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 036,[0x0434,OGF:0x01,OCF:0x0034] Return */
struct HCI_IO_Capability_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */


/*---------------------------------------------------------------------------------*/
/*                               Link Policy - 0x0800                              */
/*---------------------------------------------------------------------------------*/
/* 1.1,BREDR,[CONNECTION STATE] */
/* 037,[0x0801,OGF:0x02,OCF:0x0001] Command */
/* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */
struct HCI_Hold_ModeStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 hold_mode_max_interval;         /* [127],Time */
    UINT16 hold_mode_min_interval;         /* [128],Time */
};/* 0x99,0x09[LenI:2] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 038,[0x0803,OGF:0x02,OCF:0x0003] Command */
/* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */
struct HCI_Sniff_ModeStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 sniff_max_interval;             /* [129],Time */
    UINT16 sniff_min_interval;             /* [130],Time */
    UINT16 sniff_attempt;                  /* [131],Time */
    UINT16 sniff_timeout;                  /* [132],Time */
};/* 0x99,0x99,0x09[LenI:3] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 039,[0x0804,OGF:0x02,OCF:0x0004] Command */
/* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */
struct HCI_Exit_Sniff_ModeStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 040,[0x0805,OGF:0x02,OCF:0x0005] Command */
/* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */
struct HCI_Park_StateStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 beacon_max_interval;            /* [135],Time */
    UINT16 beacon_min_interval;            /* [136],Time */
};/* 0x99,0x09[LenI:2] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 041,[0x0806,OGF:0x02,OCF:0x0006] Command */
/* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */
struct HCI_Exit_Park_StateStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 042,[0x0807,OGF:0x02,OCF:0x0007] Command */
/* [QoS_Setup_Complete][0x0d],P:status[1],connection_handle[2],flags[1],service_type[1],token_rate[4],peak_bandwidth[4],latency[4],delay_variation[4] */
struct HCI_QoS_SetupStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 flags;                           /* [258],Val */
    UINT8 service_type;                    /* [115],Enum */
    UINT32 token_rate;                     /* [242],Val */
    UINT32 peak_bandwidth;                 /* [244],Val */
    UINT32 latency;                        /* [245],Val */
    UINT32 delay_variation;                /* [246],Val */
};/* 0x59,0xd5,0xdd,0x0d[LenI:4] */

/* 1.1,BREDR,[PICONET STRUCTURE] */
/* 043,[0x0809,OGF:0x02,OCF:0x0009] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],role[1] */
struct HCI_Role_DiscoveryStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[PICONET STRUCTURE] */
/* 043,[0x0809,OGF:0x02,OCF:0x0009] Return */
struct HCI_Role_DiscoveryCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 role;                            /* [022],Enum */
};/* 0x95,0x05[LenI:2] */

/* 1.1,BREDR,[PICONET STRUCTURE] */
/* 044,[0x080b,OGF:0x02,OCF:0x000b] Command */
/* [Role_Change][0x12],P:status[1],bd[6],role[1] */
struct HCI_Switch_RoleStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 role;                            /* [022],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 045,[0x080c,OGF:0x02,OCF:0x000c] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],link_policy_settings[2] */
struct HCI_Read_Link_Policy_SettingsStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 045,[0x080c,OGF:0x02,OCF:0x000c] Return */
struct HCI_Read_Link_Policy_SettingsCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 link_policy_settings;           /* [116],Mask */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 046,[0x080d,OGF:0x02,OCF:0x000d] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_Write_Link_Policy_SettingsStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 link_policy_settings;           /* [116],Mask */
};/* 0x99,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 046,[0x080d,OGF:0x02,OCF:0x000d] Return */
struct HCI_Write_Link_Policy_SettingsCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.2,BREDR,[CONNECTION STATE] */
/* 047,[0x080e,OGF:0x02,OCF:0x000e] Return */
struct HCI_Read_Default_Link_Policy_SettingsCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 link_policy_settings;           /* [116],Mask */
};/* 0x95,0x00[LenI:2] */

/* 1.2,BREDR,[CONNECTION STATE] */
/* 048,[0x080f,OGF:0x02,OCF:0x000f] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Default_Link_Policy_SettingsStru
{
    UINT16 link_policy_settings;           /* [116],Mask */
};/* 0x09[LenI:1] */

/* 1.2,BREDR,[CONNECTION STATE] */
/* 048,[0x080f,OGF:0x02,OCF:0x000f] Return */
struct HCI_Write_Default_Link_Policy_SettingsCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[QUALITY OF SERVICE] */
/* 049,[0x0810,OGF:0x02,OCF:0x0010] Command */
/* [Flow_Specification_Complete][0x21],P:status[1],connection_handle[2],flags[1],flow_direction[1],service_type[1],token_rate[4],token_bucket_size[4],peak_bandwidth[4],latency[4] */
struct HCI_Flow_SpecificationStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 flags;                           /* [258],Val */
    UINT8 flow_direction;                  /* [117],Enum */
    UINT8 service_type;                    /* [115],Enum */
    UINT32 token_rate;                     /* [242],Val */
    UINT32 token_bucket_size;              /* [243],Val */
    UINT32 peak_bandwidth;                 /* [244],Val */
    UINT32 latency;                        /* [245],Val */
};/* 0x59,0x55,0xdd,0xdd,0x00[LenI:5] */

/* 2.1,BREDR,[CONNECTION STATE] */
/* 050,[0x0811,OGF:0x02,OCF:0x0011] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_Sniff_SubratingStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 max_sniff_latency;              /* [107],Time */
    UINT16 min_remote_timeout;             /* [266],Time */
    UINT16 min_local_timeout;              /* [267],Time */
};/* 0x99,0x99,0x00[LenI:3] */

/* 2.1,BREDR,[CONNECTION STATE] */
/* 050,[0x0811,OGF:0x02,OCF:0x0011] Return */
struct HCI_Sniff_SubratingCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */


/*---------------------------------------------------------------------------------*/
/*                          Controller & Baseband - 0x0c00                         */
/*---------------------------------------------------------------------------------*/
/* 1.1,All,[HOST FLOW CONTROL] */
/* 051,[0x0c01,OGF:0x03,OCF:0x0001] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Set_Event_MaskStru
{
    UINT8 event_mask[8];                   /* [340],Mask64 */
};/* 0x1e[LenI:1] */

/* 1.1,All,[HOST FLOW CONTROL] */
/* 051,[0x0c01,OGF:0x03,OCF:0x0001] Return */
struct HCI_Set_Event_MaskCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,All,[DEVICE SETUP] */
/* 052,[0x0c03,OGF:0x03,OCF:0x0003] Return */
struct HCI_ResetCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR/AMP,[HOST FLOW CONTROL] */
/* 053,[0x0c05,OGF:0x03,OCF:0x0005] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Set_Event_FilterStru
{
    UINT8 filter_type;                     /* [118],Enum */
    UINT8 condition_plen;                  /* Data Need to Phase by context param */
    UINT8 condition[1];
};/* 0x25,0x00[LenI:2] */

/* 1.1,BREDR/AMP,[HOST FLOW CONTROL] */
/* 053,[0x0c05,OGF:0x03,OCF:0x0005] Return */
struct HCI_Set_Event_FilterCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 054,[0x0c08,OGF:0x03,OCF:0x0008] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_FlushStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 054,[0x0c08,OGF:0x03,OCF:0x0008] Return */
struct HCI_FlushCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 055,[0x0c09,OGF:0x03,OCF:0x0009] Return */
struct HCI_Read_PIN_TypeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 pin_type;                        /* [121],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 056,[0x0c0a,OGF:0x03,OCF:0x000a] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_PIN_TypeStru
{
    UINT8 pin_type;                        /* [121],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 056,[0x0c0a,OGF:0x03,OCF:0x000a] Return */
struct HCI_Write_PIN_TypeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 057,[0x0c0b,OGF:0x03,OCF:0x000b] Return */
struct HCI_Create_New_Unit_KeyCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 058,[0x0c0d,OGF:0x03,OCF:0x000d] Command */
/* [Command_Complete][0x0E],R:status[1],max_num_keys[2],num_keys[2] */
struct HCI_Read_Stored_Link_KeyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 all_flag;                        /* [122],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 058,[0x0c0d,OGF:0x03,OCF:0x000d] Return */
struct HCI_Read_Stored_Link_KeyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 max_num_keys;                   /* [123],Val */
    UINT16 num_keys;                       /* [124],Val */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 059,[0x0c11,OGF:0x03,OCF:0x0011] Command */
/* [Command_Complete][0x0E],R:status[1],num_keys_written[1] */
struct HCI_Write_Stored_Link_KeyStru
{
    UINT8 num_keys_to_write;               /* [125],Val */
    struct HCI_Write_Stored_Link_KeySubStru
    {
        UINT8 bd[6];                          /* [204],Val */
        UINT8 link_key[16];                   /* [254],Val */
    } n[1];
};/* 0x61,0xf9,0x00[LenI:3] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 059,[0x0c11,OGF:0x03,OCF:0x0011] Return */
struct HCI_Write_Stored_Link_KeyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 num_keys_written;                /* [126],Val */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 060,[0x0c12,OGF:0x03,OCF:0x0012] Command */
/* [Command_Complete][0x0E],R:status[1],num_keys[2] */
struct HCI_Delete_Stored_Link_KeyStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 all_flag;                        /* [122],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 060,[0x0c12,OGF:0x03,OCF:0x0012] Return */
struct HCI_Delete_Stored_Link_KeyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 num_keys;                       /* [124],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 061,[0x0c13,OGF:0x03,OCF:0x0013] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Local_NameStru
{
    UINT8 local_name[248];                 /* [240],String */
};/* 0xe3,0x03[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 061,[0x0c13,OGF:0x03,OCF:0x0013] Return */
struct HCI_Write_Local_NameCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 062,[0x0c14,OGF:0x03,OCF:0x0014] Return */
struct HCI_Read_Local_NameCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 local_name[248];                 /* [240],String */
};/* 0x35,0x3e[LenI:2] */

/* 1.1,BREDR/AMP,[CONNECTION SETUP] */
/* 063,[0x0c15,OGF:0x03,OCF:0x0015] Return */
struct HCI_Read_Connection_Accept_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 conn_accept_timeout;            /* [137],Time */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR/AMP,[CONNECTION SETUP] */
/* 064,[0x0c16,OGF:0x03,OCF:0x0016] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Connection_Accept_TimeoutStru
{
    UINT16 conn_accept_timeout;            /* [137],Time */
};/* 0x09[LenI:1] */

/* 1.1,BREDR/AMP,[CONNECTION SETUP] */
/* 064,[0x0c16,OGF:0x03,OCF:0x0016] Return */
struct HCI_Write_Connection_Accept_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 065,[0x0c17,OGF:0x03,OCF:0x0017] Return */
struct HCI_Read_Page_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 page_timeout;                   /* [138],Time */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 066,[0x0c18,OGF:0x03,OCF:0x0018] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Page_TimeoutStru
{
    UINT16 page_timeout;                   /* [138],Time */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 066,[0x0c18,OGF:0x03,OCF:0x0018] Return */
struct HCI_Write_Page_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 067,[0x0c19,OGF:0x03,OCF:0x0019] Return */
struct HCI_Read_Scan_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 scan_enable;                     /* [139],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 068,[0x0c1a,OGF:0x03,OCF:0x001a] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Scan_EnableStru
{
    UINT8 scan_enable;                     /* [139],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 068,[0x0c1a,OGF:0x03,OCF:0x001a] Return */
struct HCI_Write_Scan_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 069,[0x0c1b,OGF:0x03,OCF:0x001b] Return */
struct HCI_Read_Page_Scan_ActivityCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 page_scan_interval;             /* [140],Time */
    UINT16 page_scan_window;               /* [141],Time */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 070,[0x0c1c,OGF:0x03,OCF:0x001c] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Page_Scan_ActivityStru
{
    UINT16 page_scan_interval;             /* [140],Time */
    UINT16 page_scan_window;               /* [141],Time */
};/* 0x99,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 070,[0x0c1c,OGF:0x03,OCF:0x001c] Return */
struct HCI_Write_Page_Scan_ActivityCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 071,[0x0c1d,OGF:0x03,OCF:0x001d] Return */
struct HCI_Read_Inquiry_Scan_ActivityCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 inquiry_scan_interval;          /* [142],Time */
    UINT16 inquiry_scan_window;            /* [143],Time */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 072,[0x0c1e,OGF:0x03,OCF:0x001e] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Inquiry_Scan_ActivityStru
{
    UINT16 inquiry_scan_interval;          /* [142],Time */
    UINT16 inquiry_scan_window;            /* [143],Time */
};/* 0x99,0x00[LenI:2] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 072,[0x0c1e,OGF:0x03,OCF:0x001e] Return */
struct HCI_Write_Inquiry_Scan_ActivityCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 073,[0x0c1f,OGF:0x03,OCF:0x001f] Return */
struct HCI_Read_Authentication_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 authentication_enable;           /* [144],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 074,[0x0c20,OGF:0x03,OCF:0x0020] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Authentication_EnableStru
{
    UINT8 authentication_enable;           /* [144],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 074,[0x0c20,OGF:0x03,OCF:0x0020] Return */
struct HCI_Write_Authentication_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 075,[0x0c21,OGF:0x03,OCF:0x0021] Return */
struct HCI_Read_Encryption_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 encryption_mode;                 /* [024],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 076,[0x0c22,OGF:0x03,OCF:0x0022] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Encryption_ModeStru
{
    UINT8 encryption_mode;                 /* [024],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 076,[0x0c22,OGF:0x03,OCF:0x0022] Return */
struct HCI_Write_Encryption_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 077,[0x0c23,OGF:0x03,OCF:0x0023] Return */
struct HCI_Read_Class_of_DeviceCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 class_of_device[3];              /* [110],Mask */
};/* 0xa5,0x00[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 078,[0x0c24,OGF:0x03,OCF:0x0024] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Class_of_DeviceStru
{
    UINT8 class_of_device[3];              /* [110],Mask */
};/* 0x0a[LenI:1] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 078,[0x0c24,OGF:0x03,OCF:0x0024] Return */
struct HCI_Write_Class_of_DeviceCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 079,[0x0c25,OGF:0x03,OCF:0x0025] Return */
struct HCI_Read_Voice_SettingCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 voice_setting;                  /* [109],Mask */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 080,[0x0c26,OGF:0x03,OCF:0x0026] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Voice_SettingStru
{
    UINT16 voice_setting;                  /* [109],Mask */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 080,[0x0c26,OGF:0x03,OCF:0x0026] Return */
struct HCI_Write_Voice_SettingCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 081,[0x0c27,OGF:0x03,OCF:0x0027] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],flush_timeout[2] */
struct HCI_Read_Automatic_Flush_TimeoutStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 081,[0x0c27,OGF:0x03,OCF:0x0027] Return */
struct HCI_Read_Automatic_Flush_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 flush_timeout;                  /* [145],Time */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 082,[0x0c28,OGF:0x03,OCF:0x0028] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_Write_Automatic_Flush_TimeoutStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 flush_timeout;                  /* [145],Time */
};/* 0x99,0x00[LenI:2] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 082,[0x0c28,OGF:0x03,OCF:0x0028] Return */
struct HCI_Write_Automatic_Flush_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 083,[0x0c29,OGF:0x03,OCF:0x0029] Return */
struct HCI_Read_Num_Broadcast_RetransmissionsCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 num_broadcast_retransmissions;   /* [146],Val */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 084,[0x0c2a,OGF:0x03,OCF:0x002a] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Num_Broadcast_RetransmissionsStru
{
    UINT8 num_broadcast_retransmissions;   /* [146],Val */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 084,[0x0c2a,OGF:0x03,OCF:0x002a] Return */
struct HCI_Write_Num_Broadcast_RetransmissionsCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 085,[0x0c2b,OGF:0x03,OCF:0x002b] Return */
struct HCI_Read_Hold_Mode_ActivityCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 hold_mode_activity;              /* [147],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 086,[0x0c2c,OGF:0x03,OCF:0x002c] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Hold_Mode_ActivityStru
{
    UINT8 hold_mode_activity;              /* [147],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 086,[0x0c2c,OGF:0x03,OCF:0x002c] Return */
struct HCI_Write_Hold_Mode_ActivityCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR/LE,[LINK INFORMATION] */
/* 087,[0x0c2d,OGF:0x03,OCF:0x002d] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],transmit_power_level[1] */
struct HCI_Read_Transmit_Power_LevelStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 type;                            /* [148],Enum */
};/* 0x59,0x00[LenI:2] */

/* 1.1,BREDR/LE,[LINK INFORMATION] */
/* 087,[0x0c2d,OGF:0x03,OCF:0x002d] Return */
struct HCI_Read_Transmit_Power_LevelCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 transmit_power_level;            /* [149],Val */
};/* 0x95,0x05[LenI:2] */

/* 1.1,BREDR,[HOST FLOW CONTROL] */
/* 088,[0x0c2e,OGF:0x03,OCF:0x002e] Return */
struct HCI_Read_Synchronous_Flow_Control_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 synchronous_flow_control_enable; /* [150],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[HOST FLOW CONTROL] */
/* 089,[0x0c2f,OGF:0x03,OCF:0x002f] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Synchronous_Flow_Control_EnableStru
{
    UINT8 synchronous_flow_control_enable; /* [150],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[HOST FLOW CONTROL] */
/* 089,[0x0c2f,OGF:0x03,OCF:0x002f] Return */
struct HCI_Write_Synchronous_Flow_Control_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR/LE,[HOST FLOW CONTROL] */
/* 090,[0x0c31,OGF:0x03,OCF:0x0031] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Set_Controller_To_Host_Flow_ControlStru
{
    UINT8 flow_control_enable;             /* [151],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR/LE,[HOST FLOW CONTROL] */
/* 090,[0x0c31,OGF:0x03,OCF:0x0031] Return */
struct HCI_Set_Controller_To_Host_Flow_ControlCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR/LE,[HOST FLOW CONTROL] */
/* 091,[0x0c33,OGF:0x03,OCF:0x0033] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Host_Buffer_SizeStru
{
    UINT16 host_acl_data_packet_length;    /* [152],Val */
    UINT8 host_synchronous_data_packet_length;/* [153],Val */
    UINT16 host_total_num_acl_data_packets;/* [154],Val */
    UINT16 host_total_num_synchronous_data_packets;/* [155],Val */
};/* 0x59,0x99,0x00[LenI:3] */

/* 1.1,BREDR/LE,[HOST FLOW CONTROL] */
/* 091,[0x0c33,OGF:0x03,OCF:0x0033] Return */
struct HCI_Host_Buffer_SizeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,All,[HOST FLOW CONTROL] */
/* 092,[0x0c35,OGF:0x03,OCF:0x0035] Command */
/* - */
struct HCI_Host_Number_Of_Completed_PacketsStru
{
    UINT8 number_of_handles;               /* [156],Val */
    struct HCI_Host_Number_Of_Completed_PacketsSubStru
    {
        UINT16 connection_handle;             /* [002],Val */
        UINT16 host_num_of_completed_packets; /* [157],Val */
    } n[1];
};/* 0x91,0x09[LenI:2] */

/* 1.1,BREDR/AMP,[PHYSICAL LINKS] */
/* 093,[0x0c36,OGF:0x03,OCF:0x0036] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],link_supervision_timeout[2] */
struct HCI_Read_Link_Supervision_TimeoutStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR/AMP,[PHYSICAL LINKS] */
/* 093,[0x0c36,OGF:0x03,OCF:0x0036] Return */
struct HCI_Read_Link_Supervision_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 link_supervision_timeout;       /* [158],Time */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR/AMP,[PHYSICAL LINKS] */
/* 094,[0x0c37,OGF:0x03,OCF:0x0037] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_Write_Link_Supervision_TimeoutStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 link_supervision_timeout;       /* [158],Time */
};/* 0x99,0x00[LenI:2] */

/* 1.1,BREDR/AMP,[PHYSICAL LINKS] */
/* 094,[0x0c37,OGF:0x03,OCF:0x0037] Return */
struct HCI_Write_Link_Supervision_TimeoutCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 095,[0x0c38,OGF:0x03,OCF:0x0038] Return */
struct HCI_Read_Number_Of_Supported_IACCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 num_support_iac;                 /* [159],Val */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 096,[0x0c39,OGF:0x03,OCF:0x0039] Return */
struct HCI_Read_Current_IAC_LAPCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 num_current_iac;                 /* [160],Val */
    struct HCI_Read_Current_IAC_LAPSubStru
    {
        UINT8 lap[3];                         /* [161],Enum */
    } n[1];
};/* 0x15,0x0a[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 097,[0x0c3a,OGF:0x03,OCF:0x003a] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Current_IAC_LAPStru
{
    UINT8 num_current_iac;                 /* [160],Val */
    struct HCI_Write_Current_IAC_LAPSubStru
    {
        UINT8 lap[3];                         /* [161],Enum */
    } n[1];
};/* 0xa1,0x00[LenI:2] */

/* 1.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 097,[0x0c3a,OGF:0x03,OCF:0x003a] Return */
struct HCI_Write_Current_IAC_LAPCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 098,[0x0c3b,OGF:0x03,OCF:0x003b] Return */
struct HCI_Read_Page_Scan_Period_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 page_scan_period_mode;           /* [015],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 099,[0x0c3c,OGF:0x03,OCF:0x003c] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Page_Scan_Period_ModeStru
{
    UINT8 page_scan_period_mode;           /* [015],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 099,[0x0c3c,OGF:0x03,OCF:0x003c] Return */
struct HCI_Write_Page_Scan_Period_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 100,[0x0c3d,OGF:0x03,OCF:0x003d] Return */
struct HCI_Read_Page_Scan_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 page_scan_mode;                  /* [014],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 101,[0x0c3e,OGF:0x03,OCF:0x003e] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Page_Scan_ModeStru
{
    UINT8 page_scan_mode;                  /* [014],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 101,[0x0c3e,OGF:0x03,OCF:0x003e] Return */
struct HCI_Write_Page_Scan_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[PHYSICAL LINKS] */
/* 102,[0x0c3f,OGF:0x03,OCF:0x003f] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Set_AFH_Host_Channel_ClassificationStru
{
    UINT8 afh_host_channel_classification[10];/* [162],Enum */
};/* 0x26[LenI:1] */

/* 1.2,BREDR,[PHYSICAL LINKS] */
/* 102,[0x0c3f,OGF:0x03,OCF:0x003f] Return */
struct HCI_Set_AFH_Host_Channel_ClassificationCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 103,[0x0c42,OGF:0x03,OCF:0x0042] Return */
struct HCI_Read_Inquiry_Scan_TypeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 inquiry_scan_type;               /* [163],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 104,[0x0c43,OGF:0x03,OCF:0x0043] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Inquiry_Scan_TypeStru
{
    UINT8 inquiry_scan_type;               /* [163],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 104,[0x0c43,OGF:0x03,OCF:0x0043] Return */
struct HCI_Write_Inquiry_Scan_TypeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 105,[0x0c44,OGF:0x03,OCF:0x0044] Return */
struct HCI_Read_Inquiry_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 inquiry_mode;                    /* [164],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 106,[0x0c45,OGF:0x03,OCF:0x0045] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Inquiry_ModeStru
{
    UINT8 inquiry_mode;                    /* [164],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 106,[0x0c45,OGF:0x03,OCF:0x0045] Return */
struct HCI_Write_Inquiry_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[CONNECTION SETUP] */
/* 107,[0x0c46,OGF:0x03,OCF:0x0046] Return */
struct HCI_Read_Page_Scan_TypeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 page_scan_type;                  /* [165],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.2,BREDR,[CONNECTION SETUP] */
/* 108,[0x0c47,OGF:0x03,OCF:0x0047] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Page_Scan_TypeStru
{
    UINT8 page_scan_type;                  /* [165],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[CONNECTION SETUP] */
/* 108,[0x0c47,OGF:0x03,OCF:0x0047] Return */
struct HCI_Write_Page_Scan_TypeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[PHYSICAL LINKS] */
/* 109,[0x0c48,OGF:0x03,OCF:0x0048] Return */
struct HCI_Read_AFH_Channel_Assessment_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 afh_channel_assessment_mode;     /* [166],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.2,BREDR,[PHYSICAL LINKS] */
/* 110,[0x0c49,OGF:0x03,OCF:0x0049] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_AFH_Channel_Assessment_ModeStru
{
    UINT8 afh_channel_assessment_mode;     /* [166],Enum */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[PHYSICAL LINKS] */
/* 110,[0x0c49,OGF:0x03,OCF:0x0049] Return */
struct HCI_Write_AFH_Channel_Assessment_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 111,[0x0c51,OGF:0x03,OCF:0x0051] Return */
struct HCI_Read_Extended_Inquiry_ResponseCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 fec_required;                    /* [167],Enum */
    UINT8 extended_inquiry_response[240];  /* [168],Val */
};/* 0x55,0xc3,0x03[LenI:3] */

/* 2.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 112,[0x0c52,OGF:0x03,OCF:0x0052] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Extended_Inquiry_ResponseStru
{
    UINT8 fec_required;                    /* [167],Enum */
    UINT8 extended_inquiry_response[240];  /* [168],Val */
};/* 0x35,0x3c[LenI:2] */

/* 2.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 112,[0x0c52,OGF:0x03,OCF:0x0052] Return */
struct HCI_Write_Extended_Inquiry_ResponseCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 113,[0x0c53,OGF:0x03,OCF:0x0053] Command */
/* [Encryption_Key_Refresh_Complete][0x30],P:status[1],connection_handle[2] */
struct HCI_Refresh_Encryption_KeyStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 114,[0x0c55,OGF:0x03,OCF:0x0055] Return */
struct HCI_Read_Simple_Pairing_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 simple_pairing_mode;             /* [172],Enum */
};/* 0x55,0x00[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 115,[0x0c56,OGF:0x03,OCF:0x0056] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Simple_Pairing_ModeStru
{
    UINT8 simple_pairing_mode;             /* [172],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 115,[0x0c56,OGF:0x03,OCF:0x0056] Return */
struct HCI_Write_Simple_Pairing_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 116,[0x0c57,OGF:0x03,OCF:0x0057] Return */
struct HCI_Read_Local_OOB_DataCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 c[16];                           /* [173],Val */
    UINT8 r[16];                           /* [174],Val */
};/* 0xe5,0xfb,0x00[LenI:3] */

/* 2.1,BREDR,[DEVICE DISCOVERY] */
/* 117,[0x0c58,OGF:0x03,OCF:0x0058] Return */
struct HCI_Read_Inquiry_Response_Transmit_Power_LevelCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 tx_power;                        /* [175],Val */
};/* 0x55,0x00[LenI:2] */

/* 2.1,BREDR,[DEVICE DISCOVERY] */
/* 118,[0x0c59,OGF:0x03,OCF:0x0059] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Inquiry_Transmit_Power_LevelStru
{
    UINT8 tx_power;                        /* [175],Val */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[DEVICE DISCOVERY] */
/* 118,[0x0c59,OGF:0x03,OCF:0x0059] Return */
struct HCI_Write_Inquiry_Transmit_Power_LevelCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 119,[0x0c5a,OGF:0x03,OCF:0x005a] Return */
struct HCI_Read_Default_Erroneous_Data_ReportingCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 erroneous_data_reporting;        /* [177],Enum */
};/* 0x55,0x00[LenI:2] */

/* 2.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 120,[0x0c5b,OGF:0x03,OCF:0x005b] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Default_Erroneous_Data_ReportingStru
{
    UINT8 erroneous_data_reporting;        /* [177],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[CONTROLLER CONFIGURATION] */
/* 120,[0x0c5b,OGF:0x03,OCF:0x005b] Return */
struct HCI_Write_Default_Erroneous_Data_ReportingCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 121,[0x0c5f,OGF:0x03,OCF:0x005f] Command */
/* [Enhanced_Flush_Complete][0x39],P:handle[2] */
struct HCI_Enhanced_FlushStru
{
    UINT16 handle;                         /* [212],Val */
    UINT8 packet_type_flush;               /* [178],Enum */
};/* 0x59,0x00[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 122,[0x0c60,OGF:0x03,OCF:0x0060] Command */
/* [Command_Complete][0x0E],R:status[1],bd[6] */
struct HCI_Send_Keypress_NotificationStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 notification_type;               /* [176],Enum */
};/* 0x56,0x01[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 122,[0x0c60,OGF:0x03,OCF:0x0060] Return */
struct HCI_Send_Keypress_NotificationCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 3.0,BREDR/AMP,[HOST FLOW CONTROL] */
/* 123,[0x0c63,OGF:0x03,OCF:0x0063] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Set_Event_Mask_Page_2Stru
{
    UINT8 event_mask_page_2[8];            /* [341],Mask64 */
};/* 0x1e[LenI:1] */

/* 3.0,BREDR/AMP,[HOST FLOW CONTROL] */
/* 123,[0x0c63,OGF:0x03,OCF:0x0063] Return */
struct HCI_Set_Event_Mask_Page_2CompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
/* 124,[0x0c66,OGF:0x03,OCF:0x0066] Return */
struct HCI_Read_Flow_Control_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 flow_control_mode;               /* [184],Enum */
};/* 0x55,0x00[LenI:2] */

/* 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
/* 125,[0x0c67,OGF:0x03,OCF:0x0067] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Flow_Control_ModeStru
{
    UINT8 flow_control_mode;               /* [184],Enum */
};/* 0x05[LenI:1] */

/* 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
/* 125,[0x0c67,OGF:0x03,OCF:0x0067] Return */
struct HCI_Write_Flow_Control_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 3.0,BREDR,[LINK INFORMATION] */
/* 126,[0x0c68,OGF:0x03,OCF:0x0068] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],transmit_power_level_gfsk[1],transmit_power_level_dqpsk[1],transmit_power_level_8dpsk[1] */
struct HCI_Read_Enhanced_Transmit_Power_LevelStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 type;                            /* [148],Enum */
};/* 0x59,0x00[LenI:2] */

/* 3.0,BREDR,[LINK INFORMATION] */
/* 126,[0x0c68,OGF:0x03,OCF:0x0068] Return */
struct HCI_Read_Enhanced_Transmit_Power_LevelCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 transmit_power_level_gfsk;       /* [185],Val */
    UINT8 transmit_power_level_dqpsk;      /* [186],Val */
    UINT8 transmit_power_level_8dpsk;      /* [187],Val */
};/* 0x95,0x55,0x05[LenI:3] */

/* 4.0,BREDR,[CONTROLLER CONFIGURATION] */
/* 127,[0x0c6c,OGF:0x03,OCF:0x006c] Return */
struct HCI_Read_LE_Host_SupportCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 le_supported_host;               /* [195],Enum */
    UINT8 simultaneous_le_host;            /* [196],Enum */
};/* 0x55,0x05[LenI:2] */

/* 4.0,BREDR,[CONTROLLER CONFIGURATION] */
/* 128,[0x0c6d,OGF:0x03,OCF:0x006d] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_LE_Host_SupportStru
{
    UINT8 le_supported_host;               /* [195],Enum */
    UINT8 simultaneous_le_host;            /* [196],Enum */
};/* 0x55,0x00[LenI:2] */

/* 4.0,BREDR,[CONTROLLER CONFIGURATION] */
/* 128,[0x0c6d,OGF:0x03,OCF:0x006d] Return */
struct HCI_Write_LE_Host_SupportCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */


/*---------------------------------------------------------------------------------*/
/*                           Informational Param - 0x1000                          */
/*---------------------------------------------------------------------------------*/
/* 1.1,All,[CONTROLLER INFORMATION] */
/* 129,[0x1001,OGF:0x04,OCF:0x0001] Return */
struct HCI_Read_Local_Version_InformationCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 hci_version;                     /* [197],Enum */
    UINT16 hci_revision;                   /* [198],Val */
    UINT8 lmp_version;                     /* [199],Enum */
    UINT16 manufacturer_name;              /* [200],Enum */
    UINT16 lmp_subversion;                 /* [201],Val */
};/* 0x55,0x59,0x99,0x00[LenI:4] */

/* 1.2,All,[CONTROLLER INFORMATION] */
/* 130,[0x1002,OGF:0x04,OCF:0x0002] Return */
struct HCI_Read_Local_Supported_CommandsCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 supported_commands[64];          /* [342],Mask64 */
};/* 0x35,0x10[LenI:2] */

/* 1.1,All,[CONTROLLER INFORMATION] */
/* 131,[0x1003,OGF:0x04,OCF:0x0003] Return */
struct HCI_Read_Local_Supported_FeaturesCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 lmp_features[8];                 /* [345],Mask64 */
};/* 0xe5,0x01[LenI:2] */

/* 1.2,BREDR,[CONTROLLER INFORMATION] */
/* 132,[0x1004,OGF:0x04,OCF:0x0004] Command */
/* [Command_Complete][0x0E],R:status[1],page_number[1],max_page_number[1],extended_lmp_features[8] */
struct HCI_Read_Local_Extended_FeaturesStru
{
    UINT8 page_number;                     /* [202],Val */
};/* 0x05[LenI:1] */

/* 1.2,BREDR,[CONTROLLER INFORMATION] */
/* 132,[0x1004,OGF:0x04,OCF:0x0004] Return */
struct HCI_Read_Local_Extended_FeaturesCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 page_number;                     /* [202],Val */
    UINT8 max_page_number;                 /* [203],Val */
    UINT8 extended_lmp_features[8];        /* [347],Mask64 */
};/* 0x55,0xe5,0x01[LenI:3] */

/* 1.1,All,[CONTROLLER FLOW CONTROL] */
/* 133,[0x1005,OGF:0x04,OCF:0x0005] Return */
struct HCI_Read_Buffer_SizeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 hc_acl_data_packet_length;      /* [205],Val */
    UINT8 hc_synchronous_data_packet_length;/* [206],Val */
    UINT16 hc_total_num_acl_data_packets;  /* [207],Val */
    UINT16 hc_total_num_synchronous_data_packets;/* [208],Val */
};/* 0x95,0x95,0x09[LenI:3] */

/* 1.1,BREDR,[CONTROLLER INFORMATION] */
/* 134,[0x1007,OGF:0x04,OCF:0x0007] Return */
struct HCI_Read_Country_CodeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 country_code;                    /* [013],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR/LE,[CONTROLLER INFORMATION] */
/* 135,[0x1009,OGF:0x04,OCF:0x0009] Return */
struct HCI_Read_BD_ADDRCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
/* 136,[0x100a,OGF:0x04,OCF:0x000a] Return */
struct HCI_Read_Data_Block_SizeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 max_acl_data_packet_length;     /* [209],Val */
    UINT16 data_block_length;              /* [210],Val */
    UINT16 total_num_data_blocks;          /* [211],Val */
};/* 0x95,0x99,0x00[LenI:3] */


/*---------------------------------------------------------------------------------*/
/*                              Status Param - 0x1400                              */
/*---------------------------------------------------------------------------------*/
/* 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 137,[0x1401,OGF:0x05,OCF:0x0001] Command */
/* [Command_Complete][0x0E],R:status[1],handle[2],failed_contact_counter[2] */
struct HCI_Read_Failed_Contact_CounterStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 137,[0x1401,OGF:0x05,OCF:0x0001] Return */
struct HCI_Read_Failed_Contact_CounterCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 handle;                         /* [212],Val */
    UINT16 failed_contact_counter;         /* [213],Val */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 138,[0x1402,OGF:0x05,OCF:0x0002] Command */
/* [Command_Complete][0x0E],R:status[1],handle[2] */
struct HCI_Reset_Failed_Contact_CounterStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 138,[0x1402,OGF:0x05,OCF:0x0002] Return */
struct HCI_Reset_Failed_Contact_CounterCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 handle;                         /* [212],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR/AMP,[LINK INFORMATION] */
/* 139,[0x1403,OGF:0x05,OCF:0x0003] Command */
/* [Command_Complete][0x0E],R:status[1],handle[2],link_quality[1] */
struct HCI_Read_Link_QualityStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR/AMP,[LINK INFORMATION] */
/* 139,[0x1403,OGF:0x05,OCF:0x0003] Return */
struct HCI_Read_Link_QualityCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 handle;                         /* [212],Val */
    UINT8 link_quality;                    /* [214],Val */
};/* 0x95,0x05[LenI:2] */

/* 1.1,All,[LINK INFORMATION] */
/* 140,[0x1405,OGF:0x05,OCF:0x0005] Command */
/* [Command_Complete][0x0E],R:status[1],handle[2],rssi[1] */
struct HCI_Read_RSSIStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 1.1,All,[LINK INFORMATION] */
/* 140,[0x1405,OGF:0x05,OCF:0x0005] Return */
struct HCI_Read_RSSICompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 handle;                         /* [212],Val */
    UINT8 rssi;                            /* [215],Val */
};/* 0x95,0x05[LenI:2] */

/* 1.2,BREDR,[LINK INFORMATION] */
/* 141,[0x1406,OGF:0x05,OCF:0x0006] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],afh_mode[1],afh_channel_map[10] */
struct HCI_Read_AFH_Channel_MapStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 1.2,BREDR,[LINK INFORMATION] */
/* 141,[0x1406,OGF:0x05,OCF:0x0006] Return */
struct HCI_Read_AFH_Channel_MapCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 afh_mode;                        /* [216],Enum */
    UINT8 afh_channel_map[10];             /* [217],Val */
};/* 0x95,0x65,0x02[LenI:3] */

/* 1.2,BREDR,[LINK INFORMATION] */
/* 142,[0x1407,OGF:0x05,OCF:0x0007] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],clock[4],accuracy[2] */
struct HCI_Read_ClockStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 which_clock;                     /* [218],Enum */
};/* 0x59,0x00[LenI:2] */

/* 1.2,BREDR,[LINK INFORMATION] */
/* 142,[0x1407,OGF:0x05,OCF:0x0007] Return */
struct HCI_Read_ClockCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT32 clock;                          /* [219],Val */
    UINT16 accuracy;                       /* [221],Time */
};/* 0x95,0x9d,0x00[LenI:3] */

/* 3.0,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 143,[0x1408,OGF:0x05,OCF:0x0008] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],key_size[1] */
struct HCI_Read_Encryption_Key_SizeStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 3.0,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 143,[0x1408,OGF:0x05,OCF:0x0008] Return */
struct HCI_Read_Encryption_Key_SizeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 key_size;                        /* [222],Val */
};/* 0x95,0x05[LenI:2] */


/*---------------------------------------------------------------------------------*/
/*                                 Testing - 0x1800                                */
/*---------------------------------------------------------------------------------*/
/* 1.1,BREDR,[TESTING] */
/* 144,[0x1801,OGF:0x06,OCF:0x0001] Return */
struct HCI_Read_Loopback_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 loopback_mode;                   /* [235],Enum */
};/* 0x55,0x00[LenI:2] */

/* 1.1,BREDR,[TESTING] */
/* 145,[0x1802,OGF:0x06,OCF:0x0002] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Loopback_ModeStru
{
    UINT8 loopback_mode;                   /* [235],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[TESTING] */
/* 145,[0x1802,OGF:0x06,OCF:0x0002] Return */
struct HCI_Write_Loopback_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[TESTING] */
/* 146,[0x1803,OGF:0x06,OCF:0x0003] Return */
struct HCI_Enable_Device_Under_Test_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[TESTING] */
/* 147,[0x1804,OGF:0x06,OCF:0x0004] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_Write_Simple_Pairing_Debug_ModeStru
{
    UINT8 simple_pairing_debug_mode;       /* [236],Enum */
};/* 0x05[LenI:1] */

/* 2.1,BREDR,[TESTING] */
/* 147,[0x1804,OGF:0x06,OCF:0x0004] Return */
struct HCI_Write_Simple_Pairing_Debug_ModeCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */


/*---------------------------------------------------------------------------------*/
/*                              LE Controller - 0x2000                             */
/*---------------------------------------------------------------------------------*/
/* 4.0,LE,[HOST FLOW CONTROL] */
/* 148,[0x2001,OGF:0x08,OCF:0x0001] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Event_MaskStru
{
    UINT8 le_event_mask[8];                /* [343],Mask64 */
};/* 0x1e[LenI:1] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 148,[0x2001,OGF:0x08,OCF:0x0001] Return */
struct HCI_LE_Set_Event_MaskCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONTROLLER FLOW CONTROL] */
/* 149,[0x2002,OGF:0x08,OCF:0x0002] Return */
struct HCI_LE_Read_Buffer_SizeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 hc_le_acl_data_packet_length;   /* [300],Val */
    UINT8 hc_total_num_le_acl_data_packets;/* [301],Val */
};/* 0x95,0x05[LenI:2] */

/* 4.0,LE,[CONTROLLER INFORMATION] */
/* 150,[0x2003,OGF:0x08,OCF:0x0003] Return */
struct HCI_LE_Read_Local_Supported_FeaturesCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 le_features[8];                  /* [297],Mask */
};/* 0xe5,0x01[LenI:2] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 151,[0x2005,OGF:0x08,OCF:0x0005] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Random_AddressStru
{
    UINT8 random_address[6];               /* [290],Val */
};/* 0x16[LenI:1] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 151,[0x2005,OGF:0x08,OCF:0x0005] Return */
struct HCI_LE_Set_Random_AddressCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 152,[0x2006,OGF:0x08,OCF:0x0006] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Advertising_ParametersStru
{
    UINT16 advertising_interval_min;       /* [302],Time */
    UINT16 advertising_interval_max;       /* [303],Time */
    UINT8 advertising_type;                /* [305],Enum */
    UINT8 own_address_type;                /* [286],Enum */
    UINT8 direct_address_type;             /* [287],Enum */
    UINT8 direct_address[6];               /* [289],Val */
    UINT8 advertising_channel_map;         /* [306],Mask */
    UINT8 advertising_filter_policy;       /* [307],Enum */
};/* 0x99,0x55,0x65,0x55,0x01[LenI:5] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 152,[0x2006,OGF:0x08,OCF:0x0006] Return */
struct HCI_LE_Set_Advertising_ParametersCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[LINK INFORMATION] */
/* 153,[0x2007,OGF:0x08,OCF:0x0007] Return */
struct HCI_LE_Read_Advertising_Channel_Tx_PowerCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 transmit_power_level;            /* [149],Val */
};/* 0x55,0x00[LenI:2] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 154,[0x2008,OGF:0x08,OCF:0x0008] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Advertising_DataStru
{
    UINT8 advertising_data_length;         /* [309],Val */
    UINT8 advertising_data[31];            /* [310],Val */
};/* 0xf5,0x07[LenI:2] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 154,[0x2008,OGF:0x08,OCF:0x0008] Return */
struct HCI_LE_Set_Advertising_DataCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 155,[0x2009,OGF:0x08,OCF:0x0009] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Scan_Response_DataStru
{
    UINT8 scan_response_data_length;       /* [311],Val */
    UINT8 scan_response_data[31];          /* [312],Val */
};/* 0xf5,0x07[LenI:2] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 155,[0x2009,OGF:0x08,OCF:0x0009] Return */
struct HCI_LE_Set_Scan_Response_DataCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 156,[0x200a,OGF:0x08,OCF:0x000a] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Advertise_EnableStru
{
    UINT8 advertising_enable;              /* [313],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONTROLLER CONFIGURATION] */
/* 156,[0x200a,OGF:0x08,OCF:0x000a] Return */
struct HCI_LE_Set_Advertise_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[DEVICE DISCOVERY] */
/* 157,[0x200b,OGF:0x08,OCF:0x000b] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Scan_ParametersStru
{
    UINT8 le_scan_type;                    /* [314],Enum */
    UINT16 le_scan_interval;               /* [315],Time */
    UINT16 le_scan_window;                 /* [316],Time */
    UINT8 own_address_type;                /* [286],Enum */
    UINT8 scanning_filter_policy;          /* [317],Enum */
};/* 0x95,0x59,0x05[LenI:3] */

/* 4.0,LE,[DEVICE DISCOVERY] */
/* 157,[0x200b,OGF:0x08,OCF:0x000b] Return */
struct HCI_LE_Set_Scan_ParametersCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[DEVICE DISCOVERY] */
/* 158,[0x200c,OGF:0x08,OCF:0x000c] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Scan_EnableStru
{
    UINT8 le_scan_enable;                  /* [318],Enum */
    UINT8 filter_duplicates;               /* [319],Enum */
};/* 0x55,0x00[LenI:2] */

/* 4.0,LE,[DEVICE DISCOVERY] */
/* 158,[0x200c,OGF:0x08,OCF:0x000c] Return */
struct HCI_LE_Set_Scan_EnableCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONNECTION SETUP] */
/* 159,[0x200d,OGF:0x08,OCF:0x000d] Command */
/* [LE_Connection_Complete][0x01],P:status[1],connection_handle[2],role[1],peer_address_type[1],peer_address[6],conn_interval[2],leconn_latency[2],supervision_timeout[2],master_clock_accuracy[1] */
struct HCI_LE_Create_ConnectionStru
{
    UINT16 le_scan_interval;               /* [315],Time */
    UINT16 le_scan_window;                 /* [316],Time */
    UINT8 initiator_filter_policy;         /* [320],Enum */
    UINT8 peer_address_type;               /* [285],Enum */
    UINT8 peer_address[6];                 /* [288],Val */
    UINT8 own_address_type;                /* [286],Enum */
    UINT16 conn_interval_min;              /* [321],Time */
    UINT16 conn_interval_max;              /* [322],Time */
    UINT16 leconn_latency;                 /* [323],Val */
    UINT16 supervision_timeout;            /* [292],Time */
    UINT16 min_ce_length;                  /* [324],Time */
    UINT16 max_ce_length;                  /* [325],Time */
};/* 0x99,0x55,0x56,0x65,0x66,0x66,0x02[LenI:7] */

/* 4.0,LE,[CONNECTION SETUP] */
/* 160,[0x200e,OGF:0x08,OCF:0x000e] Return */
struct HCI_LE_Create_Connection_CancelCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 161,[0x200f,OGF:0x08,OCF:0x000f] Return */
struct HCI_LE_Read_White_List_SizeCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 white_list_size;                 /* [326],Val */
};/* 0x55,0x00[LenI:2] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 162,[0x2010,OGF:0x08,OCF:0x0010] Return */
struct HCI_LE_Clear_White_ListCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 163,[0x2011,OGF:0x08,OCF:0x0011] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Add_Device_To_White_ListStru
{
    UINT8 peer_address_type;               /* [285],Enum */
    UINT8 peer_address[6];                 /* [288],Val */
};/* 0x65,0x01[LenI:2] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 163,[0x2011,OGF:0x08,OCF:0x0011] Return */
struct HCI_LE_Add_Device_To_White_ListCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 164,[0x2012,OGF:0x08,OCF:0x0012] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Remove_Device_From_White_ListStru
{
    UINT8 peer_address_type;               /* [285],Enum */
    UINT8 peer_address[6];                 /* [288],Val */
};/* 0x65,0x01[LenI:2] */

/* 4.0,LE,[HOST FLOW CONTROL] */
/* 164,[0x2012,OGF:0x08,OCF:0x0012] Return */
struct HCI_LE_Remove_Device_From_White_ListCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[CONNECTION STATE] */
/* 165,[0x2013,OGF:0x08,OCF:0x0013] Command */
/* [LE_Connection_Update_Complete][0x03],P:status[1],connection_handle[2],conn_interval[2],leconn_latency[2],supervision_timeout[2] */
struct HCI_LE_Connection_UpdateStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 conn_interval_min;              /* [321],Time */
    UINT16 conn_interval_max;              /* [322],Time */
    UINT16 leconn_latency;                 /* [323],Val */
    UINT16 supervision_timeout;            /* [292],Time */
    UINT16 min_ce_length;                  /* [324],Time */
    UINT16 max_ce_length;                  /* [325],Time */
};/* 0x99,0x99,0x99,0x09[LenI:4] */

/* 4.0,LE,[PHYSICAL LINKS] */
/* 166,[0x2014,OGF:0x08,OCF:0x0014] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Set_Host_Channel_ClassificationStru
{
    UINT8 channel_map[5];                  /* [327],Val */
};/* 0x12[LenI:1] */

/* 4.0,LE,[PHYSICAL LINKS] */
/* 166,[0x2014,OGF:0x08,OCF:0x0014] Return */
struct HCI_LE_Set_Host_Channel_ClassificationCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[LINK INFORMATION] */
/* 167,[0x2015,OGF:0x08,OCF:0x0015] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2],channel_map[5] */
struct HCI_LE_Read_Channel_MapStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 4.0,LE,[LINK INFORMATION] */
/* 167,[0x2015,OGF:0x08,OCF:0x0015] Return */
struct HCI_LE_Read_Channel_MapCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 channel_map[5];                  /* [327],Val */
};/* 0x95,0x12[LenI:2] */

/* 4.0,LE,[REMOTE INFORMATION] */
/* 168,[0x2016,OGF:0x08,OCF:0x0016] Command */
/* [LE_Read_Remote_Used_Features_Complete][0x04],P:status[1],connection_handle[2],le_features[8] */
struct HCI_LE_Read_Remote_Used_FeaturesStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 169,[0x2017,OGF:0x08,OCF:0x0017] Command */
/* [Command_Complete][0x0E],R:status[1],encrypted_data[16] */
struct HCI_LE_EncryptStru
{
    UINT8 key[16];                         /* [328],Val */
    UINT8 plaintext_data[16];              /* [329],Val */
};/* 0xbe,0x0f[LenI:2] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 169,[0x2017,OGF:0x08,OCF:0x0017] Return */
struct HCI_LE_EncryptCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 encrypted_data[16];              /* [330],Val */
};/* 0xe5,0x03[LenI:2] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 170,[0x2018,OGF:0x08,OCF:0x0018] Return */
struct HCI_LE_RandCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 random_number[8];                /* [298],Val */
};/* 0xe5,0x01[LenI:2] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 171,[0x2019,OGF:0x08,OCF:0x0019] Command */
/* [Encryption_Key_Refresh_Complete][0x30],P:status[1],connection_handle[2] */
/* [Encryption_Change][0x08],P:status[1],connection_handle[2],encryption_enable[1] */
struct HCI_LE_Start_EncryptionStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 random_number[8];                /* [298],Val */
    UINT16 encryption_diversifier;         /* [299],Val */
    UINT8 long_term_key[16];               /* [333],Val */
};/* 0xe9,0xa5,0x0f[LenI:3] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 172,[0x201a,OGF:0x08,OCF:0x001a] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_LE_Long_Term_Key_Request_ReplyStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 long_term_key[16];               /* [333],Val */
};/* 0xe9,0x03[LenI:2] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 172,[0x201a,OGF:0x08,OCF:0x001a] Return */
struct HCI_LE_Long_Term_Key_Request_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 173,[0x201b,OGF:0x08,OCF:0x001b] Command */
/* [Command_Complete][0x0E],R:status[1],connection_handle[2] */
struct HCI_LE_Long_Term_Key_Request_Negative_ReplyStru
{
    UINT16 connection_handle;              /* [002],Val */
};/* 0x09[LenI:1] */

/* 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
/* 173,[0x201b,OGF:0x08,OCF:0x001b] Return */
struct HCI_LE_Long_Term_Key_Request_Negative_ReplyCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 4.0,LE,[CONTROLLER INFORMATION] */
/* 174,[0x201c,OGF:0x08,OCF:0x001c] Return */
struct HCI_LE_Read_Supported_StatesCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 le_states[8];                    /* [344],Mask64 */
};/* 0xe5,0x01[LenI:2] */

/* 4.0,LE,[TESTING] */
/* 175,[0x201d,OGF:0x08,OCF:0x001d] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Receiver_TestStru
{
    UINT8 rx_frequency;                    /* [334],Val */
};/* 0x05[LenI:1] */

/* 4.0,LE,[TESTING] */
/* 175,[0x201d,OGF:0x08,OCF:0x001d] Return */
struct HCI_LE_Receiver_TestCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[TESTING] */
/* 176,[0x201e,OGF:0x08,OCF:0x001e] Command */
/* [Command_Complete][0x0E],R:status[1] */
struct HCI_LE_Transmitter_TestStru
{
    UINT8 tx_frequency;                    /* [335],Val */
    UINT8 length_of_test_data;             /* [336],Val */
    UINT8 packet_payload;                  /* [337],Enum */
};/* 0x55,0x05[LenI:2] */

/* 4.0,LE,[TESTING] */
/* 176,[0x201e,OGF:0x08,OCF:0x001e] Return */
struct HCI_LE_Transmitter_TestCompStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 4.0,LE,[TESTING] */
/* 177,[0x201f,OGF:0x08,OCF:0x001f] Return */
struct HCI_LE_Test_EndCompStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 number_of_packets;              /* [338],Val */
};/* 0x95,0x00[LenI:2] */


/*---------------------------------------------------------------------------------*/
/*                                 Event Structures                                */
/*---------------------------------------------------------------------------------*/
/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 000,[0x01] Event */
struct HCI_Inquiry_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[DEVICE DISCOVERY] */
/* 001,[0x02] Event */
struct HCI_Inquiry_ResultEvStru
{
    UINT8 num_responses;                   /* [006],Val */
    struct HCI_Inquiry_ResultSubStru
    {
        UINT8 bd[6];                          /* [204],Val */
        UINT8 page_scan_repetition_mode;      /* [016],Enum */
        UINT8 page_scan_period_mode;          /* [015],Enum */
        UINT8 page_scan_mode;                 /* [014],Enum */
        UINT8 class_of_device[3];             /* [110],Mask */
        UINT16 clock_offset;                  /* [019],Mask */
    } n[1];
};/* 0x61,0x55,0x95,0x92,0x00[LenI:5] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 002,[0x03] Event */
struct HCI_Connection_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 bd[6];                           /* [204],Val */
    UINT8 link_type;                       /* [239],Enum */
    UINT8 encryption_enable;               /* [023],Enum */
};/* 0x95,0x56,0x15[LenI:3] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 003,[0x04] Event */
struct HCI_Connection_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 class_of_device[3];              /* [110],Mask */
    UINT8 link_type;                       /* [239],Enum */
};/* 0x96,0x52,0x00[LenI:3] */

/* 1.1,BREDR/LE,[CONNECTION SETUP] */
/* 004,[0x05] Event */
struct HCI_Disconnection_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 reason;                          /* [001],Enum */
};/* 0x95,0x05[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 005,[0x06] Event */
struct HCI_Authentication_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[REMOTE INFORMATION] */
/* 006,[0x07] Event */
struct HCI_Remote_Name_Request_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
    UINT8 remote_name[248];                /* [241],String */
};/* 0x65,0x8d,0x0f[LenI:3] */

/* 1.1,BREDR/LE,[AUTHENTICATION AND ENCRYPTION] */
/* 007,[0x08] Event */
struct HCI_Encryption_ChangeEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 encryption_enable;               /* [023],Enum */
};/* 0x95,0x05[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 008,[0x09] Event */
struct HCI_Change_Connection_Link_Key_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 009,[0x0a] Event */
struct HCI_Master_Link_Key_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 key_flag;                        /* [025],Enum */
};/* 0x95,0x05[LenI:2] */

/* 1.1,BREDR,[REMOTE INFORMATION] */
/* 010,[0x0b] Event */
struct HCI_Read_Remote_Supported_Features_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 lmp_features[8];                 /* [345],Mask64 */
};/* 0x95,0x1e[LenI:2] */

/* 1.1,BREDR/LE,[REMOTE INFORMATION] */
/* 011,[0x0c] Event */
struct HCI_Read_Remote_Version_Information_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 lmp_version;                     /* [199],Enum */
    UINT16 manufacturer_name;              /* [200],Enum */
    UINT16 lmp_subversion;                 /* [201],Val */
};/* 0x95,0x95,0x09[LenI:3] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 012,[0x0d] Event */
struct HCI_QoS_Setup_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 flags;                           /* [258],Val */
    UINT8 service_type;                    /* [115],Enum */
    UINT32 token_rate;                     /* [242],Val */
    UINT32 peak_bandwidth;                 /* [244],Val */
    UINT32 latency;                        /* [245],Val */
    UINT32 delay_variation;                /* [246],Val */
};/* 0x95,0x55,0xdd,0xdd,0x00[LenI:5] */

/* 1.1,All,[GENERIC EVENTS] */
/* 013,[0x0e] Event */
struct HCI_Command_CompleteEvStru
{
    UINT8 num_hci_command_packets;         /* [247],Val */
    UINT16 command_opcode;                 /* [248],Val */
    UINT8 return_parameters_plen;          /* Data Need to Phase by context param */
    UINT8 return_parameters[1];            /* [249],Val */
};/* 0x95,0x02[LenI:2] */

/* 1.1,All,[GENERIC EVENTS] */
/* 014,[0x0f] Event */
struct HCI_Command_StatusEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 num_hci_command_packets;         /* [247],Val */
    UINT16 command_opcode;                 /* [248],Val */
};/* 0x55,0x09[LenI:2] */

/* 1.1,All,[GENERIC EVENTS] */
/* 015,[0x10] Event */
struct HCI_Hardware_ErrorEvStru
{
    UINT8 hardware_code;                   /* [250],Val */
};/* 0x05[LenI:1] */

/* 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 016,[0x11] Event */
struct HCI_Flush_OccurredEvStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[PICONET STRUCTURE] */
/* 017,[0x12] Event */
struct HCI_Role_ChangeEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
    UINT8 role;                            /* [022],Enum */
};/* 0x65,0x15[LenI:2] */

/* 1.1,All,[CONTROLLER FLOW CONTROL] */
/* 018,[0x13] Event */
struct HCI_Number_Of_Completed_PacketsEvStru
{
    UINT8 number_of_handles;               /* [156],Val */
    struct HCI_Number_Of_Completed_PacketsSubStru
    {
        UINT16 connection_handle;             /* [002],Val */
        UINT16 hc_num_of_completed_packets;   /* [251],Val */
    } n[1];
};/* 0x91,0x09[LenI:2] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 019,[0x14] Event */
struct HCI_Mode_ChangeEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 current_mode;                    /* [252],Enum */
    UINT16 interval;                       /* [253],Time */
};/* 0x95,0x95,0x00[LenI:3] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 020,[0x15] Event */
struct HCI_Return_Link_KeysEvStru
{
    UINT8 num_keys;                        /* [124],Val */
    struct HCI_Return_Link_KeysSubStru
    {
        UINT8 bd[6];                          /* [204],Val */
        UINT8 link_key[16];                   /* [254],Val */
    } n[1];
};/* 0x61,0xf9,0x00[LenI:3] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 021,[0x16] Event */
struct HCI_PIN_Code_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 022,[0x17] Event */
struct HCI_Link_Key_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 023,[0x18] Event */
struct HCI_Link_Key_NotificationEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 link_key[16];                    /* [254],Val */
    UINT8 key_type;                        /* [255],Enum */
};/* 0x96,0x5f,0x00[LenI:3] */

/* 1.1,BREDR,[TESTING] */
/* 024,[0x19] Event */
struct HCI_Loopback_CommandEvStru
{
    UINT8 hci_command_packet_plen;         /* Data Need to Phase by context param */
    UINT8 hci_command_packet[1];           /* [256],Val */
};/* 0x02[LenI:1] */

/* 1.1,All,[HOST FLOW CONTROL] */
/* 025,[0x1a] Event */
struct HCI_Data_Buffer_OverflowEvStru
{
    UINT8 link_type;                       /* [239],Enum */
};/* 0x05[LenI:1] */

/* 1.1,BREDR,[CONNECTION STATE] */
/* 026,[0x1b] Event */
struct HCI_Max_Slots_ChangeEvStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 lmp_max_slots;                   /* [257],Val */
};/* 0x59,0x00[LenI:2] */

/* 1.1,BREDR,[LINK INFORMATION] */
/* 027,[0x1c] Event */
struct HCI_Read_Clock_Offset_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 clock_offset;                   /* [019],Mask */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[PHYSICAL LINKS] */
/* 028,[0x1d] Event */
struct HCI_Connection_Packet_Type_ChangedEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 packet_type;                    /* [010],Mask */
};/* 0x95,0x09[LenI:2] */

/* 1.1,BREDR,[QUALITY OF SERVICE] */
/* 029,[0x1e] Event */
struct HCI_QoS_ViolationEvStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 030,[0x1f] Event */
struct HCI_Page_Scan_Mode_ChangeEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 page_scan_mode;                  /* [014],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.1,BREDR,[CONNECTION SETUP] */
/* 031,[0x20] Event */
struct HCI_Page_Scan_Repetition_Mode_ChangeEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 page_scan_repetition_mode;       /* [016],Enum */
};/* 0x56,0x01[LenI:2] */

/* 1.2,BREDR,[QUALITY OF SERVICE] */
/* 032,[0x21] Event */
struct HCI_Flow_Specification_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 flags;                           /* [258],Val */
    UINT8 flow_direction;                  /* [117],Enum */
    UINT8 service_type;                    /* [115],Enum */
    UINT32 token_rate;                     /* [242],Val */
    UINT32 token_bucket_size;              /* [243],Val */
    UINT32 peak_bandwidth;                 /* [244],Val */
    UINT32 latency;                        /* [245],Val */
};/* 0x95,0x55,0xd5,0xdd,0x0d[LenI:5] */

/* 1.2,BREDR,[DEVICE DISCOVERY] */
/* 033,[0x22] Event */
struct HCI_Inquiry_Result_with_RSSIEvStru
{
    UINT8 num_responses;                   /* [006],Val */
    struct HCI_Inquiry_Result_with_RSSISubStru
    {
        UINT8 bd[6];                          /* [204],Val */
        UINT8 page_scan_repetition_mode;      /* [016],Enum */
        UINT8 page_scan_period_mode;          /* [015],Enum */
        UINT8 class_of_device[3];             /* [110],Mask */
        UINT16 clock_offset;                  /* [019],Mask */
        UINT8 rssi;                           /* [215],Val */
    } n[1];
};/* 0x61,0x55,0x29,0x59,0x00[LenI:5] */

/* 1.2,BREDR,[REMOTE INFORMATION] */
/* 034,[0x23] Event */
struct HCI_Read_Remote_Extended_Features_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 page_number;                     /* [202],Val */
    UINT8 max_page_number;                 /* [203],Val */
    UINT8 extended_lmp_features[8];        /* [347],Mask64 */
};/* 0x95,0x55,0x1e[LenI:3] */

/* 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 035,[0x2c] Event */
struct HCI_Synchronous_Connection_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 bd[6];                           /* [204],Val */
    UINT8 link_type;                       /* [239],Enum */
    UINT8 transmission_interval;           /* [259],Val */
    UINT8 retransmission_window;           /* [260],Val */
    UINT16 rx_packet_length;               /* [261],Val */
    UINT16 tx_packet_length;               /* [262],Val */
    UINT8 air_mode;                        /* [263],Enum */
};/* 0x95,0x56,0x55,0x65,0x16[LenI:5] */

/* 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
/* 036,[0x2d] Event */
struct HCI_Synchronous_Connection_ChangedEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 transmission_interval;           /* [259],Val */
    UINT8 retransmission_window;           /* [260],Val */
    UINT16 rx_packet_length;               /* [261],Val */
    UINT16 tx_packet_length;               /* [262],Val */
};/* 0x95,0x55,0x99,0x00[LenI:4] */

/* 2.1,BREDR,[CONNECTION STATE] */
/* 037,[0x2e] Event */
struct HCI_Sniff_SubratingEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 max_transmit_latency;           /* [264],Time */
    UINT16 max_receive_latency;            /* [265],Time */
    UINT16 min_remote_timeout;             /* [266],Time */
    UINT16 min_local_timeout;              /* [267],Time */
};/* 0x95,0x99,0x99,0x00[LenI:4] */

/* 2.1,BREDR,[DEVICE DISCOVERY] */
/* 038,[0x2f] Event */
struct HCI_Extended_Inquiry_ResultEvStru
{
    UINT8 num_responses;                   /* [006],Val */
    UINT8 bd[6];                           /* [204],Val */
    UINT8 page_scan_repetition_mode;       /* [016],Enum */
    UINT8 reserved;                        /* [017],Fix */
    UINT8 class_of_device[3];              /* [110],Mask */
    UINT16 clock_offset;                   /* [019],Mask */
    UINT8 rssi;                            /* [215],Val */
    UINT8 extended_inquiry_response[240];  /* [168],Val */
};/* 0x65,0x55,0x29,0x59,0xc3,0x03[LenI:6] */

/* 2.1,BREDR/LE,[AUTHENTICATION AND ENCRYPTION] */
/* 039,[0x30] Event */
struct HCI_Encryption_Key_Refresh_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
};/* 0x95,0x00[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 040,[0x31] Event */
struct HCI_IO_Capability_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 041,[0x32] Event */
struct HCI_IO_Capability_ResponseEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 io_capability;                   /* [112],Enum */
    UINT8 oob_data_present;                /* [113],Enum */
    UINT8 authentication_requirements;     /* [114],Enum */
};/* 0x56,0x55,0x01[LenI:3] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 042,[0x33] Event */
struct HCI_User_Confirmation_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT32 numeric_value;                  /* [268],Val */
};/* 0x56,0x03[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 043,[0x34] Event */
struct HCI_User_Passkey_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 044,[0x35] Event */
struct HCI_Remote_OOB_Data_RequestEvStru
{
    UINT8 bd[6];                           /* [204],Val */
};/* 0x16[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 045,[0x36] Event */
struct HCI_Simple_Pairing_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT8 bd[6];                           /* [204],Val */
};/* 0x65,0x01[LenI:2] */

/* 2.1,BREDR,[PHYSICAL LINKS] */
/* 046,[0x38] Event */
struct HCI_Link_Supervision_Timeout_ChangedEvStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT16 link_supervision_timeout;       /* [158],Time */
};/* 0x99,0x00[LenI:2] */

/* 2.1,BREDR/AMP,[QUALITY OF SERVICE] */
/* 047,[0x39] Event */
struct HCI_Enhanced_Flush_CompleteEvStru
{
    UINT16 handle;                         /* [212],Val */
};/* 0x09[LenI:1] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 048,[0x3b] Event */
struct HCI_User_Passkey_NotificationEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT32 passkey;                        /* [269],Val */
};/* 0x56,0x03[LenI:2] */

/* 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
/* 049,[0x3c] Event */
struct HCI_Keypress_NotificationEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 notification_type;               /* [176],Enum */
};/* 0x56,0x01[LenI:2] */

/* 2.1,BREDR,[REMOTE INFORMATION] */
/* 050,[0x3d] Event */
struct HCI_Remote_Host_Supported_Features_NotificationEvStru
{
    UINT8 bd[6];                           /* [204],Val */
    UINT8 host_supported_features[8];      /* [346],Mask */
};/* 0x96,0x07[LenI:2] */

/* 4.0,LE,[LE] */
/* 051,[0x3e] Event */
struct HCI_LE_MetaEvStru
{
    UINT8 sub_eventcode;                   /* [282],Val */
    UINT8 param_plen;                      /* Data Need to Phase by context param */
    UINT8 param[1];                        /* [283],Val */
};/* 0x25,0x00[LenI:2] */

/* 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
/* 052,[0x48] Event */
struct HCI_Number_Of_Completed_Data_BlocksEvStru
{
    UINT16 total_num_data_blocks;          /* [211],Val */
    UINT8 number_of_handles;               /* [156],Val */
    struct HCI_Number_Of_Completed_Data_BlocksSubStru
    {
        UINT16 handle;                        /* [212],Val */
        UINT16 num_of_completed_packets;      /* [274],Val */
        UINT16 num_of_completed_blocks;       /* [275],Val */
    } n[1];
};/* 0x19,0x99,0x09[LenI:3] */

/* 1.1,All,[VENDOR] */
/* 053,[0xff] Event */
struct HCI_VendorEvStru
{
    UINT8 vendordata_plen;                 /* Data Need to Phase by context param */
    UINT8 vendordata[1];                   /* [284],Val */
};/* 0x02[LenI:1] */


/*---------------------------------------------------------------------------------*/
/*                             LE Meta Event Structures                            */
/*---------------------------------------------------------------------------------*/
/* 00,[0x01] LE Meta Event */
struct HCI_LE_Connection_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 role;                            /* [022],Enum */
    UINT8 peer_address_type;               /* [285],Enum */
    UINT8 peer_address[6];                 /* [288],Val */
    UINT16 conn_interval;                  /* [291],Time */
    UINT16 leconn_latency;                 /* [323],Val */
    UINT16 supervision_timeout;            /* [292],Time */
    UINT8 master_clock_accuracy;           /* [293],Enum */
};/* 0x95,0x55,0x56,0x66,0x16[LenI:5] */

/* 01,[0x02] LE Meta Event */
struct HCI_LE_Advertising_ReportEvStru
{
    UINT8 num_reports;                     /* [294],Val */
    UINT8 param_plen;                      /* Data Need to Phase by context param */
    UINT8 param[1];                        /* [283],Val */
};/* 0x25,0x00[LenI:2] */

/* 02,[0x03] LE Meta Event */
struct HCI_LE_Connection_Update_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT16 conn_interval;                  /* [291],Time */
    UINT16 leconn_latency;                 /* [323],Val */
    UINT16 supervision_timeout;            /* [292],Time */
};/* 0x95,0x99,0x09[LenI:3] */

/* 03,[0x04] LE Meta Event */
struct HCI_LE_Read_Remote_Used_Features_CompleteEvStru
{
    UINT8 status;                          /* [001],Enum */
    UINT16 connection_handle;              /* [002],Val */
    UINT8 le_features[8];                  /* [297],Mask */
};/* 0x95,0x1e[LenI:2] */

/* 04,[0x05] LE Meta Event */
struct HCI_LE_Long_Term_Key_RequestEvStru
{
    UINT16 connection_handle;              /* [002],Val */
    UINT8 random_number[8];                /* [298],Val */
    UINT16 encrypted_diversifier;          /* [332],Val */
};/* 0xe9,0x25[LenI:2] */


/*---------------------------------------------------------------------------------*/
/*                         Structure Descriptors Data Table                        */
/*---------------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------------*/
/*                         HCI Spec OpCode for Command Code                        */
/*---------------------------------------------------------------------------------*/

enum
{

    /*---------------------------------------------------------------------------------*/
    /*                              Link Control - 0x0400                              */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_INQUIRY =                                          0x0401, /* 000,[C T], 1.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_INQUIRY_CANCEL =                                   0x0402, /* 001,[ R ], 1.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_PERIODIC_INQUIRY_MODE =                            0x0403, /* 002,[CR ], 1.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_EXIT_PERIODIC_INQUIRY_MODE =                       0x0404, /* 003,[ R ], 1.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_CREATE_CONNECTION =                                0x0405, /* 004,[C T], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_DISCONNECT =                                       0x0406, /* 005,[C T], 1.1,BREDR/LE,[CONNECTION SETUP] */
    HCI_OPC_ADD_SCO_CONNECTION =                               0x0407, /* 006,[C T], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_CREATE_CONNECTION_CANCEL =                         0x0408, /* 007,[CR ], 1.2,BREDR,[CONNECTION SETUP] */
    HCI_OPC_ACCEPT_CONNECTION_REQUEST =                        0x0409, /* 008,[C T], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_REJECT_CONNECTION_REQUEST =                        0x040a, /* 009,[C T], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_LINK_KEY_REQUEST_REPLY =                           0x040b, /* 010,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_LINK_KEY_REQUEST_NEGATIVE_REPLY =                  0x040c, /* 011,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_PIN_CODE_REQUEST_REPLY =                           0x040d, /* 012,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_PIN_CODE_REQUEST_NEGATIVE_REPLY =                  0x040e, /* 013,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_CHANGE_CONNECTION_PACKET_TYPE =                    0x040f, /* 014,[C T], 1.1,BREDR,[PHYSICAL LINKS] */
    HCI_OPC_AUTHENTICATION_REQUESTED =                         0x0411, /* 015,[C T], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_SET_CONNECTION_ENCRYPTION =                        0x0413, /* 016,[C T], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_CHANGE_CONNECTION_LINK_KEY =                       0x0415, /* 017,[C T], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_MASTER_LINK_KEY =                                  0x0417, /* 018,[C T], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_REMOTE_NAME_REQUEST =                              0x0419, /* 019,[C T], 1.1,BREDR,[REMOTE INFORMATION] */
    HCI_OPC_REMOTE_NAME_REQUEST_CANCEL =                       0x041a, /* 020,[CR ], 1.2,BREDR,[REMOTE INFORMATION] */
    HCI_OPC_READ_REMOTE_SUPPORTED_FEATURES =                   0x041b, /* 021,[C T], 1.1,BREDR,[REMOTE INFORMATION] */
    HCI_OPC_READ_REMOTE_EXTENDED_FEATURES =                    0x041c, /* 022,[C T], 1.2,BREDR,[REMOTE INFORMATION] */
    HCI_OPC_READ_REMOTE_VERSION_INFORMATION =                  0x041d, /* 023,[C T], 1.1,BREDR/LE,[REMOTE INFORMATION] */
    HCI_OPC_READ_CLOCK_OFFSET =                                0x041f, /* 024,[C T], 1.1,BREDR,[LINK INFORMATION] */
    HCI_OPC_READ_LMP_HANDLE =                                  0x0420, /* 025,[CR ], 1.2,BREDR,[LINK INFORMATION] */
    HCI_OPC_SETUP_SYNCHRONOUS_CONNECTION =                     0x0428, /* 026,[C T], 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
    HCI_OPC_ACCEPT_SYNCHRONOUS_CONNECTION_REQUEST =            0x0429, /* 027,[C TT], 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
    HCI_OPC_REJECT_SYNCHRONOUS_CONNECTION_REQUEST =            0x042a, /* 028,[C TT], 1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
    HCI_OPC_IO_CAPABILITY_REQUEST_REPLY =                      0x042b, /* 029,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_USER_CONFIRMATION_REQUEST_REPLY =                  0x042c, /* 030,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY =         0x042d, /* 031,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_USER_PASSKEY_REQUEST_REPLY =                       0x042e, /* 032,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_USER_PASSKEY_REQUEST_NEGATIVE_REPLY =              0x042f, /* 033,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_REMOTE_OOB_DATA_REQUEST_REPLY =                    0x0430, /* 034,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY =           0x0433, /* 035,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_IO_CAPABILITY_REQUEST_NEGATIVE_REPLY =             0x0434, /* 036,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */

    /*---------------------------------------------------------------------------------*/
    /*                               Link Policy - 0x0800                              */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_HOLD_MODE =                                        0x0801, /* 037,[C T], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_SNIFF_MODE =                                       0x0803, /* 038,[C T], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_EXIT_SNIFF_MODE =                                  0x0804, /* 039,[C T], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_PARK_STATE =                                       0x0805, /* 040,[C T], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_EXIT_PARK_STATE =                                  0x0806, /* 041,[C T], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_QOS_SETUP =                                        0x0807, /* 042,[C T], 1.1,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_ROLE_DISCOVERY =                                   0x0809, /* 043,[CR ], 1.1,BREDR,[PICONET STRUCTURE] */
    HCI_OPC_SWITCH_ROLE =                                      0x080b, /* 044,[C T], 1.1,BREDR,[PICONET STRUCTURE] */
    HCI_OPC_READ_LINK_POLICY_SETTINGS =                        0x080c, /* 045,[CR ], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_WRITE_LINK_POLICY_SETTINGS =                       0x080d, /* 046,[CR ], 1.1,BREDR,[CONNECTION STATE] */
    HCI_OPC_READ_DEFAULT_LINK_POLICY_SETTINGS =                0x080e, /* 047,[ R ], 1.2,BREDR,[CONNECTION STATE] */
    HCI_OPC_WRITE_DEFAULT_LINK_POLICY_SETTINGS =               0x080f, /* 048,[CR ], 1.2,BREDR,[CONNECTION STATE] */
    HCI_OPC_FLOW_SPECIFICATION =                               0x0810, /* 049,[C T], 1.2,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_SNIFF_SUBRATING =                                  0x0811, /* 050,[CR ], 2.1,BREDR,[CONNECTION STATE] */

    /*---------------------------------------------------------------------------------*/
    /*                          Controller & Baseband - 0x0c00                         */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_SET_EVENT_MASK =                                   0x0c01, /* 051,[CR ], 1.1,All,[HOST FLOW CONTROL] */
    HCI_OPC_RESET =                                            0x0c03, /* 052,[ R ], 1.1,All,[DEVICE SETUP] */
    HCI_OPC_SET_EVENT_FILTER =                                 0x0c05, /* 053,[CR ], 1.1,BREDR/AMP,[HOST FLOW CONTROL] */
    HCI_OPC_FLUSH =                                            0x0c08, /* 054,[CR ], 1.1,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_READ_PIN_TYPE =                                    0x0c09, /* 055,[ R ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_WRITE_PIN_TYPE =                                   0x0c0a, /* 056,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_CREATE_NEW_UNIT_KEY =                              0x0c0b, /* 057,[ R ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_READ_STORED_LINK_KEY =                             0x0c0d, /* 058,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_WRITE_STORED_LINK_KEY =                            0x0c11, /* 059,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_DELETE_STORED_LINK_KEY =                           0x0c12, /* 060,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_WRITE_LOCAL_NAME =                                 0x0c13, /* 061,[CR ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_READ_LOCAL_NAME =                                  0x0c14, /* 062,[ R ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_READ_CONNECTION_ACCEPT_TIMEOUT =                   0x0c15, /* 063,[ R ], 1.1,BREDR/AMP,[CONNECTION SETUP] */
    HCI_OPC_WRITE_CONNECTION_ACCEPT_TIMEOUT =                  0x0c16, /* 064,[CR ], 1.1,BREDR/AMP,[CONNECTION SETUP] */
    HCI_OPC_READ_PAGE_TIMEOUT =                                0x0c17, /* 065,[ R ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_WRITE_PAGE_TIMEOUT =                               0x0c18, /* 066,[CR ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_READ_SCAN_ENABLE =                                 0x0c19, /* 067,[ R ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_WRITE_SCAN_ENABLE =                                0x0c1a, /* 068,[CR ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_READ_PAGE_SCAN_ACTIVITY =                          0x0c1b, /* 069,[ R ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_WRITE_PAGE_SCAN_ACTIVITY =                         0x0c1c, /* 070,[CR ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_READ_INQUIRY_SCAN_ACTIVITY =                       0x0c1d, /* 071,[ R ], 1.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_WRITE_INQUIRY_SCAN_ACTIVITY =                      0x0c1e, /* 072,[CR ], 1.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_READ_AUTHENTICATION_ENABLE =                       0x0c1f, /* 073,[ R ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_WRITE_AUTHENTICATION_ENABLE =                      0x0c20, /* 074,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_READ_ENCRYPTION_MODE =                             0x0c21, /* 075,[ R ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_WRITE_ENCRYPTION_MODE =                            0x0c22, /* 076,[CR ], 1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_READ_CLASS_OF_DEVICE =                             0x0c23, /* 077,[ R ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_WRITE_CLASS_OF_DEVICE =                            0x0c24, /* 078,[CR ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_READ_VOICE_SETTING =                               0x0c25, /* 079,[ R ], 1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
    HCI_OPC_WRITE_VOICE_SETTING =                              0x0c26, /* 080,[CR ], 1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
    HCI_OPC_READ_AUTOMATIC_FLUSH_TIMEOUT =                     0x0c27, /* 081,[CR ], 1.1,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_WRITE_AUTOMATIC_FLUSH_TIMEOUT =                    0x0c28, /* 082,[CR ], 1.1,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_READ_NUM_BROADCAST_RETRANSMISSIONS =               0x0c29, /* 083,[ R ], 1.1,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_WRITE_NUM_BROADCAST_RETRANSMISSIONS =              0x0c2a, /* 084,[CR ], 1.1,BREDR,[QUALITY OF SERVICE] */
    HCI_OPC_READ_HOLD_MODE_ACTIVITY =                          0x0c2b, /* 085,[ R ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_WRITE_HOLD_MODE_ACTIVITY =                         0x0c2c, /* 086,[CR ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_READ_TRANSMIT_POWER_LEVEL =                        0x0c2d, /* 087,[CR ], 1.1,BREDR/LE,[LINK INFORMATION] */
    HCI_OPC_READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE =             0x0c2e, /* 088,[ R ], 1.1,BREDR,[HOST FLOW CONTROL] */
    HCI_OPC_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE =            0x0c2f, /* 089,[CR ], 1.1,BREDR,[HOST FLOW CONTROL] */
    HCI_OPC_SET_CONTROLLER_TO_HOST_FLOW_CONTROL =              0x0c31, /* 090,[CR ], 1.1,BREDR/LE,[HOST FLOW CONTROL] */
    HCI_OPC_HOST_BUFFER_SIZE =                                 0x0c33, /* 091,[CR ], 1.1,BREDR/LE,[HOST FLOW CONTROL] */
    HCI_OPC_HOST_NUMBER_OF_COMPLETED_PACKETS =                 0x0c35, /* 092,[C -NoCFC], 1.1,All,[HOST FLOW CONTROL] */
    HCI_OPC_READ_LINK_SUPERVISION_TIMEOUT =                    0x0c36, /* 093,[CR ], 1.1,BREDR/AMP,[PHYSICAL LINKS] */
    HCI_OPC_WRITE_LINK_SUPERVISION_TIMEOUT =                   0x0c37, /* 094,[CR ], 1.1,BREDR/AMP,[PHYSICAL LINKS] */
    HCI_OPC_READ_NUMBER_OF_SUPPORTED_IAC =                     0x0c38, /* 095,[ R ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_READ_CURRENT_IAC_LAP =                             0x0c39, /* 096,[ R ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_WRITE_CURRENT_IAC_LAP =                            0x0c3a, /* 097,[CR ], 1.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_READ_PAGE_SCAN_PERIOD_MODE =                       0x0c3b, /* 098,[ R ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_WRITE_PAGE_SCAN_PERIOD_MODE =                      0x0c3c, /* 099,[CR ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_READ_PAGE_SCAN_MODE =                              0x0c3d, /* 100,[ R ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_WRITE_PAGE_SCAN_MODE =                             0x0c3e, /* 101,[CR ], 1.1,BREDR,[CONNECTION SETUP] */
    HCI_OPC_SET_AFH_HOST_CHANNEL_CLASSIFICATION =              0x0c3f, /* 102,[CR ], 1.2,BREDR,[PHYSICAL LINKS] */
    HCI_OPC_READ_INQUIRY_SCAN_TYPE =                           0x0c42, /* 103,[ R ], 1.2,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_WRITE_INQUIRY_SCAN_TYPE =                          0x0c43, /* 104,[CR ], 1.2,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_READ_INQUIRY_MODE =                                0x0c44, /* 105,[ R ], 1.2,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_WRITE_INQUIRY_MODE =                               0x0c45, /* 106,[CR ], 1.2,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_READ_PAGE_SCAN_TYPE =                              0x0c46, /* 107,[ R ], 1.2,BREDR,[CONNECTION SETUP] */
    HCI_OPC_WRITE_PAGE_SCAN_TYPE =                             0x0c47, /* 108,[CR ], 1.2,BREDR,[CONNECTION SETUP] */
    HCI_OPC_READ_AFH_CHANNEL_ASSESSMENT_MODE =                 0x0c48, /* 109,[ R ], 1.2,BREDR,[PHYSICAL LINKS] */
    HCI_OPC_WRITE_AFH_CHANNEL_ASSESSMENT_MODE =                0x0c49, /* 110,[CR ], 1.2,BREDR,[PHYSICAL LINKS] */
    HCI_OPC_READ_EXTENDED_INQUIRY_RESPONSE =                   0x0c51, /* 111,[ R ], 2.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_WRITE_EXTENDED_INQUIRY_RESPONSE =                  0x0c52, /* 112,[CR ], 2.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_REFRESH_ENCRYPTION_KEY =                           0x0c53, /* 113,[C T], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_READ_SIMPLE_PAIRING_MODE =                         0x0c55, /* 114,[ R ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_WRITE_SIMPLE_PAIRING_MODE =                        0x0c56, /* 115,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_READ_LOCAL_OOB_DATA =                              0x0c57, /* 116,[ R ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL =       0x0c58, /* 117,[ R ], 2.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL =               0x0c59, /* 118,[CR ], 2.1,BREDR,[DEVICE DISCOVERY] */
    HCI_OPC_READ_DEFAULT_ERRONEOUS_DATA_REPORTING =            0x0c5a, /* 119,[ R ], 2.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING =           0x0c5b, /* 120,[CR ], 2.1,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_ENHANCED_FLUSH =                                   0x0c5f, /* 121,[C T], 2.1,BREDR/AMP,[QUALITY OF SERVICE] */
    HCI_OPC_SEND_KEYPRESS_NOTIFICATION =                       0x0c60, /* 122,[CR ], 2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_SET_EVENT_MASK_PAGE_2 =                            0x0c63, /* 123,[CR ], 3.0,BREDR/AMP,[HOST FLOW CONTROL] */
    HCI_OPC_READ_FLOW_CONTROL_MODE =                           0x0c66, /* 124,[ R ], 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
    HCI_OPC_WRITE_FLOW_CONTROL_MODE =                          0x0c67, /* 125,[CR ], 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
    HCI_OPC_READ_ENHANCED_TRANSMIT_POWER_LEVEL =               0x0c68, /* 126,[CR ], 3.0,BREDR,[LINK INFORMATION] */
    HCI_OPC_READ_LE_HOST_SUPPORT =                             0x0c6c, /* 127,[ R ], 4.0,BREDR,[CONTROLLER CONFIGURATION] */
    HCI_OPC_WRITE_LE_HOST_SUPPORT =                            0x0c6d, /* 128,[CR ], 4.0,BREDR,[CONTROLLER CONFIGURATION] */

    /*---------------------------------------------------------------------------------*/
    /*                           Informational Param - 0x1000                          */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_READ_LOCAL_VERSION_INFORMATION =                   0x1001, /* 129,[ R ], 1.1,All,[CONTROLLER INFORMATION] */
    HCI_OPC_READ_LOCAL_SUPPORTED_COMMANDS =                    0x1002, /* 130,[ R ], 1.2,All,[CONTROLLER INFORMATION] */
    HCI_OPC_READ_LOCAL_SUPPORTED_FEATURES =                    0x1003, /* 131,[ R ], 1.1,All,[CONTROLLER INFORMATION] */
    HCI_OPC_READ_LOCAL_EXTENDED_FEATURES =                     0x1004, /* 132,[CR ], 1.2,BREDR,[CONTROLLER INFORMATION] */
    HCI_OPC_READ_BUFFER_SIZE =                                 0x1005, /* 133,[ R ], 1.1,All,[CONTROLLER FLOW CONTROL] */
    HCI_OPC_READ_COUNTRY_CODE =                                0x1007, /* 134,[ R ], 1.1,BREDR,[CONTROLLER INFORMATION] */
    HCI_OPC_READ_BD_ADDR =                                     0x1009, /* 135,[ R ], 1.1,BREDR/LE,[CONTROLLER INFORMATION] */
    HCI_OPC_READ_DATA_BLOCK_SIZE =                             0x100a, /* 136,[ R ], 3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */

    /*---------------------------------------------------------------------------------*/
    /*                              Status Param - 0x1400                              */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_READ_FAILED_CONTACT_COUNTER =                      0x1401, /* 137,[CR ], 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
    HCI_OPC_RESET_FAILED_CONTACT_COUNTER =                     0x1402, /* 138,[CR ], 1.1,BREDR/AMP,[QUALITY OF SERVICE] */
    HCI_OPC_READ_LINK_QUALITY =                                0x1403, /* 139,[CR ], 1.1,BREDR/AMP,[LINK INFORMATION] */
    HCI_OPC_READ_RSSI =                                        0x1405, /* 140,[CR ], 1.1,All,[LINK INFORMATION] */
    HCI_OPC_READ_AFH_CHANNEL_MAP =                             0x1406, /* 141,[CR ], 1.2,BREDR,[LINK INFORMATION] */
    HCI_OPC_READ_CLOCK =                                       0x1407, /* 142,[CR ], 1.2,BREDR,[LINK INFORMATION] */
    HCI_OPC_READ_ENCRYPTION_KEY_SIZE =                         0x1408, /* 143,[CR ], 3.0,BREDR,[AUTHENTICATION AND ENCRYPTION] */

    /*---------------------------------------------------------------------------------*/
    /*                                 Testing - 0x1800                                */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_READ_LOOPBACK_MODE =                               0x1801, /* 144,[ R ], 1.1,BREDR,[TESTING] */
    HCI_OPC_WRITE_LOOPBACK_MODE =                              0x1802, /* 145,[CR ], 1.1,BREDR,[TESTING] */
    HCI_OPC_ENABLE_DEVICE_UNDER_TEST_MODE =                    0x1803, /* 146,[ R ], 1.1,BREDR,[TESTING] */
    HCI_OPC_WRITE_SIMPLE_PAIRING_DEBUG_MODE =                  0x1804, /* 147,[CR ], 2.1,BREDR,[TESTING] */

    /*---------------------------------------------------------------------------------*/
    /*                              LE Controller - 0x2000                             */
    /*---------------------------------------------------------------------------------*/
    HCI_OPC_LE_SET_EVENT_MASK =                                0x2001, /* 148,[CR ], 4.0,LE,[HOST FLOW CONTROL] */
    HCI_OPC_LE_READ_BUFFER_SIZE =                              0x2002, /* 149,[ R ], 4.0,LE,[CONTROLLER FLOW CONTROL] */
    HCI_OPC_LE_READ_LOCAL_SUPPORTED_FEATURES =                 0x2003, /* 150,[ R ], 4.0,LE,[CONTROLLER INFORMATION] */
    HCI_OPC_LE_SET_RANDOM_ADDRESS =                            0x2005, /* 151,[CR ], 4.0,LE,[CONTROLLER CONFIGURATION] */
    HCI_OPC_LE_SET_ADVERTISING_PARAMETERS =                    0x2006, /* 152,[CR ], 4.0,LE,[CONTROLLER CONFIGURATION] */
    HCI_OPC_LE_READ_ADVERTISING_CHANNEL_TX_POWER =             0x2007, /* 153,[ R ], 4.0,LE,[LINK INFORMATION] */
    HCI_OPC_LE_SET_ADVERTISING_DATA =                          0x2008, /* 154,[CR ], 4.0,LE,[CONTROLLER CONFIGURATION] */
    HCI_OPC_LE_SET_SCAN_RESPONSE_DATA =                        0x2009, /* 155,[CR ], 4.0,LE,[CONTROLLER CONFIGURATION] */
    HCI_OPC_LE_SET_ADVERTISE_ENABLE =                          0x200a, /* 156,[CR ], 4.0,LE,[CONTROLLER CONFIGURATION] */
    HCI_OPC_LE_SET_SCAN_PARAMETERS =                           0x200b, /* 157,[CR ], 4.0,LE,[DEVICE DISCOVERY] */
    HCI_OPC_LE_SET_SCAN_ENABLE =                               0x200c, /* 158,[CR ], 4.0,LE,[DEVICE DISCOVERY] */
    HCI_OPC_LE_CREATE_CONNECTION =                             0x200d, /* 159,[C T], 4.0,LE,[CONNECTION SETUP] */
    HCI_OPC_LE_CREATE_CONNECTION_CANCEL =                      0x200e, /* 160,[ R ], 4.0,LE,[CONNECTION SETUP] */
    HCI_OPC_LE_READ_WHITE_LIST_SIZE =                          0x200f, /* 161,[ R ], 4.0,LE,[HOST FLOW CONTROL] */
    HCI_OPC_LE_CLEAR_WHITE_LIST =                              0x2010, /* 162,[ R ], 4.0,LE,[HOST FLOW CONTROL] */
    HCI_OPC_LE_ADD_DEVICE_TO_WHITE_LIST =                      0x2011, /* 163,[CR ], 4.0,LE,[HOST FLOW CONTROL] */
    HCI_OPC_LE_REMOVE_DEVICE_FROM_WHITE_LIST =                 0x2012, /* 164,[CR ], 4.0,LE,[HOST FLOW CONTROL] */
    HCI_OPC_LE_CONNECTION_UPDATE =                             0x2013, /* 165,[C T], 4.0,LE,[CONNECTION STATE] */
    HCI_OPC_LE_SET_HOST_CHANNEL_CLASSIFICATION =               0x2014, /* 166,[CR ], 4.0,LE,[PHYSICAL LINKS] */
    HCI_OPC_LE_READ_CHANNEL_MAP =                              0x2015, /* 167,[CR ], 4.0,LE,[LINK INFORMATION] */
    HCI_OPC_LE_READ_REMOTE_USED_FEATURES =                     0x2016, /* 168,[C T], 4.0,LE,[REMOTE INFORMATION] */
    HCI_OPC_LE_ENCRYPT =                                       0x2017, /* 169,[CR ], 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_LE_RAND =                                          0x2018, /* 170,[ R ], 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_LE_START_ENCRYPTION =                              0x2019, /* 171,[C TT], 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_LE_LONG_TERM_KEY_REQUEST_REPLY =                   0x201a, /* 172,[CR ], 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY =          0x201b, /* 173,[CR ], 4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    HCI_OPC_LE_READ_SUPPORTED_STATES =                         0x201c, /* 174,[ R ], 4.0,LE,[CONTROLLER INFORMATION] */
    HCI_OPC_LE_RECEIVER_TEST =                                 0x201d, /* 175,[CR ], 4.0,LE,[TESTING] */
    HCI_OPC_LE_TRANSMITTER_TEST =                              0x201e, /* 176,[CR ], 4.0,LE,[TESTING] */
    HCI_OPC_LE_TEST_END =                                      0x201f, /* 177,[ R ], 4.0,LE,[TESTING] */
};

/*---------------------------------------------------------------------------------*/
/*                             UI Command Code HCI_OPS                             */
/*---------------------------------------------------------------------------------*/

enum
{

    /*---------------------------------------------------------------------------------*/
    /*                              Link Control - 0x0400                              */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_INQUIRY =                                          /* ((0x00 << 24) 'E'  | (0x2a << 16)  | 0x0401 | 0x8000) */ 0x002a8401,
    /* 000,[C T],1.1,BREDR,[DEVICE DISCOVERY] */
    /* C:lap[3],inquiry_len[1],num_responses[1] */
    /* [Inquiry_Complete][0x01],P:status[1] */

    HCI_OPS_INQUIRY_CANCEL =                                   /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x0402 | 0x0000) */ 0x4c000402,
    /* 001,[ R ],1.1,BREDR,[DEVICE DISCOVERY] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_PERIODIC_INQUIRY_MODE =                            /* ((0x4c << 24) 'R'  | (0x29 << 16)  | 0x0403 | 0x0000) */ 0x4c290403,
    /* 002,[CR ],1.1,BREDR,[DEVICE DISCOVERY] */
    /* C:max_period_len[2],min_period_len[2],lap[3],inquiry_len[1],num_responses[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_EXIT_PERIODIC_INQUIRY_MODE =                       /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x0404 | 0x0000) */ 0x4c000404,
    /* 003,[ R ],1.1,BREDR,[DEVICE DISCOVERY] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_CREATE_CONNECTION =                                /* ((0x02 << 24) 'E'  | (0x11 << 16)  | 0x0405 | 0x8000) */ 0x02118405,
    /* 004,[C T],1.1,BREDR,[CONNECTION SETUP] */
    /* C:bd[6],packet_type[2],page_scan_repetition_mode[1],reserved[1],clock_offset[2],allow_role_switch[1] */
    /* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */

    HCI_OPS_DISCONNECT =                                       /* ((0x04 << 24) 'E'  | (0x62 << 16)  | 0x0406 | 0x8000) */ 0x04628406,
    /* 005,[C T],1.1,BREDR/LE,[CONNECTION SETUP] */
    /* C:connection_handle[2],reason[1] */
    /* [Disconnection_Complete][0x05],P:status[1],connection_handle[2],reason[1] */

    HCI_OPS_ADD_SCO_CONNECTION =                               /* ((0x02 << 24) 'E'  | (0x23 << 16)  | 0x0407 | 0x8000) */ 0x02238407,
    /* 006,[C T],1.1,BREDR,[CONNECTION SETUP] */
    /* C:connection_handle[2],packet_type[2] */
    /* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */

    HCI_OPS_CREATE_CONNECTION_CANCEL =                         /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x0408 | 0x0000) */ 0x138e0408,
    /* 007,[CR ],1.2,BREDR,[CONNECTION SETUP] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_ACCEPT_CONNECTION_REQUEST =                        /* ((0x02 << 24) 'E'  | (0x64 << 16)  | 0x0409 | 0x8000) */ 0x02648409,
    /* 008,[C T],1.1,BREDR,[CONNECTION SETUP] */
    /* C:bd[6],role[1] */
    /* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */

    HCI_OPS_REJECT_CONNECTION_REQUEST =                        /* ((0x02 << 24) 'E'  | (0x64 << 16)  | 0x040a | 0x8000) */ 0x0264840a,
    /* 009,[C T],1.1,BREDR,[CONNECTION SETUP] */
    /* C:bd[6],reason[1] */
    /* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */

    HCI_OPS_LINK_KEY_REQUEST_REPLY =                           /* ((0x13 << 24) 'R'  | (0x66 << 16)  | 0x040b | 0x0000) */ 0x1366040b,
    /* 010,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],link_key[16] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_LINK_KEY_REQUEST_NEGATIVE_REPLY =                  /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x040c | 0x0000) */ 0x138e040c,
    /* 011,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_PIN_CODE_REQUEST_REPLY =                           /* ((0x13 << 24) 'R'  | (0x2c << 16)  | 0x040d | 0x0000) */ 0x132c040d,
    /* 012,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],pin_code_len[1],pin_code[16] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_PIN_CODE_REQUEST_NEGATIVE_REPLY =                  /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x040e | 0x0000) */ 0x138e040e,
    /* 013,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_CHANGE_CONNECTION_PACKET_TYPE =                    /* ((0x1c << 24) 'E'  | (0x23 << 16)  | 0x040f | 0x8000) */ 0x1c23840f,
    /* 014,[C T],1.1,BREDR,[PHYSICAL LINKS] */
    /* C:connection_handle[2],packet_type[2] */
    /* [Connection_Packet_Type_Changed][0x1d],P:status[1],connection_handle[2],packet_type[2] */

    HCI_OPS_AUTHENTICATION_REQUESTED =                         /* ((0x05 << 24) 'E'  | (0x18 << 16)  | 0x0411 | 0x8000) */ 0x05188411,
    /* 015,[C T],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2] */
    /* [Authentication_Complete][0x06],P:status[1],connection_handle[2] */

    HCI_OPS_SET_CONNECTION_ENCRYPTION =                        /* ((0x07 << 24) 'E'  | (0x62 << 16)  | 0x0413 | 0x8000) */ 0x07628413,
    /* 016,[C T],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2],encryption_enable[1] */
    /* [Encryption_Change][0x08],P:status[1],connection_handle[2],encryption_enable[1] */

    HCI_OPS_CHANGE_CONNECTION_LINK_KEY =                       /* ((0x08 << 24) 'E'  | (0x18 << 16)  | 0x0415 | 0x8000) */ 0x08188415,
    /* 017,[C T],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2] */
    /* [Change_Connection_Link_Key_Complete][0x09],P:status[1],connection_handle[2] */

    HCI_OPS_MASTER_LINK_KEY =                                  /* ((0x09 << 24) 'E'  | (0x4c << 16)  | 0x0417 | 0x8000) */ 0x094c8417,
    /* 018,[C T],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:key_flag[1] */
    /* [Master_Link_Key_Complete][0x0a],P:status[1],connection_handle[2],key_flag[1] */

    HCI_OPS_REMOTE_NAME_REQUEST =                              /* ((0x06 << 24) 'E'  | (0x2f << 16)  | 0x0419 | 0x8000) */ 0x062f8419,
    /* 019,[C T],1.1,BREDR,[REMOTE INFORMATION] */
    /* C:bd[6],page_scan_repetition_mode[1],reserved[1],clock_offset[2] */
    /* [Remote_Name_Request_Complete][0x07],P:status[1],bd[6],remote_name[248] */

    HCI_OPS_REMOTE_NAME_REQUEST_CANCEL =                       /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x041a | 0x0000) */ 0x138e041a,
    /* 020,[CR ],1.2,BREDR,[REMOTE INFORMATION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_READ_REMOTE_SUPPORTED_FEATURES =                   /* ((0x0a << 24) 'E'  | (0x18 << 16)  | 0x041b | 0x8000) */ 0x0a18841b,
    /* 021,[C T],1.1,BREDR,[REMOTE INFORMATION] */
    /* C:connection_handle[2] */
    /* [Read_Remote_Supported_Features_Complete][0x0b],P:status[1],connection_handle[2],lmp_features[8] */

    HCI_OPS_READ_REMOTE_EXTENDED_FEATURES =                    /* ((0x22 << 24) 'E'  | (0x62 << 16)  | 0x041c | 0x8000) */ 0x2262841c,
    /* 022,[C T],1.2,BREDR,[REMOTE INFORMATION] */
    /* C:connection_handle[2],page_number[1] */
    /* [Read_Remote_Extended_Features_Complete][0x23],P:status[1],connection_handle[2],page_number[1],max_page_number[1],extended_lmp_features[8] */

    HCI_OPS_READ_REMOTE_VERSION_INFORMATION =                  /* ((0x0b << 24) 'E'  | (0x18 << 16)  | 0x041d | 0x8000) */ 0x0b18841d,
    /* 023,[C T],1.1,BREDR/LE,[REMOTE INFORMATION] */
    /* C:connection_handle[2] */
    /* [Read_Remote_Version_Information_Complete][0x0c],P:status[1],connection_handle[2],lmp_version[1],manufacturer_name[2],lmp_subversion[2] */

    HCI_OPS_READ_CLOCK_OFFSET =                                /* ((0x1b << 24) 'E'  | (0x18 << 16)  | 0x041f | 0x8000) */ 0x1b18841f,
    /* 024,[C T],1.1,BREDR,[LINK INFORMATION] */
    /* C:connection_handle[2] */
    /* [Read_Clock_Offset_Complete][0x1c],P:status[1],connection_handle[2],clock_offset[2] */

    HCI_OPS_READ_LMP_HANDLE =                                  /* ((0x32 << 24) 'R'  | (0x18 << 16)  | 0x0420 | 0x0000) */ 0x32180420,
    /* 025,[CR ],1.2,BREDR,[LINK INFORMATION] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],lmp_handle[1],reserved[4] */

    HCI_OPS_SETUP_SYNCHRONOUS_CONNECTION =                     /* ((0x23 << 24) 'E'  | (0x15 << 16)  | 0x0428 | 0x8000) */ 0x23158428,
    /* 026,[C T],1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
    /* C:connection_handle[2],transmit_bandwidth[4],receive_bandwidth[4],max_latency[2],voice_setting[2],retransmission_effort[1],packet_type[2] */
    /* [Synchronous_Connection_Complete][0x2c],P:status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],rx_packet_length[2],tx_packet_length[2],air_mode[1] */

    HCI_OPS_ACCEPT_SYNCHRONOUS_CONNECTION_REQUEST =            /* ((0x23 << 24) 'E'  | (0x19 << 16)  | 0x0429 | 0x8000) */ 0x23198429,
    /* 027,[C TT],1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
    /* C:bd[6],transmit_bandwidth[4],receive_bandwidth[4],max_latency[2],voice_setting[2],retransmission_effort[1],packet_type[2] */
    /* [Synchronous_Connection_Complete][0x2c],P:status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],rx_packet_length[2],tx_packet_length[2],air_mode[1] */
    /* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */

    HCI_OPS_REJECT_SYNCHRONOUS_CONNECTION_REQUEST =            /* ((0x23 << 24) 'E'  | (0x64 << 16)  | 0x042a | 0x8000) */ 0x2364842a,
    /* 028,[C TT],1.2,BREDR,[SYNCHRONOUS CONNECTIONS] */
    /* C:bd[6],reason[1] */
    /* [Synchronous_Connection_Complete][0x2c],P:status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],rx_packet_length[2],tx_packet_length[2],air_mode[1] */
    /* [Connection_Complete][0x03],P:status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1] */

    HCI_OPS_IO_CAPABILITY_REQUEST_REPLY =                      /* ((0x13 << 24) 'R'  | (0x35 << 16)  | 0x042b | 0x0000) */ 0x1335042b,
    /* 029,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],io_capability[1],oob_data_present[1],authentication_requirements[1] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_USER_CONFIRMATION_REQUEST_REPLY =                  /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x042c | 0x0000) */ 0x138e042c,
    /* 030,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_USER_CONFIRMATION_REQUEST_NEGATIVE_REPLY =         /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x042d | 0x0000) */ 0x138e042d,
    /* 031,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_USER_PASSKEY_REQUEST_REPLY =                       /* ((0x13 << 24) 'R'  | (0x68 << 16)  | 0x042e | 0x0000) */ 0x1368042e,
    /* 032,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],numeric_value[4] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_USER_PASSKEY_REQUEST_NEGATIVE_REPLY =              /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x042f | 0x0000) */ 0x138e042f,
    /* 033,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_REMOTE_OOB_DATA_REQUEST_REPLY =                    /* ((0x13 << 24) 'R'  | (0x38 << 16)  | 0x0430 | 0x0000) */ 0x13380430,
    /* 034,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],c[16],r[16] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_REMOTE_OOB_DATA_REQUEST_NEGATIVE_REPLY =           /* ((0x13 << 24) 'R'  | (0x8e << 16)  | 0x0433 | 0x0000) */ 0x138e0433,
    /* 035,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_IO_CAPABILITY_REQUEST_NEGATIVE_REPLY =             /* ((0x13 << 24) 'R'  | (0x64 << 16)  | 0x0434 | 0x0000) */ 0x13640434,
    /* 036,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],reason[1] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */


    /*---------------------------------------------------------------------------------*/
    /*                               Link Policy - 0x0800                              */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_HOLD_MODE =                                        /* ((0x13 << 24) 'E'  | (0x27 << 16)  | 0x0801 | 0x8000) */ 0x13278801,
    /* 037,[C T],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2],hold_mode_max_interval[2],hold_mode_min_interval[2] */
    /* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */

    HCI_OPS_SNIFF_MODE =                                       /* ((0x13 << 24) 'E'  | (0x3b << 16)  | 0x0803 | 0x8000) */ 0x133b8803,
    /* 038,[C T],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2],sniff_max_interval[2],sniff_min_interval[2],sniff_attempt[2],sniff_timeout[2] */
    /* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */

    HCI_OPS_EXIT_SNIFF_MODE =                                  /* ((0x13 << 24) 'E'  | (0x18 << 16)  | 0x0804 | 0x8000) */ 0x13188804,
    /* 039,[C T],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2] */
    /* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */

    HCI_OPS_PARK_STATE =                                       /* ((0x13 << 24) 'E'  | (0x27 << 16)  | 0x0805 | 0x8000) */ 0x13278805,
    /* 040,[C T],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2],beacon_max_interval[2],beacon_min_interval[2] */
    /* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */

    HCI_OPS_EXIT_PARK_STATE =                                  /* ((0x13 << 24) 'E'  | (0x18 << 16)  | 0x0806 | 0x8000) */ 0x13188806,
    /* 041,[C T],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2] */
    /* [Mode_Change][0x14],P:status[1],connection_handle[2],current_mode[1],interval[2] */

    HCI_OPS_QOS_SETUP =                                        /* ((0x0c << 24) 'E'  | (0x1d << 16)  | 0x0807 | 0x8000) */ 0x0c1d8807,
    /* 042,[C T],1.1,BREDR,[QUALITY OF SERVICE] */
    /* C:connection_handle[2],flags[1],service_type[1],token_rate[4],peak_bandwidth[4],latency[4],delay_variation[4] */
    /* [QoS_Setup_Complete][0x0d],P:status[1],connection_handle[2],flags[1],service_type[1],token_rate[4],peak_bandwidth[4],latency[4],delay_variation[4] */

    HCI_OPS_ROLE_DISCOVERY =                                   /* ((0x6a << 24) 'R'  | (0x18 << 16)  | 0x0809 | 0x0000) */ 0x6a180809,
    /* 043,[CR ],1.1,BREDR,[PICONET STRUCTURE] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],role[1] */

    HCI_OPS_SWITCH_ROLE =                                      /* ((0x11 << 24) 'E'  | (0x64 << 16)  | 0x080b | 0x8000) */ 0x1164880b,
    /* 044,[C T],1.1,BREDR,[PICONET STRUCTURE] */
    /* C:bd[6],role[1] */
    /* [Role_Change][0x12],P:status[1],bd[6],role[1] */

    HCI_OPS_READ_LINK_POLICY_SETTINGS =                        /* ((0x6c << 24) 'R'  | (0x18 << 16)  | 0x080c | 0x0000) */ 0x6c18080c,
    /* 045,[CR ],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],link_policy_settings[2] */

    HCI_OPS_WRITE_LINK_POLICY_SETTINGS =                       /* ((0x6e << 24) 'R'  | (0x23 << 16)  | 0x080d | 0x0000) */ 0x6e23080d,
    /* 046,[CR ],1.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2],link_policy_settings[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */

    HCI_OPS_READ_DEFAULT_LINK_POLICY_SETTINGS =                /* ((0x6e << 24) 'R'  | (0x00 << 16)  | 0x080e | 0x0000) */ 0x6e00080e,
    /* 047,[ R ],1.2,BREDR,[CONNECTION STATE] */
    /* [Command_Complete][0x0E],R:status[1],link_policy_settings[2] */

    HCI_OPS_WRITE_DEFAULT_LINK_POLICY_SETTINGS =               /* ((0x4c << 24) 'R'  | (0x18 << 16)  | 0x080f | 0x0000) */ 0x4c18080f,
    /* 048,[CR ],1.2,BREDR,[CONNECTION STATE] */
    /* C:link_policy_settings[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_FLOW_SPECIFICATION =                               /* ((0x20 << 24) 'E'  | (0x07 << 16)  | 0x0810 | 0x8000) */ 0x20078810,
    /* 049,[C T],1.2,BREDR,[QUALITY OF SERVICE] */
    /* C:connection_handle[2],flags[1],flow_direction[1],service_type[1],token_rate[4],token_bucket_size[4],peak_bandwidth[4],latency[4] */
    /* [Flow_Specification_Complete][0x21],P:status[1],connection_handle[2],flags[1],flow_direction[1],service_type[1],token_rate[4],token_bucket_size[4],peak_bandwidth[4],latency[4] */

    HCI_OPS_SNIFF_SUBRATING =                                  /* ((0x6e << 24) 'R'  | (0x3e << 16)  | 0x0811 | 0x0000) */ 0x6e3e0811,
    /* 050,[CR ],2.1,BREDR,[CONNECTION STATE] */
    /* C:connection_handle[2],max_sniff_latency[2],min_remote_timeout[2],min_local_timeout[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */


    /*---------------------------------------------------------------------------------*/
    /*                          Controller & Baseband - 0x0c00                         */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_SET_EVENT_MASK =                                   /* ((0x4c << 24) 'R'  | (0x8f << 16)  | 0x0c01 | 0x0000) */ 0x4c8f0c01,
    /* 051,[CR ],1.1,All,[HOST FLOW CONTROL] */
    /* C:event_mask[8] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_RESET =                                            /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x0c03 | 0x0000) */ 0x4c000c03,
    /* 052,[ R ],1.1,All,[DEVICE SETUP] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_SET_EVENT_FILTER =                                 /* ((0x4c << 24) 'R'  | (0x70 << 16)  | 0x0c05 | 0x0000) */ 0x4c700c05,
    /* 053,[CR ],1.1,BREDR/AMP,[HOST FLOW CONTROL] */
    /* C:filter_type[1],condition[x] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_FLUSH =                                            /* ((0x6e << 24) 'R'  | (0x18 << 16)  | 0x0c08 | 0x0000) */ 0x6e180c08,
    /* 054,[CR ],1.1,BREDR,[QUALITY OF SERVICE] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */

    HCI_OPS_READ_PIN_TYPE =                                    /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c09 | 0x0000) */ 0x72000c09,
    /* 055,[ R ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1],pin_type[1] */

    HCI_OPS_WRITE_PIN_TYPE =                                   /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c0a | 0x0000) */ 0x4c4c0c0a,
    /* 056,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:pin_type[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_CREATE_NEW_UNIT_KEY =                              /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x0c0b | 0x0000) */ 0x4c000c0b,
    /* 057,[ R ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_STORED_LINK_KEY =                             /* ((0x6c << 24) 'R'  | (0x64 << 16)  | 0x0c0d | 0x0000) */ 0x6c640c0d,
    /* 058,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],all_flag[1] */
    /* [Command_Complete][0x0E],R:status[1],max_num_keys[2],num_keys[2] */

    HCI_OPS_WRITE_STORED_LINK_KEY =                            /* ((0x72 << 24) 'R'  | (0x41 << 16)  | 0x0c11 | 0x0000) */ 0x72410c11,
    /* 059,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:num_keys_to_write[n],bd[6],link_key[16] */
    /* [Command_Complete][0x0E],R:status[1],num_keys_written[1] */

    HCI_OPS_DELETE_STORED_LINK_KEY =                           /* ((0x6e << 24) 'R'  | (0x64 << 16)  | 0x0c12 | 0x0000) */ 0x6e640c12,
    /* 060,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],all_flag[1] */
    /* [Command_Complete][0x0E],R:status[1],num_keys[2] */

    HCI_OPS_WRITE_LOCAL_NAME =                                 /* ((0x4c << 24) 'R'  | (0x74 << 16)  | 0x0c13 | 0x0000) */ 0x4c740c13,
    /* 061,[CR ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:local_name[248] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_LOCAL_NAME =                                  /* ((0x76 << 24) 'R'  | (0x00 << 16)  | 0x0c14 | 0x0000) */ 0x76000c14,
    /* 062,[ R ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],local_name[248] */

    HCI_OPS_READ_CONNECTION_ACCEPT_TIMEOUT =                   /* ((0x6e << 24) 'R'  | (0x00 << 16)  | 0x0c15 | 0x0000) */ 0x6e000c15,
    /* 063,[ R ],1.1,BREDR/AMP,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],conn_accept_timeout[2] */

    HCI_OPS_WRITE_CONNECTION_ACCEPT_TIMEOUT =                  /* ((0x4c << 24) 'R'  | (0x18 << 16)  | 0x0c16 | 0x0000) */ 0x4c180c16,
    /* 064,[CR ],1.1,BREDR/AMP,[CONNECTION SETUP] */
    /* C:conn_accept_timeout[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_PAGE_TIMEOUT =                                /* ((0x6e << 24) 'R'  | (0x00 << 16)  | 0x0c17 | 0x0000) */ 0x6e000c17,
    /* 065,[ R ],1.1,BREDR,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],page_timeout[2] */

    HCI_OPS_WRITE_PAGE_TIMEOUT =                               /* ((0x4c << 24) 'R'  | (0x18 << 16)  | 0x0c18 | 0x0000) */ 0x4c180c18,
    /* 066,[CR ],1.1,BREDR,[CONNECTION SETUP] */
    /* C:page_timeout[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_SCAN_ENABLE =                                 /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c19 | 0x0000) */ 0x72000c19,
    /* 067,[ R ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],scan_enable[1] */

    HCI_OPS_WRITE_SCAN_ENABLE =                                /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c1a | 0x0000) */ 0x4c4c0c1a,
    /* 068,[CR ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:scan_enable[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_PAGE_SCAN_ACTIVITY =                          /* ((0x6c << 24) 'R'  | (0x00 << 16)  | 0x0c1b | 0x0000) */ 0x6c000c1b,
    /* 069,[ R ],1.1,BREDR,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],page_scan_interval[2],page_scan_window[2] */

    HCI_OPS_WRITE_PAGE_SCAN_ACTIVITY =                         /* ((0x4c << 24) 'R'  | (0x23 << 16)  | 0x0c1c | 0x0000) */ 0x4c230c1c,
    /* 070,[CR ],1.1,BREDR,[CONNECTION SETUP] */
    /* C:page_scan_interval[2],page_scan_window[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_INQUIRY_SCAN_ACTIVITY =                       /* ((0x6c << 24) 'R'  | (0x00 << 16)  | 0x0c1d | 0x0000) */ 0x6c000c1d,
    /* 071,[ R ],1.1,BREDR,[DEVICE DISCOVERY] */
    /* [Command_Complete][0x0E],R:status[1],inquiry_scan_interval[2],inquiry_scan_window[2] */

    HCI_OPS_WRITE_INQUIRY_SCAN_ACTIVITY =                      /* ((0x4c << 24) 'R'  | (0x23 << 16)  | 0x0c1e | 0x0000) */ 0x4c230c1e,
    /* 072,[CR ],1.1,BREDR,[DEVICE DISCOVERY] */
    /* C:inquiry_scan_interval[2],inquiry_scan_window[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_AUTHENTICATION_ENABLE =                       /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c1f | 0x0000) */ 0x72000c1f,
    /* 073,[ R ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1],authentication_enable[1] */

    HCI_OPS_WRITE_AUTHENTICATION_ENABLE =                      /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c20 | 0x0000) */ 0x4c4c0c20,
    /* 074,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:authentication_enable[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_ENCRYPTION_MODE =                             /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c21 | 0x0000) */ 0x72000c21,
    /* 075,[ R ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1],encryption_mode[1] */

    HCI_OPS_WRITE_ENCRYPTION_MODE =                            /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c22 | 0x0000) */ 0x4c4c0c22,
    /* 076,[CR ],1.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:encryption_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_CLASS_OF_DEVICE =                             /* ((0x78 << 24) 'R'  | (0x00 << 16)  | 0x0c23 | 0x0000) */ 0x78000c23,
    /* 077,[ R ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],class_of_device[3] */

    HCI_OPS_WRITE_CLASS_OF_DEVICE =                            /* ((0x4c << 24) 'R'  | (0x7d << 16)  | 0x0c24 | 0x0000) */ 0x4c7d0c24,
    /* 078,[CR ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:class_of_device[3] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_VOICE_SETTING =                               /* ((0x6e << 24) 'R'  | (0x00 << 16)  | 0x0c25 | 0x0000) */ 0x6e000c25,
    /* 079,[ R ],1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
    /* [Command_Complete][0x0E],R:status[1],voice_setting[2] */

    HCI_OPS_WRITE_VOICE_SETTING =                              /* ((0x4c << 24) 'R'  | (0x18 << 16)  | 0x0c26 | 0x0000) */ 0x4c180c26,
    /* 080,[CR ],1.1,BREDR,[SYNCHRONOUS CONNECTIONS] */
    /* C:voice_setting[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_AUTOMATIC_FLUSH_TIMEOUT =                     /* ((0x6c << 24) 'R'  | (0x18 << 16)  | 0x0c27 | 0x0000) */ 0x6c180c27,
    /* 081,[CR ],1.1,BREDR,[QUALITY OF SERVICE] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],flush_timeout[2] */

    HCI_OPS_WRITE_AUTOMATIC_FLUSH_TIMEOUT =                    /* ((0x6e << 24) 'R'  | (0x23 << 16)  | 0x0c28 | 0x0000) */ 0x6e230c28,
    /* 082,[CR ],1.1,BREDR,[QUALITY OF SERVICE] */
    /* C:connection_handle[2],flush_timeout[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */

    HCI_OPS_READ_NUM_BROADCAST_RETRANSMISSIONS =               /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c29 | 0x0000) */ 0x72000c29,
    /* 083,[ R ],1.1,BREDR,[QUALITY OF SERVICE] */
    /* [Command_Complete][0x0E],R:status[1],num_broadcast_retransmissions[1] */

    HCI_OPS_WRITE_NUM_BROADCAST_RETRANSMISSIONS =              /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c2a | 0x0000) */ 0x4c4c0c2a,
    /* 084,[CR ],1.1,BREDR,[QUALITY OF SERVICE] */
    /* C:num_broadcast_retransmissions[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_HOLD_MODE_ACTIVITY =                          /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c2b | 0x0000) */ 0x72000c2b,
    /* 085,[ R ],1.1,BREDR,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],hold_mode_activity[1] */

    HCI_OPS_WRITE_HOLD_MODE_ACTIVITY =                         /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c2c | 0x0000) */ 0x4c4c0c2c,
    /* 086,[CR ],1.1,BREDR,[CONNECTION SETUP] */
    /* C:hold_mode_activity[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_TRANSMIT_POWER_LEVEL =                        /* ((0x6a << 24) 'R'  | (0x62 << 16)  | 0x0c2d | 0x0000) */ 0x6a620c2d,
    /* 087,[CR ],1.1,BREDR/LE,[LINK INFORMATION] */
    /* C:connection_handle[2],type[1] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],transmit_power_level[1] */

    HCI_OPS_READ_SYNCHRONOUS_FLOW_CONTROL_ENABLE =             /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c2e | 0x0000) */ 0x72000c2e,
    /* 088,[ R ],1.1,BREDR,[HOST FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1],synchronous_flow_control_enable[1] */

    HCI_OPS_WRITE_SYNCHRONOUS_FLOW_CONTROL_ENABLE =            /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c2f | 0x0000) */ 0x4c4c0c2f,
    /* 089,[CR ],1.1,BREDR,[HOST FLOW CONTROL] */
    /* C:synchronous_flow_control_enable[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_SET_CONTROLLER_TO_HOST_FLOW_CONTROL =              /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c31 | 0x0000) */ 0x4c4c0c31,
    /* 090,[CR ],1.1,BREDR/LE,[HOST FLOW CONTROL] */
    /* C:flow_control_enable[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_HOST_BUFFER_SIZE =                                 /* ((0x4c << 24) 'R'  | (0x22 << 16)  | 0x0c33 | 0x0000) */ 0x4c220c33,
    /* 091,[CR ],1.1,BREDR/LE,[HOST FLOW CONTROL] */
    /* C:host_acl_data_packet_length[2],host_synchronous_data_packet_length[1],host_total_num_acl_data_packets[2],host_total_num_synchronous_data_packets[2] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_HOST_NUMBER_OF_COMPLETED_PACKETS =                 /* ((0xFF << 24) 'N'  | (0x7a << 16)  | 0x0c35 | 0x0000) */ 0xff7a0c35,
    /* 092,[C -NoCFC],1.1,All,[HOST FLOW CONTROL] */
    /* C:number_of_handles[n],connection_handle[2],host_num_of_completed_packets[2] */
    /* - */

    HCI_OPS_READ_LINK_SUPERVISION_TIMEOUT =                    /* ((0x6c << 24) 'R'  | (0x18 << 16)  | 0x0c36 | 0x0000) */ 0x6c180c36,
    /* 093,[CR ],1.1,BREDR/AMP,[PHYSICAL LINKS] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],link_supervision_timeout[2] */

    HCI_OPS_WRITE_LINK_SUPERVISION_TIMEOUT =                   /* ((0x6e << 24) 'R'  | (0x23 << 16)  | 0x0c37 | 0x0000) */ 0x6e230c37,
    /* 094,[CR ],1.1,BREDR/AMP,[PHYSICAL LINKS] */
    /* C:connection_handle[2],link_supervision_timeout[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */

    HCI_OPS_READ_NUMBER_OF_SUPPORTED_IAC =                     /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c38 | 0x0000) */ 0x72000c38,
    /* 095,[ R ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],num_support_iac[1] */

    HCI_OPS_READ_CURRENT_IAC_LAP =                             /* ((0x7c << 24) 'R'  | (0x00 << 16)  | 0x0c39 | 0x0000) */ 0x7c000c39,
    /* 096,[ R ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],num_current_iac[n],lap[3] */

    HCI_OPS_WRITE_CURRENT_IAC_LAP =                            /* ((0x4c << 24) 'R'  | (0x7e << 16)  | 0x0c3a | 0x0000) */ 0x4c7e0c3a,
    /* 097,[CR ],1.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:num_current_iac[n],lap[3] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_PAGE_SCAN_PERIOD_MODE =                       /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c3b | 0x0000) */ 0x72000c3b,
    /* 098,[ R ],1.1,BREDR,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],page_scan_period_mode[1] */

    HCI_OPS_WRITE_PAGE_SCAN_PERIOD_MODE =                      /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c3c | 0x0000) */ 0x4c4c0c3c,
    /* 099,[CR ],1.1,BREDR,[CONNECTION SETUP] */
    /* C:page_scan_period_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_PAGE_SCAN_MODE =                              /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c3d | 0x0000) */ 0x72000c3d,
    /* 100,[ R ],1.1,BREDR,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],page_scan_mode[1] */

    HCI_OPS_WRITE_PAGE_SCAN_MODE =                             /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c3e | 0x0000) */ 0x4c4c0c3e,
    /* 101,[CR ],1.1,BREDR,[CONNECTION SETUP] */
    /* C:page_scan_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_SET_AFH_HOST_CHANNEL_CLASSIFICATION =              /* ((0x4c << 24) 'R'  | (0x90 << 16)  | 0x0c3f | 0x0000) */ 0x4c900c3f,
    /* 102,[CR ],1.2,BREDR,[PHYSICAL LINKS] */
    /* C:afh_host_channel_classification[10] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_INQUIRY_SCAN_TYPE =                           /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c42 | 0x0000) */ 0x72000c42,
    /* 103,[ R ],1.2,BREDR,[DEVICE DISCOVERY] */
    /* [Command_Complete][0x0E],R:status[1],inquiry_scan_type[1] */

    HCI_OPS_WRITE_INQUIRY_SCAN_TYPE =                          /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c43 | 0x0000) */ 0x4c4c0c43,
    /* 104,[CR ],1.2,BREDR,[DEVICE DISCOVERY] */
    /* C:inquiry_scan_type[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_INQUIRY_MODE =                                /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c44 | 0x0000) */ 0x72000c44,
    /* 105,[ R ],1.2,BREDR,[DEVICE DISCOVERY] */
    /* [Command_Complete][0x0E],R:status[1],inquiry_mode[1] */

    HCI_OPS_WRITE_INQUIRY_MODE =                               /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c45 | 0x0000) */ 0x4c4c0c45,
    /* 106,[CR ],1.2,BREDR,[DEVICE DISCOVERY] */
    /* C:inquiry_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_PAGE_SCAN_TYPE =                              /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c46 | 0x0000) */ 0x72000c46,
    /* 107,[ R ],1.2,BREDR,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1],page_scan_type[1] */

    HCI_OPS_WRITE_PAGE_SCAN_TYPE =                             /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c47 | 0x0000) */ 0x4c4c0c47,
    /* 108,[CR ],1.2,BREDR,[CONNECTION SETUP] */
    /* C:page_scan_type[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_AFH_CHANNEL_ASSESSMENT_MODE =                 /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c48 | 0x0000) */ 0x72000c48,
    /* 109,[ R ],1.2,BREDR,[PHYSICAL LINKS] */
    /* [Command_Complete][0x0E],R:status[1],afh_channel_assessment_mode[1] */

    HCI_OPS_WRITE_AFH_CHANNEL_ASSESSMENT_MODE =                /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c49 | 0x0000) */ 0x4c4c0c49,
    /* 110,[CR ],1.2,BREDR,[PHYSICAL LINKS] */
    /* C:afh_channel_assessment_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_EXTENDED_INQUIRY_RESPONSE =                   /* ((0x44 << 24) 'R'  | (0x00 << 16)  | 0x0c51 | 0x0000) */ 0x44000c51,
    /* 111,[ R ],2.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],fec_required[1],extended_inquiry_response[240] */

    HCI_OPS_WRITE_EXTENDED_INQUIRY_RESPONSE =                  /* ((0x4c << 24) 'R'  | (0x80 << 16)  | 0x0c52 | 0x0000) */ 0x4c800c52,
    /* 112,[CR ],2.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:fec_required[1],extended_inquiry_response[240] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_REFRESH_ENCRYPTION_KEY =                           /* ((0x27 << 24) 'E'  | (0x18 << 16)  | 0x0c53 | 0x8000) */ 0x27188c53,
    /* 113,[C T],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2] */
    /* [Encryption_Key_Refresh_Complete][0x30],P:status[1],connection_handle[2] */

    HCI_OPS_READ_SIMPLE_PAIRING_MODE =                         /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c55 | 0x0000) */ 0x72000c55,
    /* 114,[ R ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1],simple_pairing_mode[1] */

    HCI_OPS_WRITE_SIMPLE_PAIRING_MODE =                        /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c56 | 0x0000) */ 0x4c4c0c56,
    /* 115,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:simple_pairing_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_LOCAL_OOB_DATA =                              /* ((0x47 << 24) 'R'  | (0x00 << 16)  | 0x0c57 | 0x0000) */ 0x47000c57,
    /* 116,[ R ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1],c[16],r[16] */

    HCI_OPS_READ_INQUIRY_RESPONSE_TRANSMIT_POWER_LEVEL =       /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c58 | 0x0000) */ 0x72000c58,
    /* 117,[ R ],2.1,BREDR,[DEVICE DISCOVERY] */
    /* [Command_Complete][0x0E],R:status[1],tx_power[1] */

    HCI_OPS_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL =               /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c59 | 0x0000) */ 0x4c4c0c59,
    /* 118,[CR ],2.1,BREDR,[DEVICE DISCOVERY] */
    /* C:tx_power[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_DEFAULT_ERRONEOUS_DATA_REPORTING =            /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c5a | 0x0000) */ 0x72000c5a,
    /* 119,[ R ],2.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],erroneous_data_reporting[1] */

    HCI_OPS_WRITE_DEFAULT_ERRONEOUS_DATA_REPORTING =           /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c5b | 0x0000) */ 0x4c4c0c5b,
    /* 120,[CR ],2.1,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:erroneous_data_reporting[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_ENHANCED_FLUSH =                                   /* ((0x2f << 24) 'E'  | (0x62 << 16)  | 0x0c5f | 0x8000) */ 0x2f628c5f,
    /* 121,[C T],2.1,BREDR/AMP,[QUALITY OF SERVICE] */
    /* C:handle[2],packet_type_flush[1] */
    /* [Enhanced_Flush_Complete][0x39],P:handle[2] */

    HCI_OPS_SEND_KEYPRESS_NOTIFICATION =                       /* ((0x13 << 24) 'R'  | (0x64 << 16)  | 0x0c60 | 0x0000) */ 0x13640c60,
    /* 122,[CR ],2.1,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:bd[6],notification_type[1] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_SET_EVENT_MASK_PAGE_2 =                            /* ((0x4c << 24) 'R'  | (0x8f << 16)  | 0x0c63 | 0x0000) */ 0x4c8f0c63,
    /* 123,[CR ],3.0,BREDR/AMP,[HOST FLOW CONTROL] */
    /* C:event_mask_page_2[8] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_FLOW_CONTROL_MODE =                           /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x0c66 | 0x0000) */ 0x72000c66,
    /* 124,[ R ],3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1],flow_control_mode[1] */

    HCI_OPS_WRITE_FLOW_CONTROL_MODE =                          /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x0c67 | 0x0000) */ 0x4c4c0c67,
    /* 125,[CR ],3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
    /* C:flow_control_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_READ_ENHANCED_TRANSMIT_POWER_LEVEL =               /* ((0x4a << 24) 'R'  | (0x62 << 16)  | 0x0c68 | 0x0000) */ 0x4a620c68,
    /* 126,[CR ],3.0,BREDR,[LINK INFORMATION] */
    /* C:connection_handle[2],type[1] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],transmit_power_level_gfsk[1],transmit_power_level_dqpsk[1],transmit_power_level_8dpsk[1] */

    HCI_OPS_READ_LE_HOST_SUPPORT =                             /* ((0x4b << 24) 'R'  | (0x00 << 16)  | 0x0c6c | 0x0000) */ 0x4b000c6c,
    /* 127,[ R ],4.0,BREDR,[CONTROLLER CONFIGURATION] */
    /* [Command_Complete][0x0E],R:status[1],le_supported_host[1],simultaneous_le_host[1] */

    HCI_OPS_WRITE_LE_HOST_SUPPORT =                            /* ((0x4c << 24) 'R'  | (0x72 << 16)  | 0x0c6d | 0x0000) */ 0x4c720c6d,
    /* 128,[CR ],4.0,BREDR,[CONTROLLER CONFIGURATION] */
    /* C:le_supported_host[1],simultaneous_le_host[1] */
    /* [Command_Complete][0x0E],R:status[1] */


    /*---------------------------------------------------------------------------------*/
    /*                           Informational Param - 0x1000                          */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_READ_LOCAL_VERSION_INFORMATION =                   /* ((0x21 << 24) 'R'  | (0x00 << 16)  | 0x1001 | 0x0000) */ 0x21001001,
    /* 129,[ R ],1.1,All,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],hci_version[1],hci_revision[2],lmp_version[1],manufacturer_name[2],lmp_subversion[2] */

    HCI_OPS_READ_LOCAL_SUPPORTED_COMMANDS =                    /* ((0x82 << 24) 'R'  | (0x00 << 16)  | 0x1002 | 0x0000) */ 0x82001002,
    /* 130,[ R ],1.2,All,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],supported_commands[64] */

    HCI_OPS_READ_LOCAL_SUPPORTED_FEATURES =                    /* ((0x4e << 24) 'R'  | (0x00 << 16)  | 0x1003 | 0x0000) */ 0x4e001003,
    /* 131,[ R ],1.1,All,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],lmp_features[8] */

    HCI_OPS_READ_LOCAL_EXTENDED_FEATURES =                     /* ((0x4d << 24) 'R'  | (0x4c << 16)  | 0x1004 | 0x0000) */ 0x4d4c1004,
    /* 132,[CR ],1.2,BREDR,[CONTROLLER INFORMATION] */
    /* C:page_number[1] */
    /* [Command_Complete][0x0E],R:status[1],page_number[1],max_page_number[1],extended_lmp_features[8] */

    HCI_OPS_READ_BUFFER_SIZE =                                 /* ((0x50 << 24) 'R'  | (0x00 << 16)  | 0x1005 | 0x0000) */ 0x50001005,
    /* 133,[ R ],1.1,All,[CONTROLLER FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1],hc_acl_data_packet_length[2],hc_synchronous_data_packet_length[1],hc_total_num_acl_data_packets[2],hc_total_num_synchronous_data_packets[2] */

    HCI_OPS_READ_COUNTRY_CODE =                                /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x1007 | 0x0000) */ 0x72001007,
    /* 134,[ R ],1.1,BREDR,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],country_code[1] */

    HCI_OPS_READ_BD_ADDR =                                     /* ((0x13 << 24) 'R'  | (0x00 << 16)  | 0x1009 | 0x0000) */ 0x13001009,
    /* 135,[ R ],1.1,BREDR/LE,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],bd[6] */

    HCI_OPS_READ_DATA_BLOCK_SIZE =                             /* ((0x53 << 24) 'R'  | (0x00 << 16)  | 0x100a | 0x0000) */ 0x5300100a,
    /* 136,[ R ],3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1],max_acl_data_packet_length[2],data_block_length[2],total_num_data_blocks[2] */


    /*---------------------------------------------------------------------------------*/
    /*                              Status Param - 0x1400                              */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_READ_FAILED_CONTACT_COUNTER =                      /* ((0x6c << 24) 'R'  | (0x18 << 16)  | 0x1401 | 0x0000) */ 0x6c181401,
    /* 137,[CR ],1.1,BREDR/AMP,[QUALITY OF SERVICE] */
    /* C:handle[2] */
    /* [Command_Complete][0x0E],R:status[1],handle[2],failed_contact_counter[2] */

    HCI_OPS_RESET_FAILED_CONTACT_COUNTER =                     /* ((0x6e << 24) 'R'  | (0x18 << 16)  | 0x1402 | 0x0000) */ 0x6e181402,
    /* 138,[CR ],1.1,BREDR/AMP,[QUALITY OF SERVICE] */
    /* C:handle[2] */
    /* [Command_Complete][0x0E],R:status[1],handle[2] */

    HCI_OPS_READ_LINK_QUALITY =                                /* ((0x6a << 24) 'R'  | (0x18 << 16)  | 0x1403 | 0x0000) */ 0x6a181403,
    /* 139,[CR ],1.1,BREDR/AMP,[LINK INFORMATION] */
    /* C:handle[2] */
    /* [Command_Complete][0x0E],R:status[1],handle[2],link_quality[1] */

    HCI_OPS_READ_RSSI =                                        /* ((0x6a << 24) 'R'  | (0x18 << 16)  | 0x1405 | 0x0000) */ 0x6a181405,
    /* 140,[CR ],1.1,All,[LINK INFORMATION] */
    /* C:handle[2] */
    /* [Command_Complete][0x0E],R:status[1],handle[2],rssi[1] */

    HCI_OPS_READ_AFH_CHANNEL_MAP =                             /* ((0x56 << 24) 'R'  | (0x18 << 16)  | 0x1406 | 0x0000) */ 0x56181406,
    /* 141,[CR ],1.2,BREDR,[LINK INFORMATION] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],afh_mode[1],afh_channel_map[10] */

    HCI_OPS_READ_CLOCK =                                       /* ((0x59 << 24) 'R'  | (0x62 << 16)  | 0x1407 | 0x0000) */ 0x59621407,
    /* 142,[CR ],1.2,BREDR,[LINK INFORMATION] */
    /* C:connection_handle[2],which_clock[1] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],clock[4],accuracy[2] */

    HCI_OPS_READ_ENCRYPTION_KEY_SIZE =                         /* ((0x6a << 24) 'R'  | (0x18 << 16)  | 0x1408 | 0x0000) */ 0x6a181408,
    /* 143,[CR ],3.0,BREDR,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],key_size[1] */


    /*---------------------------------------------------------------------------------*/
    /*                                 Testing - 0x1800                                */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_READ_LOOPBACK_MODE =                               /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x1801 | 0x0000) */ 0x72001801,
    /* 144,[ R ],1.1,BREDR,[TESTING] */
    /* [Command_Complete][0x0E],R:status[1],loopback_mode[1] */

    HCI_OPS_WRITE_LOOPBACK_MODE =                              /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x1802 | 0x0000) */ 0x4c4c1802,
    /* 145,[CR ],1.1,BREDR,[TESTING] */
    /* C:loopback_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_ENABLE_DEVICE_UNDER_TEST_MODE =                    /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x1803 | 0x0000) */ 0x4c001803,
    /* 146,[ R ],1.1,BREDR,[TESTING] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_WRITE_SIMPLE_PAIRING_DEBUG_MODE =                  /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x1804 | 0x0000) */ 0x4c4c1804,
    /* 147,[CR ],2.1,BREDR,[TESTING] */
    /* C:simple_pairing_debug_mode[1] */
    /* [Command_Complete][0x0E],R:status[1] */


    /*---------------------------------------------------------------------------------*/
    /*                              LE Controller - 0x2000                             */
    /*---------------------------------------------------------------------------------*/
    HCI_OPS_LE_SET_EVENT_MASK =                                /* ((0x4c << 24) 'R'  | (0x8f << 16)  | 0x2001 | 0x0000) */ 0x4c8f2001,
    /* 148,[CR ],4.0,LE,[HOST FLOW CONTROL] */
    /* C:le_event_mask[8] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_READ_BUFFER_SIZE =                              /* ((0x6a << 24) 'R'  | (0x00 << 16)  | 0x2002 | 0x0000) */ 0x6a002002,
    /* 149,[ R ],4.0,LE,[CONTROLLER FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1],hc_le_acl_data_packet_length[2],hc_total_num_le_acl_data_packets[1] */

    HCI_OPS_LE_READ_LOCAL_SUPPORTED_FEATURES =                 /* ((0x4e << 24) 'R'  | (0x00 << 16)  | 0x2003 | 0x0000) */ 0x4e002003,
    /* 150,[ R ],4.0,LE,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],le_features[8] */

    HCI_OPS_LE_SET_RANDOM_ADDRESS =                            /* ((0x4c << 24) 'R'  | (0x8e << 16)  | 0x2005 | 0x0000) */ 0x4c8e2005,
    /* 151,[CR ],4.0,LE,[CONTROLLER CONFIGURATION] */
    /* C:random_address[6] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_SET_ADVERTISING_PARAMETERS =                    /* ((0x4c << 24) 'R'  | (0x0c << 16)  | 0x2006 | 0x0000) */ 0x4c0c2006,
    /* 152,[CR ],4.0,LE,[CONTROLLER CONFIGURATION] */
    /* C:advertising_interval_min[2],advertising_interval_max[2],advertising_type[1],own_address_type[1],direct_address_type[1],direct_address[6],advertising_channel_map[1],advertising_filter_policy[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_READ_ADVERTISING_CHANNEL_TX_POWER =             /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x2007 | 0x0000) */ 0x72002007,
    /* 153,[ R ],4.0,LE,[LINK INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],transmit_power_level[1] */

    HCI_OPS_LE_SET_ADVERTISING_DATA =                          /* ((0x4c << 24) 'R'  | (0x84 << 16)  | 0x2008 | 0x0000) */ 0x4c842008,
    /* 154,[CR ],4.0,LE,[CONTROLLER CONFIGURATION] */
    /* C:advertising_data_length[1],advertising_data[31] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_SET_SCAN_RESPONSE_DATA =                        /* ((0x4c << 24) 'R'  | (0x84 << 16)  | 0x2009 | 0x0000) */ 0x4c842009,
    /* 155,[CR ],4.0,LE,[CONTROLLER CONFIGURATION] */
    /* C:scan_response_data_length[1],scan_response_data[31] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_SET_ADVERTISE_ENABLE =                          /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x200a | 0x0000) */ 0x4c4c200a,
    /* 156,[CR ],4.0,LE,[CONTROLLER CONFIGURATION] */
    /* C:advertising_enable[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_SET_SCAN_PARAMETERS =                           /* ((0x4c << 24) 'R'  | (0x5c << 16)  | 0x200b | 0x0000) */ 0x4c5c200b,
    /* 157,[CR ],4.0,LE,[DEVICE DISCOVERY] */
    /* C:le_scan_type[1],le_scan_interval[2],le_scan_window[2],own_address_type[1],scanning_filter_policy[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_SET_SCAN_ENABLE =                               /* ((0x4c << 24) 'R'  | (0x72 << 16)  | 0x200c | 0x0000) */ 0x4c72200c,
    /* 158,[CR ],4.0,LE,[DEVICE DISCOVERY] */
    /* C:le_scan_enable[1],filter_duplicates[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_CREATE_CONNECTION =                             /* ((0x36 << 24) 'L'  | (0x00 << 16)  | 0x200d | 0x8000) */ 0x3600a00d,
    /* 159,[C T],4.0,LE,[CONNECTION SETUP] */
    /* C:le_scan_interval[2],le_scan_window[2],initiator_filter_policy[1],peer_address_type[1],peer_address[6],own_address_type[1],conn_interval_min[2],conn_interval_max[2],leconn_latency[2],supervision_timeout[2],min_ce_length[2],max_ce_length[2] */
    /* [LE_Connection_Complete][0x01],P:status[1],connection_handle[2],role[1],peer_address_type[1],peer_address[6],conn_interval[2],leconn_latency[2],supervision_timeout[2],master_clock_accuracy[1] */

    HCI_OPS_LE_CREATE_CONNECTION_CANCEL =                      /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x200e | 0x0000) */ 0x4c00200e,
    /* 160,[ R ],4.0,LE,[CONNECTION SETUP] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_READ_WHITE_LIST_SIZE =                          /* ((0x72 << 24) 'R'  | (0x00 << 16)  | 0x200f | 0x0000) */ 0x7200200f,
    /* 161,[ R ],4.0,LE,[HOST FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1],white_list_size[1] */

    HCI_OPS_LE_CLEAR_WHITE_LIST =                              /* ((0x4c << 24) 'R'  | (0x00 << 16)  | 0x2010 | 0x0000) */ 0x4c002010,
    /* 162,[ R ],4.0,LE,[HOST FLOW CONTROL] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_ADD_DEVICE_TO_WHITE_LIST =                      /* ((0x4c << 24) 'R'  | (0x13 << 16)  | 0x2011 | 0x0000) */ 0x4c132011,
    /* 163,[CR ],4.0,LE,[HOST FLOW CONTROL] */
    /* C:peer_address_type[1],peer_address[6] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_REMOVE_DEVICE_FROM_WHITE_LIST =                 /* ((0x4c << 24) 'R'  | (0x13 << 16)  | 0x2012 | 0x0000) */ 0x4c132012,
    /* 164,[CR ],4.0,LE,[HOST FLOW CONTROL] */
    /* C:peer_address_type[1],peer_address[6] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_CONNECTION_UPDATE =                             /* ((0x38 << 24) 'L'  | (0x25 << 16)  | 0x2013 | 0x8000) */ 0x3825a013,
    /* 165,[C T],4.0,LE,[CONNECTION STATE] */
    /* C:connection_handle[2],conn_interval_min[2],conn_interval_max[2],leconn_latency[2],supervision_timeout[2],min_ce_length[2],max_ce_length[2] */
    /* [LE_Connection_Update_Complete][0x03],P:status[1],connection_handle[2],conn_interval[2],leconn_latency[2],supervision_timeout[2] */

    HCI_OPS_LE_SET_HOST_CHANNEL_CLASSIFICATION =               /* ((0x4c << 24) 'R'  | (0x87 << 16)  | 0x2014 | 0x0000) */ 0x4c872014,
    /* 166,[CR ],4.0,LE,[PHYSICAL LINKS] */
    /* C:channel_map[5] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_READ_CHANNEL_MAP =                              /* ((0x86 << 24) 'R'  | (0x18 << 16)  | 0x2015 | 0x0000) */ 0x86182015,
    /* 167,[CR ],4.0,LE,[LINK INFORMATION] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2],channel_map[5] */

    HCI_OPS_LE_READ_REMOTE_USED_FEATURES =                     /* ((0x39 << 24) 'L'  | (0x18 << 16)  | 0x2016 | 0x8000) */ 0x3918a016,
    /* 168,[C T],4.0,LE,[REMOTE INFORMATION] */
    /* C:connection_handle[2] */
    /* [LE_Read_Remote_Used_Features_Complete][0x04],P:status[1],connection_handle[2],le_features[8] */

    HCI_OPS_LE_ENCRYPT =                                       /* ((0x8a << 24) 'R'  | (0x88 << 16)  | 0x2017 | 0x0000) */ 0x8a882017,
    /* 169,[CR ],4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    /* C:key[16],plaintext_data[16] */
    /* [Command_Complete][0x0E],R:status[1],encrypted_data[16] */

    HCI_OPS_LE_RAND =                                          /* ((0x4e << 24) 'R'  | (0x00 << 16)  | 0x2018 | 0x0000) */ 0x4e002018,
    /* 170,[ R ],4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    /* [Command_Complete][0x0E],R:status[1],random_number[8] */

    HCI_OPS_LE_START_ENCRYPTION =                              /* ((0x27 << 24) 'E'  | (0x5f << 16)  | 0x2019 | 0x8000) */ 0x275fa019,
    /* 171,[C TT],4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2],random_number[8],encryption_diversifier[2],long_term_key[16] */
    /* [Encryption_Key_Refresh_Complete][0x30],P:status[1],connection_handle[2] */
    /* [Encryption_Change][0x08],P:status[1],connection_handle[2],encryption_enable[1] */

    HCI_OPS_LE_LONG_TERM_KEY_REQUEST_REPLY =                   /* ((0x6e << 24) 'R'  | (0x8c << 16)  | 0x201a | 0x0000) */ 0x6e8c201a,
    /* 172,[CR ],4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2],long_term_key[16] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */

    HCI_OPS_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY =          /* ((0x6e << 24) 'R'  | (0x18 << 16)  | 0x201b | 0x0000) */ 0x6e18201b,
    /* 173,[CR ],4.0,LE,[AUTHENTICATION AND ENCRYPTION] */
    /* C:connection_handle[2] */
    /* [Command_Complete][0x0E],R:status[1],connection_handle[2] */

    HCI_OPS_LE_READ_SUPPORTED_STATES =                         /* ((0x4e << 24) 'R'  | (0x00 << 16)  | 0x201c | 0x0000) */ 0x4e00201c,
    /* 174,[ R ],4.0,LE,[CONTROLLER INFORMATION] */
    /* [Command_Complete][0x0E],R:status[1],le_states[8] */

    HCI_OPS_LE_RECEIVER_TEST =                                 /* ((0x4c << 24) 'R'  | (0x4c << 16)  | 0x201d | 0x0000) */ 0x4c4c201d,
    /* 175,[CR ],4.0,LE,[TESTING] */
    /* C:rx_frequency[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_TRANSMITTER_TEST =                              /* ((0x4c << 24) 'R'  | (0x4b << 16)  | 0x201e | 0x0000) */ 0x4c4b201e,
    /* 176,[CR ],4.0,LE,[TESTING] */
    /* C:tx_frequency[1],length_of_test_data[1],packet_payload[1] */
    /* [Command_Complete][0x0E],R:status[1] */

    HCI_OPS_LE_TEST_END =                                      /* ((0x6e << 24) 'R'  | (0x00 << 16)  | 0x201f | 0x0000) */ 0x6e00201f,
    /* 177,[ R ],4.0,LE,[TESTING] */
    /* [Command_Complete][0x0E],R:status[1],number_of_packets[2] */

};
#pragma __PRQA_IGNORE_END__
/*---------------------------------------------------------------------------------*/
/*                            Event Code Internal Index                            */
/*---------------------------------------------------------------------------------*/

enum
{
    HCI_EVI_INQUIRY_COMPLETE =                                 0x00,
    /* 00,[EvCode:0x01],[1.1,BREDR,[DEVICE DISCOVERY]] */
    /* [status[1]] */

    HCI_EVI_INQUIRY_RESULT =                                   0x01,
    /* 01,[EvCode:0x02],[1.1,BREDR,[DEVICE DISCOVERY]] */
    /* [num_responses[n],bd[6],page_scan_repetition_mode[1],page_scan_period_mode[1],page_scan_mode[1],
    class_of_device[3],clock_offset[2]] */

    HCI_EVI_CONNECTION_COMPLETE =                              0x02,
    /* 02,[EvCode:0x03],[1.1,BREDR,[CONNECTION SETUP]] */
    /* [status[1],connection_handle[2],bd[6],link_type[1],encryption_enable[1]] */

    HCI_EVI_CONNECTION_REQUEST =                               0x03,
    /* 03,[EvCode:0x04],[1.1,BREDR,[CONNECTION SETUP]] */
    /* [bd[6],class_of_device[3],link_type[1]] */

    HCI_EVI_DISCONNECTION_COMPLETE =                           0x04,
    /* 04,[EvCode:0x05],[1.1,BREDR/LE,[CONNECTION SETUP]] */
    /* [status[1],connection_handle[2],reason[1]] */

    HCI_EVI_AUTHENTICATION_COMPLETE =                          0x05,
    /* 05,[EvCode:0x06],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [status[1],connection_handle[2]] */

    HCI_EVI_REMOTE_NAME_REQUEST_COMPLETE =                     0x06,
    /* 06,[EvCode:0x07],[1.1,BREDR,[REMOTE INFORMATION]] */
    /* [status[1],bd[6],remote_name[248]] */

    HCI_EVI_ENCRYPTION_CHANGE =                                0x07,
    /* 07,[EvCode:0x08],[1.1,BREDR/LE,[AUTHENTICATION AND ENCRYPTION]] */
    /* [status[1],connection_handle[2],encryption_enable[1]] */

    HCI_EVI_CHANGE_CONNECTION_LINK_KEY_COMPLETE =              0x08,
    /* 08,[EvCode:0x09],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [status[1],connection_handle[2]] */

    HCI_EVI_MASTER_LINK_KEY_COMPLETE =                         0x09,
    /* 09,[EvCode:0x0a],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [status[1],connection_handle[2],key_flag[1]] */

    HCI_EVI_READ_REMOTE_SUPPORTED_FEATURES_COMPLETE =          0x0a,
    /* 10,[EvCode:0x0b],[1.1,BREDR,[REMOTE INFORMATION]] */
    /* [status[1],connection_handle[2],lmp_features[8]] */

    HCI_EVI_READ_REMOTE_VERSION_INFORMATION_COMPLETE =         0x0b,
    /* 11,[EvCode:0x0c],[1.1,BREDR/LE,[REMOTE INFORMATION]] */
    /* [status[1],connection_handle[2],lmp_version[1],manufacturer_name[2],lmp_subversion[2]] */

    HCI_EVI_QOS_SETUP_COMPLETE =                               0x0c,
    /* 12,[EvCode:0x0d],[1.1,BREDR,[QUALITY OF SERVICE]] */
    /* [status[1],connection_handle[2],flags[1],service_type[1],token_rate[4],peak_bandwidth[4],
    latency[4],delay_variation[4]] */

    HCI_EVI_COMMAND_COMPLETE =                                 0x0d,
    /* 13,[EvCode:0x0e],[1.1,All,[GENERIC EVENTS]] */
    /* [num_hci_command_packets[1],command_opcode[2],return_parameters[x]] */

    HCI_EVI_COMMAND_STATUS =                                   0x0e,
    /* 14,[EvCode:0x0f],[1.1,All,[GENERIC EVENTS]] */
    /* [status[1],num_hci_command_packets[1],command_opcode[2]] */

    HCI_EVI_HARDWARE_ERROR =                                   0x0f,
    /* 15,[EvCode:0x10],[1.1,All,[GENERIC EVENTS]] */
    /* [hardware_code[1]] */

    HCI_EVI_FLUSH_OCCURRED =                                   0x10,
    /* 16,[EvCode:0x11],[1.1,BREDR/AMP,[QUALITY OF SERVICE]] */
    /* [handle[2]] */

    HCI_EVI_ROLE_CHANGE =                                      0x11,
    /* 17,[EvCode:0x12],[1.1,BREDR,[PICONET STRUCTURE]] */
    /* [status[1],bd[6],role[1]] */

    HCI_EVI_NUMBER_OF_COMPLETED_PACKETS =                      0x12,
    /* 18,[EvCode:0x13],[1.1,All,[CONTROLLER FLOW CONTROL]] */
    /* [number_of_handles[n],connection_handle[2],hc_num_of_completed_packets[2]] */

    HCI_EVI_MODE_CHANGE =                                      0x13,
    /* 19,[EvCode:0x14],[1.1,BREDR,[CONNECTION STATE]] */
    /* [status[1],connection_handle[2],current_mode[1],interval[2]] */

    HCI_EVI_RETURN_LINK_KEYS =                                 0x14,
    /* 20,[EvCode:0x15],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [num_keys[n],bd[6],link_key[16]] */

    HCI_EVI_PIN_CODE_REQUEST =                                 0x15,
    /* 21,[EvCode:0x16],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6]] */

    HCI_EVI_LINK_KEY_REQUEST =                                 0x16,
    /* 22,[EvCode:0x17],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6]] */

    HCI_EVI_LINK_KEY_NOTIFICATION =                            0x17,
    /* 23,[EvCode:0x18],[1.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6],link_key[16],key_type[1]] */

    HCI_EVI_LOOPBACK_COMMAND =                                 0x18,
    /* 24,[EvCode:0x19],[1.1,BREDR,[TESTING]] */
    /* [hci_command_packet[x]] */

    HCI_EVI_DATA_BUFFER_OVERFLOW =                             0x19,
    /* 25,[EvCode:0x1a],[1.1,All,[HOST FLOW CONTROL]] */
    /* [link_type[1]] */

    HCI_EVI_MAX_SLOTS_CHANGE =                                 0x1a,
    /* 26,[EvCode:0x1b],[1.1,BREDR,[CONNECTION STATE]] */
    /* [connection_handle[2],lmp_max_slots[1]] */

    HCI_EVI_READ_CLOCK_OFFSET_COMPLETE =                       0x1b,
    /* 27,[EvCode:0x1c],[1.1,BREDR,[LINK INFORMATION]] */
    /* [status[1],connection_handle[2],clock_offset[2]] */

    HCI_EVI_CONNECTION_PACKET_TYPE_CHANGED =                   0x1c,
    /* 28,[EvCode:0x1d],[1.1,BREDR,[PHYSICAL LINKS]] */
    /* [status[1],connection_handle[2],packet_type[2]] */

    HCI_EVI_QOS_VIOLATION =                                    0x1d,
    /* 29,[EvCode:0x1e],[1.1,BREDR,[QUALITY OF SERVICE]] */
    /* [handle[2]] */

    HCI_EVI_PAGE_SCAN_MODE_CHANGE =                            0x1e,
    /* 30,[EvCode:0x1f],[1.1,BREDR,[CONNECTION SETUP]] */
    /* [bd[6],page_scan_mode[1]] */

    HCI_EVI_PAGE_SCAN_REPETITION_MODE_CHANGE =                 0x1f,
    /* 31,[EvCode:0x20],[1.1,BREDR,[CONNECTION SETUP]] */
    /* [bd[6],page_scan_repetition_mode[1]] */

    HCI_EVI_FLOW_SPECIFICATION_COMPLETE =                      0x20,
    /* 32,[EvCode:0x21],[1.2,BREDR,[QUALITY OF SERVICE]] */
    /* [status[1],connection_handle[2],flags[1],flow_direction[1],service_type[1],token_rate[4],
    token_bucket_size[4],peak_bandwidth[4],latency[4]] */

    HCI_EVI_INQUIRY_RESULT_WITH_RSSI =                         0x21,
    /* 33,[EvCode:0x22],[1.2,BREDR,[DEVICE DISCOVERY]] */
    /* [num_responses[n],bd[6],page_scan_repetition_mode[1],page_scan_period_mode[1],class_of_device[3],
    clock_offset[2],rssi[1]] */

    HCI_EVI_READ_REMOTE_EXTENDED_FEATURES_COMPLETE =           0x22,
    /* 34,[EvCode:0x23],[1.2,BREDR,[REMOTE INFORMATION]] */
    /* [status[1],connection_handle[2],page_number[1],max_page_number[1],extended_lmp_features[8]] */

    HCI_EVI_SYNCHRONOUS_CONNECTION_COMPLETE =                  0x23,
    /* 35,[EvCode:0x2c],[1.2,BREDR,[SYNCHRONOUS CONNECTIONS]] */
    /* [status[1],connection_handle[2],bd[6],link_type[1],transmission_interval[1],retransmission_window[1],
    rx_packet_length[2],tx_packet_length[2],air_mode[1]] */

    HCI_EVI_SYNCHRONOUS_CONNECTION_CHANGED =                   0x24,
    /* 36,[EvCode:0x2d],[1.2,BREDR,[SYNCHRONOUS CONNECTIONS]] */
    /* [status[1],connection_handle[2],transmission_interval[1],retransmission_window[1],rx_packet_length[2],
    tx_packet_length[2]] */

    HCI_EVI_SNIFF_SUBRATING =                                  0x25,
    /* 37,[EvCode:0x2e],[2.1,BREDR,[CONNECTION STATE]] */
    /* [status[1],connection_handle[2],max_transmit_latency[2],max_receive_latency[2],min_remote_timeout[2],
    min_local_timeout[2]] */

    HCI_EVI_EXTENDED_INQUIRY_RESULT =                          0x26,
    /* 38,[EvCode:0x2f],[2.1,BREDR,[DEVICE DISCOVERY]] */
    /* [num_responses[1],bd[6],page_scan_repetition_mode[1],reserved[1],class_of_device[3],clock_offset[2],
    rssi[1],extended_inquiry_response[240]] */

    HCI_EVI_ENCRYPTION_KEY_REFRESH_COMPLETE =                  0x27,
    /* 39,[EvCode:0x30],[2.1,BREDR/LE,[AUTHENTICATION AND ENCRYPTION]] */
    /* [status[1],connection_handle[2]] */

    HCI_EVI_IO_CAPABILITY_REQUEST =                            0x28,
    /* 40,[EvCode:0x31],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6]] */

    HCI_EVI_IO_CAPABILITY_RESPONSE =                           0x29,
    /* 41,[EvCode:0x32],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6],io_capability[1],oob_data_present[1],authentication_requirements[1]] */

    HCI_EVI_USER_CONFIRMATION_REQUEST =                        0x2a,
    /* 42,[EvCode:0x33],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6],numeric_value[4]] */

    HCI_EVI_USER_PASSKEY_REQUEST =                             0x2b,
    /* 43,[EvCode:0x34],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6]] */

    HCI_EVI_REMOTE_OOB_DATA_REQUEST =                          0x2c,
    /* 44,[EvCode:0x35],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6]] */

    HCI_EVI_SIMPLE_PAIRING_COMPLETE =                          0x2d,
    /* 45,[EvCode:0x36],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [status[1],bd[6]] */

    HCI_EVI_LINK_SUPERVISION_TIMEOUT_CHANGED =                 0x2e,
    /* 46,[EvCode:0x38],[2.1,BREDR,[PHYSICAL LINKS]] */
    /* [connection_handle[2],link_supervision_timeout[2]] */

    HCI_EVI_ENHANCED_FLUSH_COMPLETE =                          0x2f,
    /* 47,[EvCode:0x39],[2.1,BREDR/AMP,[QUALITY OF SERVICE]] */
    /* [handle[2]] */

    HCI_EVI_USER_PASSKEY_NOTIFICATION =                        0x30,
    /* 48,[EvCode:0x3b],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6],passkey[4]] */

    HCI_EVI_KEYPRESS_NOTIFICATION =                            0x31,
    /* 49,[EvCode:0x3c],[2.1,BREDR,[AUTHENTICATION AND ENCRYPTION]] */
    /* [bd[6],notification_type[1]] */

    HCI_EVI_REMOTE_HOST_SUPPORTED_FEATURES_NOTIFICATION =      0x32,
    /* 50,[EvCode:0x3d],[2.1,BREDR,[REMOTE INFORMATION]] */
    /* [bd[6],host_supported_features[8]] */

    HCI_EVI_LE_META =                                          0x33,
    /* 51,[EvCode:0x3e],[4.0,LE,[LE]] */
    /* [sub_eventcode[1],param[x]] */

    HCI_EVI_NUMBER_OF_COMPLETED_DATA_BLOCKS =                  0x34,
    /* 52,[EvCode:0x48],[3.0,BREDR/AMP,[CONTROLLER FLOW CONTROL]] */
    /* [total_num_data_blocks[2],number_of_handles[n],handle[2],num_of_completed_packets[2],
    num_of_completed_blocks[2]] */

    HCI_EVI_VENDOR =                                           0x35,
    /* 53,[EvCode:0xff],[1.1,All,[VENDOR]] */
    /* [vendordata[x]] */

    HCI_EVI_LE_CONNECTION_COMPLETE =                           HCI_EVI_VENDOR + 0x01,
    /* 54,[EvCode:0x01],[4.0,LE,[CONNECTION SETUP]] */
    /* [status[1],connection_handle[2],role[1],peer_address_type[1],peer_address[6],conn_interval[2],
    leconn_latency[2],supervision_timeout[2],master_clock_accuracy[1]] */

    HCI_EVI_LE_ADVERTISING_REPORT =                            HCI_EVI_VENDOR + 0x02,
    /* 55,[EvCode:0x02],[4.0,LE,[DEVICE DISCOVERY]] */
    /* [num_reports[1],param[x]] */

    HCI_EVI_LE_CONNECTION_UPDATE_COMPLETE =                    HCI_EVI_VENDOR + 0x03,
    /* 56,[EvCode:0x03],[4.0,LE,[CONNECTION STATE]] */
    /* [status[1],connection_handle[2],conn_interval[2],leconn_latency[2],supervision_timeout[2]] */

    HCI_EVI_LE_READ_REMOTE_USED_FEATURES_COMPLETE =            HCI_EVI_VENDOR + 0x04,
    /* 57,[EvCode:0x04],[4.0,LE,[REMOTE INFORMATION]] */
    /* [status[1],connection_handle[2],le_features[8]] */

    HCI_EVI_LE_LONG_TERM_KEY_REQUEST =                         HCI_EVI_VENDOR + 0x05,
    /* 58,[EvCode:0x05],[4.0,LE,[AUTHENTICATION AND ENCRYPTION]] */
    /* [connection_handle[2],random_number[8],encrypted_diversifier[2]] */

};

#pragma __PRQA_IGNORE_START__

/*---------------------------------------------------------------------------------*/
/*                      Event Gap Table for Event Code & Index                     */
/*---------------------------------------------------------------------------------*/

/* HCI Spec defined EvCode are incoherenced, convert to EvIndex for contiguous memory */
struct HCI_IndexGapStru
{
    UINT8 code;/* evcode */
    UINT8 gap;
};


/*---------------------------------------------------------------------------------*/
/*                  Event_Complete matches Command_Request Opcode                  */
/*---------------------------------------------------------------------------------*/

/* Commands that have more than one default termination events */
struct HCI_EventCommandStru
{
    UINT16 opcode;
    UINT8 evindex;
};


/*---------------------------------------------------------------------------------*/
/*                                    Parameters                                   */
/*---------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------*/
/*                             [001][Status][Enum][L:0]                            */
/*---------------------------------------------------------------------------------*/
/* Return                   Inquiry_Cancel                                (0x0402) */
/* Return                   Periodic_Inquiry_Mode                         (0x0403) */
/* Return                   Exit_Periodic_Inquiry_Mode                    (0x0404) */
/* Return                   Create_Connection_Cancel                      (0x0408) */
/* Return                   Link_Key_Request_Reply                        (0x040b) */
/* Return                   Link_Key_Request_Negative_Reply               (0x040c) */
/* Return                   PIN_Code_Request_Reply                        (0x040d) */
/* Return                   PIN_Code_Request_Negative_Reply               (0x040e) */
/* Return                   Remote_Name_Request_Cancel                    (0x041a) */
/* Return                   Read_LMP_Handle                               (0x0420) */
/* Return                   IO_Capability_Request_Reply                   (0x042b) */
/* Return                   User_Confirmation_Request_Reply               (0x042c) */
/* Return                   User_Confirmation_Request_Negative_Reply      (0x042d) */
/* Return                   User_Passkey_Request_Reply                    (0x042e) */
/* Return                   User_Passkey_Request_Negative_Reply           (0x042f) */
/* Return                   Remote_OOB_Data_Request_Reply                 (0x0430) */
/* Return                   Remote_OOB_Data_Request_Negative_Reply        (0x0433) */
/* Return                   IO_Capability_Request_Negative_Reply          (0x0434) */
/* Return                   Role_Discovery                                (0x0809) */
/* Return                   Read_Link_Policy_Settings                     (0x080c) */
/* Return                   Write_Link_Policy_Settings                    (0x080d) */
/* Return                   Read_Default_Link_Policy_Settings             (0x080e) */
/* Return                   Write_Default_Link_Policy_Settings            (0x080f) */
/* Return                   Sniff_Subrating                               (0x0811) */
/* Return                   Set_Event_Mask                                (0x0c01) */
/* Return                   Reset                                         (0x0c03) */
/* Return                   Set_Event_Filter                              (0x0c05) */
/* Return                   Flush                                         (0x0c08) */
/* Return                   Read_PIN_Type                                 (0x0c09) */
/* Return                   Write_PIN_Type                                (0x0c0a) */
/* Return                   Create_New_Unit_Key                           (0x0c0b) */
/* Return                   Read_Stored_Link_Key                          (0x0c0d) */
/* Return                   Write_Stored_Link_Key                         (0x0c11) */
/* Return                   Delete_Stored_Link_Key                        (0x0c12) */
/* Return                   Write_Local_Name                              (0x0c13) */
/* Return                   Read_Local_Name                               (0x0c14) */
/* Return                   Read_Connection_Accept_Timeout                (0x0c15) */
/* Return                   Write_Connection_Accept_Timeout               (0x0c16) */
/* Return                   Read_Page_Timeout                             (0x0c17) */
/* Return                   Write_Page_Timeout                            (0x0c18) */
/* Return                   Read_Scan_Enable                              (0x0c19) */
/* Return                   Write_Scan_Enable                             (0x0c1a) */
/* Return                   Read_Page_Scan_Activity                       (0x0c1b) */
/* Return                   Write_Page_Scan_Activity                      (0x0c1c) */
/* Return                   Read_Inquiry_Scan_Activity                    (0x0c1d) */
/* Return                   Write_Inquiry_Scan_Activity                   (0x0c1e) */
/* Return                   Read_Authentication_Enable                    (0x0c1f) */
/* Return                   Write_Authentication_Enable                   (0x0c20) */
/* Return                   Read_Encryption_Mode                          (0x0c21) */
/* Return                   Write_Encryption_Mode                         (0x0c22) */
/* Return                   Read_Class_of_Device                          (0x0c23) */
/* Return                   Write_Class_of_Device                         (0x0c24) */
/* Return                   Read_Voice_Setting                            (0x0c25) */
/* Return                   Write_Voice_Setting                           (0x0c26) */
/* Return                   Read_Automatic_Flush_Timeout                  (0x0c27) */
/* Return                   Write_Automatic_Flush_Timeout                 (0x0c28) */
/* Return                   Read_Num_Broadcast_Retransmissions            (0x0c29) */
/* Return                   Write_Num_Broadcast_Retransmissions           (0x0c2a) */
/* Return                   Read_Hold_Mode_Activity                       (0x0c2b) */
/* Return                   Write_Hold_Mode_Activity                      (0x0c2c) */
/* Return                   Read_Transmit_Power_Level                     (0x0c2d) */
/* Return                   Read_Synchronous_Flow_Control_Enable          (0x0c2e) */
/* Return                   Write_Synchronous_Flow_Control_Enable         (0x0c2f) */
/* Return                   Set_Controller_To_Host_Flow_Control           (0x0c31) */
/* Return                   Host_Buffer_Size                              (0x0c33) */
/* Return                   Read_Link_Supervision_Timeout                 (0x0c36) */
/* Return                   Write_Link_Supervision_Timeout                (0x0c37) */
/* Return                   Read_Number_Of_Supported_IAC                  (0x0c38) */
/* Return                   Read_Current_IAC_LAP                          (0x0c39) */
/* Return                   Write_Current_IAC_LAP                         (0x0c3a) */
/* Return                   Read_Page_Scan_Period_Mode                    (0x0c3b) */
/* Return                   Write_Page_Scan_Period_Mode                   (0x0c3c) */
/* Return                   Read_Page_Scan_Mode                           (0x0c3d) */
/* Return                   Write_Page_Scan_Mode                          (0x0c3e) */
/* Return                   Set_AFH_Host_Channel_Classification           (0x0c3f) */
/* Return                   Read_Inquiry_Scan_Type                        (0x0c42) */
/* Return                   Write_Inquiry_Scan_Type                       (0x0c43) */
/* Return                   Read_Inquiry_Mode                             (0x0c44) */
/* Return                   Write_Inquiry_Mode                            (0x0c45) */
/* Return                   Read_Page_Scan_Type                           (0x0c46) */
/* Return                   Write_Page_Scan_Type                          (0x0c47) */
/* Return                   Read_AFH_Channel_Assessment_Mode              (0x0c48) */
/* Return                   Write_AFH_Channel_Assessment_Mode             (0x0c49) */
/* Return                   Read_Extended_Inquiry_Response                (0x0c51) */
/* Return                   Write_Extended_Inquiry_Response               (0x0c52) */
/* Return                   Read_Simple_Pairing_Mode                      (0x0c55) */
/* Return                   Write_Simple_Pairing_Mode                     (0x0c56) */
/* Return                   Read_Local_OOB_Data                           (0x0c57) */
/* Return                   Read_Inquiry_Response_Transmit_Power_Level    (0x0c58) */
/* Return                   Write_Inquiry_Transmit_Power_Level            (0x0c59) */
/* Return                   Read_Default_Erroneous_Data_Reporting         (0x0c5a) */
/* Return                   Write_Default_Erroneous_Data_Reporting        (0x0c5b) */
/* Return                   Send_Keypress_Notification                    (0x0c60) */
/* Return                   Set_Event_Mask_Page_2                         (0x0c63) */
/* Return                   Read_Flow_Control_Mode                        (0x0c66) */
/* Return                   Write_Flow_Control_Mode                       (0x0c67) */
/* Return                   Read_Enhanced_Transmit_Power_Level            (0x0c68) */
/* Return                   Read_LE_Host_Support                          (0x0c6c) */
/* Return                   Write_LE_Host_Support                         (0x0c6d) */
/* Return                   Read_Local_Version_Information                (0x1001) */
/* Return                   Read_Local_Supported_Commands                 (0x1002) */
/* Return                   Read_Local_Supported_Features                 (0x1003) */
/* Return                   Read_Local_Extended_Features                  (0x1004) */
/* Return                   Read_Buffer_Size                              (0x1005) */
/* Return                   Read_Country_Code                             (0x1007) */
/* Return                   Read_BD_ADDR                                  (0x1009) */
/* Return                   Read_Data_Block_Size                          (0x100a) */
/* Return                   Read_Failed_Contact_Counter                   (0x1401) */
/* Return                   Reset_Failed_Contact_Counter                  (0x1402) */
/* Return                   Read_Link_Quality                             (0x1403) */
/* Return                   Read_RSSI                                     (0x1405) */
/* Return                   Read_AFH_Channel_Map                          (0x1406) */
/* Return                   Read_Clock                                    (0x1407) */
/* Return                   Read_Encryption_Key_Size                      (0x1408) */
/* Return                   Read_Loopback_Mode                            (0x1801) */
/* Return                   Write_Loopback_Mode                           (0x1802) */
/* Return                   Enable_Device_Under_Test_Mode                 (0x1803) */
/* Return                   Write_Simple_Pairing_Debug_Mode               (0x1804) */
/* Return                   LE_Set_Event_Mask                             (0x2001) */
/* Return                   LE_Read_Buffer_Size                           (0x2002) */
/* Return                   LE_Read_Local_Supported_Features              (0x2003) */
/* Return                   LE_Set_Random_Address                         (0x2005) */
/* Return                   LE_Set_Advertising_Parameters                 (0x2006) */
/* Return                   LE_Read_Advertising_Channel_Tx_Power          (0x2007) */
/* Return                   LE_Set_Advertising_Data                       (0x2008) */
/* Return                   LE_Set_Scan_Response_Data                     (0x2009) */
/* Return                   LE_Set_Advertise_Enable                       (0x200a) */
/* Return                   LE_Set_Scan_Parameters                        (0x200b) */
/* Return                   LE_Set_Scan_Enable                            (0x200c) */
/* Return                   LE_Create_Connection_Cancel                   (0x200e) */
/* Return                   LE_Read_White_List_Size                       (0x200f) */
/* Return                   LE_Clear_White_List                           (0x2010) */
/* Return                   LE_Add_Device_To_White_List                   (0x2011) */
/* Return                   LE_Remove_Device_From_White_List              (0x2012) */
/* Return                   LE_Set_Host_Channel_Classification            (0x2014) */
/* Return                   LE_Read_Channel_Map                           (0x2015) */
/* Return                   LE_Encrypt                                    (0x2017) */
/* Return                   LE_Rand                                       (0x2018) */
/* Return                   LE_Long_Term_Key_Request_Reply                (0x201a) */
/* Return                   LE_Long_Term_Key_Request_Negative_Reply       (0x201b) */
/* Return                   LE_Read_Supported_States                      (0x201c) */
/* Return                   LE_Receiver_Test                              (0x201d) */
/* Return                   LE_Transmitter_Test                           (0x201e) */
/* Return                   LE_Test_End                                   (0x201f) */
/* Event                    Inquiry_Complete                              (0x0001) */
/* Event                    Connection_Complete                           (0x0003) */
/* Event                    Disconnection_Complete                        (0x0005) */
/* Event                    Authentication_Complete                       (0x0006) */
/* Event                    Remote_Name_Request_Complete                  (0x0007) */
/* Event                    Encryption_Change                             (0x0008) */
/* Event                    Change_Connection_Link_Key_Complete           (0x0009) */
/* Event                    Master_Link_Key_Complete                      (0x000a) */
/* Event                    Read_Remote_Supported_Features_Complete       (0x000b) */
/* Event                    Read_Remote_Version_Information_Complete      (0x000c) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Command_Status                                (0x000f) */
/* Event                    Role_Change                                   (0x0012) */
/* Event                    Mode_Change                                   (0x0014) */
/* Event                    Read_Clock_Offset_Complete                    (0x001c) */
/* Event                    Connection_Packet_Type_Changed                (0x001d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Event                    Read_Remote_Extended_Features_Complete        (0x0023) */
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Synchronous_Connection_Changed                (0x002d) */
/* Event                    Sniff_Subrating                               (0x002e) */
/* Event                    Encryption_Key_Refresh_Complete               (0x0030) */
/* Event                    Simple_Pairing_Complete                       (0x0036) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
/* LEEvent                  LE_Connection_Update_Complete                 (0x0003) */
/* LEEvent                  LE_Read_Remote_Used_Features_Complete         (0x0004) */
/* Also "Reason", This document lists the various possible error codes. When a
   command fails, or an LMP, LL, or AMP message needs to indicate a failure, error
   codes are used to indicate the reason for the error. Error codes have a size of
   one octet */
typedef enum _tHCI_Status
{
    HCI_STATUS_OK =                                                          0x00,
    HCI_STATUS_UNKNOWN_HCI_COMMAND =                                         0x01,
    HCI_STATUS_UNKNOWN_CONNECTION_IDENTIFIER =                               0x02,
    HCI_STATUS_HARDWARE_FAILURE =                                            0x03,
    HCI_STATUS_PAGE_TIMEOUT =                                                0x04,
    HCI_STATUS_AUTHENTICATION_FAILURE =                                      0x05,
    HCI_STATUS_PIN_OR_KEY_MISSING =                                          0x06,
    HCI_STATUS_MEMORY_CAPACITY_EXCEEDED =                                    0x07,
    HCI_STATUS_CONNECTION_TIMEOUT =                                          0x08,
    HCI_STATUS_CONNECTION_LIMIT_EXCEEDED =                                   0x09,
    HCI_STATUS_SYNCHRONOUS_CONNECTION_LIMIT_TO_A_DEVICE_EXCEEDED =           0x0a,
    HCI_STATUS_ACL_CONNECTION_ALREADY_EXISTS =                               0x0b,
    HCI_STATUS_COMMAND_DISALLOWED =                                          0x0c,
    HCI_STATUS_CONNECTION_REJECTED_LIMITED_RESOURCES =                       0x0d,
    HCI_STATUS_CONNECTION_REJECTED_SECURITY_REASONS =                        0x0e,
    HCI_STATUS_CONNECTION_REJECTED_UNACCEPTABLE_BD_ADDR =                    0x0f,
    HCI_STATUS_CONNECTION_ACCEPT_TIMEOUT_EXCEEDED =                          0x10,
    HCI_STATUS_UNSUPPORTED_FEATURE_OR_PARAMETER_VALUE =                      0x11,
    HCI_STATUS_INVALID_HCI_COMMAND_PARAMETERS =                              0x12,
    HCI_STATUS_REMOTE_USER_TERMINATED_CONNECTION =                           0x13,
    HCI_STATUS_REMOTE_TERMINATED_CONNECTION_LOW_RESOURCES =                  0x14,
    HCI_STATUS_REMOTE_TERMINATED_CONNECTION_POWER_OFF =                      0x15,
    HCI_STATUS_CONNECTION_TERMINATED_BY_LOCAL_HOST =                         0x16,
    HCI_STATUS_REPEATED_ATTEMPTS =                                           0x17,
    HCI_STATUS_PAIRING_NOT_ALLOWED =                                         0x18,
    HCI_STATUS_UNKNOWN_LMP_PDU =                                             0x19,
    HCI_STATUS_UNSUPPORTED_REMOTE_OR_LMP_FEATURE =                           0x1a,
    HCI_STATUS_SCO_OFFSET_REJECTED =                                         0x1b,
    HCI_STATUS_SCO_INTERVAL_REJECTED =                                       0x1c,
    HCI_STATUS_SCO_AIR_MODE_REJECTED =                                       0x1d,
    HCI_STATUS_INVALID_LMP_PARAMETERS =                                      0x1e,
    HCI_STATUS_UNSPECIFIED_ERROR =                                           0x1f,
    HCI_STATUS_UNSUPPORTED_LMP_PARAMETER_VALUE =                             0x20,
    HCI_STATUS_ROLE_CHANGE_NOT_ALLOWED =                                     0x21,
    HCI_STATUS_LMP_OR_LL_RESPONSE_TIMEOUT =                                  0x22,
    HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION =                             0x23,
    HCI_STATUS_LMP_PDU_NOT_ALLOWED =                                         0x24,
    HCI_STATUS_ENCRYPTION_MODE_NOT_ACCEPTABLE =                              0x25,
    HCI_STATUS_LINK_KEY_CANNOT_BE_CHANGED =                                  0x26,
    HCI_STATUS_REQUESTED_QOS_NOT_SUPPORTED =                                 0x27,
    HCI_STATUS_INSTANT_PASSED =                                              0x28,
    HCI_STATUS_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED =                         0x29,
    HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION =                             0x2a,
    HCI_STATUS_QOS_UNACCEPTABLE_PARAMETER =                                  0x2c,
    HCI_STATUS_QOS_REJECTED =                                                0x2d,
    HCI_STATUS_CHANNEL_ASSESSMENT_NOT_SUPPORTED =                            0x2e,
    HCI_STATUS_INSUFFICIENT_SECURITY =                                       0x2f,
    HCI_STATUS_PARAMETER_OUT_OF_MANDATORY_RANGE =                            0x30,
    HCI_STATUS_ROLE_SWITCH_PENDING =                                         0x32,
    HCI_STATUS_RESERVED_SLOT_VIOLATION =                                     0x34,
    HCI_STATUS_ROLE_SWITCH_FAILED =                                          0x35,
    HCI_STATUS_EXTENDED_INQUIRY_RESPONSE_TOO_LARGE =                         0x36,
    HCI_STATUS_SIMPLE_PAIRING_NOT_SUPPORTED_BY_HOST =                        0x37,
    HCI_STATUS_HOST_BUSY_PAIRING =                                           0x38,
    HCI_STATUS_CONNECTION_REJECTED_NO_SUITABLE_CHANNEL_FOUND =               0x39,
    HCI_STATUS_CONTROLLER_BUSY =                                             0x3a,
    HCI_STATUS_UNACCEPTABLE_CONNECTION_INTERVAL =                            0x3b,
    HCI_STATUS_DIRECTED_ADVERTISING_TIMEOUT =                                0x3c,
    HCI_STATUS_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE =                    0x3d,
    HCI_STATUS_CONNECTION_FAILED_TO_BE_ESTABLISHED =                         0x3e,
    HCI_STATUS_MAC_CONNECTION_FAILED =                                       0x3f,
    HCI_STATUS_SAM_SLOT_MAP_NOT_COMPATIBLE =                                 0x40,
    HCI_STATUS_BROADCAST_ENCRYPTION_NOT_ALLOWED =                            0x41,
    HCI_STATUS_LT_ADDR_ALREADY_IN_USE =                                      0x42,
    HCI_STATUS_LT_ADDR_NOT_ALLOCATED =                                       0x43,
    HCI_STATUS_CONNECTIONLESS_BROADCAST_NOT_ENABLED =                        0x44,
    HCI_STATUS_CONNECTIONLESS_BROADCAST_DATA_LENGTH_EXCEEDS_MAXIMUM_ALLOWED_PACKET_SIZE = 0x45
} tHCI_Status;

/*---------------------------------------------------------------------------------*/
/*                        [002][Connection_Handle][Val][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Disconnect                                    (0x0406) */
/* Request                  Add_SCO_Connection                            (0x0407) */
/* Request                  Change_Connection_Packet_Type                 (0x040f) */
/* Request                  Authentication_Requested                      (0x0411) */
/* Request                  Set_Connection_Encryption                     (0x0413) */
/* Request                  Change_Connection_Link_Key                    (0x0415) */
/* Request                  Read_Remote_Supported_Features                (0x041b) */
/* Request                  Read_Remote_Extended_Features                 (0x041c) */
/* Request                  Read_Remote_Version_Information               (0x041d) */
/* Request                  Read_Clock_Offset                             (0x041f) */
/* Request,Return           Read_LMP_Handle                               (0x0420) */
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Hold_Mode                                     (0x0801) */
/* Request                  Sniff_Mode                                    (0x0803) */
/* Request                  Exit_Sniff_Mode                               (0x0804) */
/* Request                  Park_State                                    (0x0805) */
/* Request                  Exit_Park_State                               (0x0806) */
/* Request                  QoS_Setup                                     (0x0807) */
/* Request,Return           Role_Discovery                                (0x0809) */
/* Request,Return           Read_Link_Policy_Settings                     (0x080c) */
/* Request,Return           Write_Link_Policy_Settings                    (0x080d) */
/* Request                  Flow_Specification                            (0x0810) */
/* Request,Return           Sniff_Subrating                               (0x0811) */
/* Request,Return           Flush                                         (0x0c08) */
/* Request,Return           Read_Automatic_Flush_Timeout                  (0x0c27) */
/* Request,Return           Write_Automatic_Flush_Timeout                 (0x0c28) */
/* Request,Return           Read_Transmit_Power_Level                     (0x0c2d) */
/* Request                  Host_Number_Of_Completed_Packets              (0x0c35) */
/* Request,Return           Read_Link_Supervision_Timeout                 (0x0c36) */
/* Request,Return           Write_Link_Supervision_Timeout                (0x0c37) */
/* Request                  Refresh_Encryption_Key                        (0x0c53) */
/* Request,Return           Read_Enhanced_Transmit_Power_Level            (0x0c68) */
/* Request,Return           Read_AFH_Channel_Map                          (0x1406) */
/* Request,Return           Read_Clock                                    (0x1407) */
/* Request,Return           Read_Encryption_Key_Size                      (0x1408) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* Request,Return           LE_Read_Channel_Map                           (0x2015) */
/* Request                  LE_Read_Remote_Used_Features                  (0x2016) */
/* Request                  LE_Start_Encryption                           (0x2019) */
/* Request,Return           LE_Long_Term_Key_Request_Reply                (0x201a) */
/* Request,Return           LE_Long_Term_Key_Request_Negative_Reply       (0x201b) */
/* Event                    Connection_Complete                           (0x0003) */
/* Event                    Disconnection_Complete                        (0x0005) */
/* Event                    Authentication_Complete                       (0x0006) */
/* Event                    Encryption_Change                             (0x0008) */
/* Event                    Change_Connection_Link_Key_Complete           (0x0009) */
/* Event                    Master_Link_Key_Complete                      (0x000a) */
/* Event                    Read_Remote_Supported_Features_Complete       (0x000b) */
/* Event                    Read_Remote_Version_Information_Complete      (0x000c) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Number_Of_Completed_Packets                   (0x0013) */
/* Event                    Mode_Change                                   (0x0014) */
/* Event                    Max_Slots_Change                              (0x001b) */
/* Event                    Read_Clock_Offset_Complete                    (0x001c) */
/* Event                    Connection_Packet_Type_Changed                (0x001d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Event                    Read_Remote_Extended_Features_Complete        (0x0023) */
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Synchronous_Connection_Changed                (0x002d) */
/* Event                    Sniff_Subrating                               (0x002e) */
/* Event                    Encryption_Key_Refresh_Complete               (0x0030) */
/* Event                    Link_Supervision_Timeout_Changed              (0x0038) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
/* LEEvent                  LE_Connection_Update_Complete                 (0x0003) */
/* LEEvent                  LE_Read_Remote_Used_Features_Complete         (0x0004) */
/* LEEvent                  LE_Long_Term_Key_Request                      (0x0005) */
/* Returned from creating a connection,0x0F00 - 0x0FFF Reserved for future use */
/* Range: 0x0 ~ 0xeff */

/*---------------------------------------------------------------------------------*/
/*                          [003][Inquiry_Len][Time][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  Inquiry                                       (0x0401) */
/* Request                  Periodic_Inquiry_Mode                         (0x0403) */
/* Maximum amount of time specified before the Inquiry is halted,Time = N * 1.28
   sec,Range: 1.28 - 61.44 Sec */
/* Range: 0x1 ~ 0x30 */
/* TimeRange[1.280000]: 1.280000 ~ 61.440000 */

/*---------------------------------------------------------------------------------*/
/*                         [004][Max_Period_Len][Time][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  Periodic_Inquiry_Mode                         (0x0403) */
/* Maximum amount of time specified between consecutive inquiries.Size: 2 octets
   Time = N * 1.28 sec Range: 3.84 C 83884.8 Sec 0.0 - 23.3 hours */
/* Range: 0x3 ~ 0xffff */
/* TimeRange[1.280000]: 3.840000 ~ 83884.800000 */

/*---------------------------------------------------------------------------------*/
/*                         [005][Min_Period_Len][Time][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  Periodic_Inquiry_Mode                         (0x0403) */
/* Minimum amount of time specified between consecutive inquiries.Size: 2 octets
   Time = N * 1.28 sec Range: 2.56 C 83883.52 Sec 0.0 - 23.3 hours */
/* Range: 0x2 ~ 0xfffe */
/* TimeRange[1.280000]: 2.560000 ~ 83883.520000 */

/*---------------------------------------------------------------------------------*/
/*                          [006][Num_Responses][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  Inquiry                                       (0x0401) */
/* Request                  Periodic_Inquiry_Mode                         (0x0403) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* 0x00 Unlimited number of responses,0x01-0xFF Maximum number of responses from
   the Inquiry before the Inquiry is halted */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                      [007][Packet_Boundary_Flag][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/*  */
typedef enum _tHCI_Packet_Boundary_Flag
{
    HCI_PACKET_BOUNDARY_FLAG_FIRST_NON_AUTOMATICALLY_FLUSHABLE_PACKET =      0x00,
    HCI_PACKET_BOUNDARY_FLAG_CONTINUING_FRAGMENT =                           0x01,
    HCI_PACKET_BOUNDARY_FLAG_FIRST_AUTOMATICALLY_FLUSHABLE_PACKET =          0x02,
    HCI_PACKET_BOUNDARY_FLAG_A_COMPLETE_L2CAP_PDU_AUTOMATICALLY_FLUSHABLE =  0x03
} tHCI_Packet_Boundary_Flag;

/*---------------------------------------------------------------------------------*/
/*                       [008][Packet_Status_Flag][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/*  */
typedef enum _tHCI_Packet_Status_Flag
{
    HCI_PACKET_STATUS_FLAG_CORRECTLY_RECEIVED_DATA =                         0x00,
    HCI_PACKET_STATUS_FLAG_POSSIBLY_INVALID_DATA =                           0x01,
    HCI_PACKET_STATUS_FLAG_NO_DATA_RECEIVED =                                0x02,
    HCI_PACKET_STATUS_FLAG_DATA_PARTIALLY_LOST =                             0x03
} tHCI_Packet_Status_Flag;

/*---------------------------------------------------------------------------------*/
/*                         [009][Broadcast_Flag][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* in packet from Host to Controller */
typedef enum _tHCI_Broadcast_Flag
{
    HCI_BROADCAST_FLAG_NO_BROADCAST =                                        0x00,
    HCI_BROADCAST_FLAG_ACTIVE_SLAVE_BROADCAST =                              0x01,
    HCI_BROADCAST_FLAG_PARKED_SLAVE_BROADCAST =                              0x02
} tHCI_Broadcast_Flag;

/*---------------------------------------------------------------------------------*/
/*                          [010][Packet_Type][Mask][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  Create_Connection                             (0x0405) */
/* Request                  Add_SCO_Connection                            (0x0407) */
/* Request                  Change_Connection_Packet_Type                 (0x040f) */
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* Event                    Connection_Packet_Type_Changed                (0x001d) */
/* ACL Packet Type */
typedef enum _tHCI_Packet_Type
{
    HCI_PACKET_TYPE_2DH1_MAY_NOT =                                           0x0002,
    HCI_PACKET_TYPE_3DH1_MAY_NOT =                                           0x0004,
    HCI_PACKET_TYPE_DM1_MAY =                                                0x0008,
    HCI_PACKET_TYPE_DH1_MAY =                                                0x0010,
    HCI_PACKET_TYPE_2DH3_MAY_NOT =                                           0x0100,
    HCI_PACKET_TYPE_3DH3_MAY_NOT =                                           0x0200,
    HCI_PACKET_TYPE_DM3_MAY =                                                0x0400,
    HCI_PACKET_TYPE_DH3_MAY =                                                0x0800,
    HCI_PACKET_TYPE_2DH5_MAY_NOT =                                           0x1000,
    HCI_PACKET_TYPE_3DH5_MAY_NOT =                                           0x2000,
    HCI_PACKET_TYPE_DM5_MAY =                                                0x4000,
    HCI_PACKET_TYPE_DH5_MAY =                                                0x8000,
    HCI_PACKET_TYPE_DEFAULT_ACL =                                            0xCC18,
    /* SCO Packet Type */
    HCI_PACKET_TYPE_HV1 =                                                    0x0020,
    HCI_PACKET_TYPE_HV2 =                                                    0x0040,
    HCI_PACKET_TYPE_HV3 =                                                    0x0080,
    HCI_PACKET_TYPE_DEFAULT_SCO =                                            0x00E0,
    /* Synchronous Packet Type */
    HCI_PACKET_TYPE_HV1_MAY =                                                0x0001,
    HCI_PACKET_TYPE_HV2_MAY =                                                0x0002,
    HCI_PACKET_TYPE_HV3_MAY =                                                0x0004,
    HCI_PACKET_TYPE_EV3_MAY =                                                0x0008,
    HCI_PACKET_TYPE_EV4_MAY =                                                0x0010,
    HCI_PACKET_TYPE_EV5_MAY =                                                0x0020,
    HCI_PACKET_TYPE_2EV3_MAY_NOT =                                           0x0040,
    HCI_PACKET_TYPE_3EV3_MAY_NOT =                                           0x0080,
    HCI_PACKET_TYPE_2EV5_MAY_NOT =                                           0x0100,
    HCI_PACKET_TYPE_3EV5_MAY_NOT =                                           0x0200,
    HCI_PACKET_TYPE_DEFAULT_SYNCHRONOUS =                                    0x003F,
    HCI_PACKET_TYPE_DEFAULT2_SYNCHRONOUS =                                   0x038F
} tHCI_Packet_Type;

/*---------------------------------------------------------------------------------*/
/*                          [011][PIN_Code_Len][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  PIN_Code_Request_Reply                        (0x040d) */
/* The PIN code length specifics the length, in octets, of the PIN code to be used */
/* Range: 0x1 ~ 0x10 */

/*---------------------------------------------------------------------------------*/
/*                            [012][PIN_Code][Val][L:16]                           */
/*---------------------------------------------------------------------------------*/
/* Request                  PIN_Code_Request_Reply                        (0x040d) */
/* PIN code for the device that is to be connected. The Host should ensure that
   strong PIN Codes are used. PIN Codes can be up to a maximum of 128 bits. Note:
   The PIN_Code Parameter is a string parameter. Endianess does therefore not
   apply to the PIN_Code Parameter. The first octet of the PIN code should be
   transmitted first */

/*---------------------------------------------------------------------------------*/
/*                          [013][Country_Code][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Country_Code                             (0x1007) */
typedef enum _tHCI_Country_Code
{
    HCI_COUNTRY_CODE_NORTH_AMERICA_EUROPE_AND_JAPAN =                        0x00,
    HCI_COUNTRY_CODE_FRANCE =                                                0x01
} tHCI_Country_Code;

/*---------------------------------------------------------------------------------*/
/*                         [014][Page_Scan_Mode][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Page_Scan_Mode                           (0x0c3d) */
/* Request                  Write_Page_Scan_Mode                          (0x0c3e) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Page_Scan_Mode_Change                         (0x001f) */
typedef enum _tHCI_Page_Scan_Mode
{
    HCI_PAGE_SCAN_MODE_MANDATORY_PAGE_SCAN_MODE =                            0x00,
    HCI_PAGE_SCAN_MODE_OPTIONAL_PAGE_SCAN_MODE_I =                           0x01,
    HCI_PAGE_SCAN_MODE_OPTIONAL_PAGE_SCAN_MODE_II =                          0x02,
    HCI_PAGE_SCAN_MODE_OPTIONAL_PAGE_SCAN_MODE_III =                         0x03
} tHCI_Page_Scan_Mode;

/*---------------------------------------------------------------------------------*/
/*                     [015][Page_Scan_Period_Mode][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Page_Scan_Period_Mode                    (0x0c3b) */
/* Request                  Write_Page_Scan_Period_Mode                   (0x0c3c) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Every time an inquiry response message is sent,the BR/EDR Controller will start
   a timer (T_mandatory_pscan), the value of which is dependent on the
   Page_Scan_Period_Mode. As long as this timer has not expired, the  BR/EDR
   Controller will use the mandatory page scan mode for all following page scans.
   Note: The timer T_mandatory_pscan will be reset at each new inquiry response */
typedef enum _tHCI_Page_Scan_Period_Mode
{
    HCI_PAGE_SCAN_PERIOD_MODE_P0 =                                           0x00,
    HCI_PAGE_SCAN_PERIOD_MODE_P1 =                                           0x01,
    HCI_PAGE_SCAN_PERIOD_MODE_P2 =                                           0x02
} tHCI_Page_Scan_Period_Mode;

/*---------------------------------------------------------------------------------*/
/*                   [016][Page_Scan_Repetition_Mode][Enum][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Request                  Create_Connection                             (0x0405) */
/* Request                  Remote_Name_Request                           (0x0419) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Page_Scan_Repetition_Mode_Change              (0x0020) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
typedef enum _tHCI_Page_Scan_Repetition_Mode
{
    HCI_PAGE_SCAN_REPETITION_MODE_R0 =                                       0x00,
    HCI_PAGE_SCAN_REPETITION_MODE_R1 =                                       0x01,
    HCI_PAGE_SCAN_REPETITION_MODE_R2 =                                       0x02
} tHCI_Page_Scan_Repetition_Mode;

/*---------------------------------------------------------------------------------*/
/*                            [017][Reserved][Fix][L:1]                            */
/*---------------------------------------------------------------------------------*/
/* Request                  Create_Connection                             (0x0405) */
/* Request                  Remote_Name_Request                           (0x0419) */
/* Return                   Read_LMP_Handle                               (0x0420) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* Reserved, must be set to 0x00 */

/*---------------------------------------------------------------------------------*/
/*                           [018][LMP_Handle][Val][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_LMP_Handle                               (0x0420) */
/* The LMP Handle is the LMP Handle that is associated with this Connection_Handle.
  For a synchronous handle, this would be the LMP Synchronous Handle used when
   negotiating the synchronous connection in the link manager */

/*---------------------------------------------------------------------------------*/
/*                          [019][Clock_Offset][Mask][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  Create_Connection                             (0x0405) */
/* Request                  Remote_Name_Request                           (0x0419) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Read_Clock_Offset_Complete                    (0x001c) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* Bit 14-0 Bit 16-2 of CLKslave-CLKmaster,Bit 15 Clock_Offset_Valid_Flag */
typedef enum _tHCI_Clock_Offset
{
    HCI_CLOCK_OFFSET_INVALID =                                               0x0000,
    HCI_CLOCK_OFFSET_VALID =                                                 0x8000
} tHCI_Clock_Offset;

/*---------------------------------------------------------------------------------*/
/*                       [020][Allow_Role_Switch][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Create_Connection                             (0x0405) */
typedef enum _tHCI_Allow_Role_Switch
{
    HCI_ALLOW_ROLE_SWITCH_REJECT =                                           0x00,
    HCI_ALLOW_ROLE_SWITCH_ACCEPT =                                           0x01
} tHCI_Allow_Role_Switch;

/*---------------------------------------------------------------------------------*/
/*                         [021][Report_Reason][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Report_Reason
{
    HCI_REPORT_REASON_CONFIGURED_INTERVAL_REPORT =                           0x00
} tHCI_Report_Reason;

/*---------------------------------------------------------------------------------*/
/*                              [022][Role][Enum][L:1]                             */
/*---------------------------------------------------------------------------------*/
/* Request                  Accept_Connection_Request                     (0x0409) */
/* Return                   Role_Discovery                                (0x0809) */
/* Request                  Switch_Role                                   (0x080b) */
/* Event                    Role_Change                                   (0x0012) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
typedef enum _tHCI_Role
{
    HCI_ROLE_MASTER =                                                        0x00,
    HCI_ROLE_SLAVE =                                                         0x01
} tHCI_Role;

/*---------------------------------------------------------------------------------*/
/*                       [023][Encryption_Enable][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Set_Connection_Encryption                     (0x0413) */
/* Event                    Connection_Complete                           (0x0003) */
/* Event                    Encryption_Change                             (0x0008) */
typedef enum _tHCI_Encryption_Enable
{
    HCI_ENCRYPTION_ENABLE_OFF =                                              0x00,
    HCI_ENCRYPTION_ENABLE_ON =                                               0x01,
    HCI_ENCRYPTION_ENABLE_ON_AESCCM =                                        0x02
} tHCI_Encryption_Enable;

/*---------------------------------------------------------------------------------*/
/*                        [024][Encryption_Mode][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Encryption_Mode                          (0x0c21) */
/* Request                  Write_Encryption_Mode                         (0x0c22) */
typedef enum _tHCI_Encryption_Mode
{
    HCI_ENCRYPTION_MODE_NOT_REQUIRED =                                       0x00,
    HCI_ENCRYPTION_MODE_REQUIRED_FOR_ALL_CONNECTIONS =                       0x01
} tHCI_Encryption_Mode;

/*---------------------------------------------------------------------------------*/
/*                            [025][Key_Flag][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Request                  Master_Link_Key                               (0x0417) */
/* Event                    Master_Link_Key_Complete                      (0x000a) */
typedef enum _tHCI_Key_Flag
{
    HCI_KEY_FLAG_SEMI_PERMANENT =                                            0x00,
    HCI_KEY_FLAG_TEMPORARY =                                                 0x01
} tHCI_Key_Flag;

/*---------------------------------------------------------------------------------*/
/*                       [026][Transmit_Bandwidth][Val][L:4]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* Transmit bandwidth in octets per second, 0x00000000 - 0xFFFFFFFE Transmit
   bandwidth in octets per second. 0xFFFFFFFF Don`t care */

/*---------------------------------------------------------------------------------*/
/*                        [027][Receive_Bandwidth][Val][L:4]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* Receive bandwidth in octets per second, 0x00000000 - 0xFFFFFFFE Receive
   bandwidth in octets per second. 0xFFFFFFFF Don`t care */

/*---------------------------------------------------------------------------------*/
/*                     [028][Transmit_Coding_Format][Val][L:5]                     */
/*---------------------------------------------------------------------------------*/
/* Octet 0 See Assigned Numbers for Coding_Format, Octet 1-2: Company ID, see
   Assigned Numbers for Company dentifier. Octet 3-4: Vendor specific codec ID.
   Shall be ignored if octet 0 of Transmit_Coding_Format is not 0xFF. */

/*---------------------------------------------------------------------------------*/
/*                      [029][Receive_Coding_Format][Val][L:5]                     */
/*---------------------------------------------------------------------------------*/
/* Octet 0 See Assigned Numbers for Coding_Format, Octet 1-2: Company ID, see
   Assigned Numbers for Company dentifier. Octet 3-4: Vendor specific codec ID.
   Shall be ignored if octet 0 of Transmit_Coding_Format is not 0xFF. */

/*---------------------------------------------------------------------------------*/
/*                    [030][Transmit_Codec_Frame_Size][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* 0xXXXX Range: 0x0001-0xFFFF, the actual size of the over-the-air encoded frame
   in octets. 0x0000 Reserved */

/*---------------------------------------------------------------------------------*/
/*                    [031][Receive_Codec_Frame_Size][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* 0xXXXX Range: 0x0001-0xFFFF, the actual size of the over-the-air encoded frame
   in octets. 0x0000 Reserved */

/*---------------------------------------------------------------------------------*/
/*                         [032][Input_Bandwidth][Val][L:4]                        */
/*---------------------------------------------------------------------------------*/
/* 0xXXXXXXXX Host to Controller nominal data rate in octets per second. */

/*---------------------------------------------------------------------------------*/
/*                        [033][Output_Bandwidth][Val][L:4]                        */
/*---------------------------------------------------------------------------------*/
/* 0xXXXXXXXX Host to Controller nominal data rate in octets per second. */

/*---------------------------------------------------------------------------------*/
/*                       [034][Input_Coding_Format][Val][L:5]                      */
/*---------------------------------------------------------------------------------*/
/* Octet 0 See Assigned Numbers for Coding_Format, Octet 1-2: Company ID, see
   Assigned Numbers for Company dentifier. Octet 3-4: Vendor specific codec ID.
   Shall be ignored if octet 0 of Transmit_Coding_Format is not 0xFF. */

/*---------------------------------------------------------------------------------*/
/*                      [035][Output_Coding_Format][Val][L:5]                      */
/*---------------------------------------------------------------------------------*/
/* Octet 0 See Assigned Numbers for Coding_Format, Octet 1-2: Company ID, see
   Assigned Numbers for Company dentifier. Octet 3-4: Vendor specific codec ID.
   Shall be ignored if octet 0 of Transmit_Coding_Format is not 0xFF. */

/*---------------------------------------------------------------------------------*/
/*                      [036][Input_Coded_Data_Size][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* 0xXXXX Size, in bits, of the sample or framed data */

/*---------------------------------------------------------------------------------*/
/*                     [037][Output_Coded_Data_Size][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* 0xXXXX Size, in bits, of the sample or framed data */

/*---------------------------------------------------------------------------------*/
/*                      [038][Input_PCM_Data_Format][Val][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* 0xXX See Assigned Numbers for PCM_Data_Format */

/*---------------------------------------------------------------------------------*/
/*                     [039][Output_PCM_Data_Format][Val][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* 0xXX See Assigned Numbers for PCM_Data_Format */

/*---------------------------------------------------------------------------------*/
/*              [040][Input_PCM_Sample_Payload_MSB_Position][Val][L:1]             */
/*---------------------------------------------------------------------------------*/
/* 0xXX The number of bit positions within an audio sample that the MSB of the
   sample is away from star ting at the MSB of the data. */

/*---------------------------------------------------------------------------------*/
/*             [041][Output_PCM_Sample_Payload_MSB_Position][Val][L:1]             */
/*---------------------------------------------------------------------------------*/
/* 0xXX The number of bit positions within an audio sample that the MSB of the
   sample is away from star ting at the MSB of the data. */

/*---------------------------------------------------------------------------------*/
/*                        [042][Input_Data_Path][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* 0x01-0xFE Logical_Channel_Number. The meaning of the logical channels will be
   vendor specific.  */
typedef enum _tHCI_Input_Data_Path
{
    HCI_INPUT_DATA_PATH_HCI =                                                0x00,
    HCI_INPUT_DATA_PATH_AUDIO_TEST_MODE =                                    0xFF
} tHCI_Input_Data_Path;

/*---------------------------------------------------------------------------------*/
/*                        [043][Output_Data_Path][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* 0x01-0xFE Logical_Channel_Number. The meaning of the logical channels will be
   vendor specific.  */
typedef enum _tHCI_Output_Data_Path
{
    HCI_OUTPUT_DATA_PATH_HCI =                                               0x00,
    HCI_OUTPUT_DATA_PATH_AUDIO_TEST_MODE =                                   0xFF
} tHCI_Output_Data_Path;

/*---------------------------------------------------------------------------------*/
/*                    [044][Input_Transport_Unit_Size][Val][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* 1 to 255 The number of bits in each unit of data received from the Host over the
   audio data transport.0 Not applicable (implied by the choice of audio data
   transport) */

/*---------------------------------------------------------------------------------*/
/*                   [045][Output_Transport_Unit_Size][Val][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* 1 to 255 The number of bits in each unit of data received from the Host over the
   audio data transport.0 Not applicable (implied by the choice of audio data
   transport) */

/*---------------------------------------------------------------------------------*/
/*                       [046][MWS_Channel_Enable][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* 0x02 - 0xFF Reserved. is used to enabl e or disable the MWS channel */
typedef enum _tHCI_MWS_Channel_Enable
{
    HCI_MWS_CHANNEL_ENABLE_DISABLED =                                        0x00,
    HCI_MWS_CHANNEL_ENABLE_ENABLED =                                         0x01
} tHCI_MWS_Channel_Enable;

/*---------------------------------------------------------------------------------*/
/*                     [047][MWS_RX_Center_Frequency][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* MWS RX center frequency in MHz */

/*---------------------------------------------------------------------------------*/
/*                     [048][MWS_TX_Center_Frequency][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* MWS TX center frequency in MHz */

/*---------------------------------------------------------------------------------*/
/*                    [049][MWS_RX_Channel_Bandwidth][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* MWS RX channel bandwidth in kHz. */

/*---------------------------------------------------------------------------------*/
/*                    [050][MWS_TX_Channel_Bandwidth][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* MWS TX channel bandwidth in kHz. */

/*---------------------------------------------------------------------------------*/
/*                        [051][MWS_Channel_Type][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* See Bluetooth Assigned numbers. */

/*---------------------------------------------------------------------------------*/
/*                       [052][Ext_Frame_Duration][Val][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* External frame duration in microseconds, unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                  [053][Ext_Frame_Sync_Assert_Offset][Val][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* External frame offset in microseconds, signed integer */

/*---------------------------------------------------------------------------------*/
/*                  [054][Ext_Frame_Sync_Assert_Jitter][Val][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* External frame sync jitter in microseconds, unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                         [055][Ext_Num_Periods][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Number of specified periods in an external frame.Valid range: 1 to 32, unsigned
   integer */

/*---------------------------------------------------------------------------------*/
/*                         [056][Period_Duration][Val][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Duration of the [i] period in microseconds, unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                          [057][Period_Type][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* 0x04-0xFF Reserved */
typedef enum _tHCI_Period_Type
{
    HCI_PERIOD_TYPE_DOWNLINK =                                               0x00,
    HCI_PERIOD_TYPE_UPLINK =                                                 0x01,
    HCI_PERIOD_TYPE_BIDIRECTIONAL =                                          0x02,
    HCI_PERIOD_TYPE_GUARD_PERIOD =                                           0x03
} tHCI_Period_Type;

/*---------------------------------------------------------------------------------*/
/*                      [058][MWS_RX_Assert_Offset][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* MWS_RX signal assert offset in microseconds, signed integer. */

/*---------------------------------------------------------------------------------*/
/*                      [059][MWS_RX_Assert_Jitter][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* MWS_RX signal assert jitter in microseconds, unsigned integer. */

/*---------------------------------------------------------------------------------*/
/*                     [060][MWS_RX_Deassert_Offset][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* MWS_RX signal deassert offset in microseconds signed integer. */

/*---------------------------------------------------------------------------------*/
/*                     [061][MWS_RX_Deassert_Jitter][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* MWS_RX signal deassert jitter in microseconds unsigned integer. */

/*---------------------------------------------------------------------------------*/
/*                      [062][MWS_TX_Assert_Offset][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* MWS_TX signal assert offset in microseconds signed integer. */

/*---------------------------------------------------------------------------------*/
/*                      [063][MWS_TX_Assert_Jitter][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* MWS_TX signal assert jitter in microseconds unsigned integer. */

/*---------------------------------------------------------------------------------*/
/*                     [064][MWS_TX_Deassert_Offset][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* MWS_TX signal deassert offset in microseconds signed integer. */

/*---------------------------------------------------------------------------------*/
/*                     [065][MWS_TX_Deassert_Jitter][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* MWS_TX signal deassert jitter in microseconds unsigned integer. */

/*---------------------------------------------------------------------------------*/
/*                    [066][MWS_Pattern_Assert_Offset][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* MWS_PATTERN signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                    [067][MWS_Pattern_Assert_Jitter][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* MWS_PATTERN signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*              [068][MWS_Inactivity_Duration_Assert_Offset][Val][L:2]             */
/*---------------------------------------------------------------------------------*/
/* MWS_INACTIVITY_DURATION signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*              [069][MWS_Inactivity_Duration_Assert_Jitter][Val][L:2]             */
/*---------------------------------------------------------------------------------*/
/* MWS_INACTIVITY_DURATION signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                [070][MWS_Scan_Frequency_Assert_Offset][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* MWS_SCAN_FREQUENCY signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                [071][MWS_Scan_Frequency_Assert_Jitter][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* MWS_SCAN_FREQUENCY signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*               [072][MWS_Priority_Assert_Offset_Request][Val][L:2]               */
/*---------------------------------------------------------------------------------*/
/* Minimum advance notification from the beginning of an MWS Uplink period in
   microseconds (unsigned integer) before which the BLUETOOTH_RX_PRI or 802_RX_PRI
   signal shall be asserted to be recognized by the MWS */

/*---------------------------------------------------------------------------------*/
/*               [073][Bluetooth_RX_Priority_Assert_Offset][Val][L:2]              */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_RX_PRI signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*               [074][Bluetooth_RX_Priority_Assert_Jitter][Val][L:2]              */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_RX_PRI signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*              [075][Bluetooth_RX_Priority_Deassert_Offset][Val][L:2]             */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_RX_PRI signal deassert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*              [076][Bluetooth_RX_Priority_Deassert_Jitter][Val][L:2]             */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_RX_PRI signal deassert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                 [077][_802_RX_Priority_Assert_Offset][Val][L:2]                 */
/*---------------------------------------------------------------------------------*/
/* 802_RX_PRI signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                 [078][_802_RX_Priority_Assert_Jitter][Val][L:2]                 */
/*---------------------------------------------------------------------------------*/
/* 802_RX_PRI signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                [079][_802_RX_Priority_Deassert_Offset][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* 802_RX_PRI signal deassert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                [080][_802_RX_Priority_Deassert_Jitter][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* 802_RX_PRI signal deassert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                  [081][Bluetooth_TX_On_Assert_Offset][Val][L:2]                 */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_TX_ON signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                  [082][Bluetooth_TX_On_Assert_Jitter][Val][L:2]                 */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_TX_ON signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                 [083][Bluetooth_TX_On_Deassert_Offset][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_TX_ON signal deassert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                 [084][Bluetooth_TX_On_Deassert_Jitter][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* Bluetooth_TX_ON signal deassert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                    [085][_802_TX_On_Assert_Offset][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* 802_TX_ON signal assert offset in microseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                    [086][_802_TX_On_Assert_Jitter][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* 802_TX_ON signal assert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                   [087][_802_TX_On_Deassert_Offset][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* 802_TX_ON signal deassert offset in micr oseconds signed integer */

/*---------------------------------------------------------------------------------*/
/*                   [088][_802_TX_On_Deassert_Jitter][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* 802_TX_ON signal deassert jitter in microseconds unsigned integer */

/*---------------------------------------------------------------------------------*/
/*                         [089][Transport_Layer][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* See Assigned Numbers. */

/*---------------------------------------------------------------------------------*/
/*                        [090][To_MWS_Baud_Rate][Val][L:4]                        */
/*---------------------------------------------------------------------------------*/
/* List of supported Baud rates in the Bluetooth Controller to MWS Device direction
   in Baud. Each element of the list shall have the format 0xXXXXXXXX. The list
   shall start with the first baud rate for the first transport, followed by the
   remaining baud rates for the first transport, followed by the baud rates for
   the second transport (if any), followed by baud rates for subsequent transports
   (if any) */

/*---------------------------------------------------------------------------------*/
/*                       [091][From_MWS_Baud_Rate][Val][L:4]                       */
/*---------------------------------------------------------------------------------*/
/* List of supported Baud rates in the Bluetooth Controller for signals in the MWS
   to Bluetooth Controller Device direction in Baud. Each element of the list
   shall have the format 0xXXXXXXXX. The list shall start with the first baud rate
   for the first transport, followed by the remaining baud rates for the first
   transport, followed by the baud rates for the second transport (if any),
   followed by baud rates for subsequent transports (if any).  */

/*---------------------------------------------------------------------------------*/
/*                      [092][Num_Scan_Frequencies][Val][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Number of MWS scan frequencies to be set in the table. */

/*---------------------------------------------------------------------------------*/
/*                       [093][Scan_Frequency_Low][Val][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Lower edge of the MWS scan frequency in MHz, unsigned integer. */

/*---------------------------------------------------------------------------------*/
/*                       [094][Scan_Frequency_High][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Upper edge of the MWS scan frequencyin MHz, unsigned integer. */

/*---------------------------------------------------------------------------------*/
/*                        [095][MWS_PATTERN_Index][Val][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Index of the MWS_PATTERN instance to be configured. Range is 0-2. */

/*---------------------------------------------------------------------------------*/
/*                    [096][MWS_PATTERN_NumIntervals][Val][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* The number of intervals in the following array. */

/*---------------------------------------------------------------------------------*/
/*                  [097][MWS_PATTERN_IntervalDuration][Val][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* An array specifying the duration of Bluetooth activity intervals in microseconds */

/*---------------------------------------------------------------------------------*/
/*                    [098][MWS_PATTERN_IntervalType][Enum][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* An array specifying the types of permitted Bluetooth activities in each interval */
typedef enum _tHCI_MWS_PATTERN_IntervalType
{
    HCI_MWS_PATTERN_INTERVALTYPE_NEITHER_TRANSMISSION_NOR_RECEPTION_IS_ALLOWED = 0x00,
    HCI_MWS_PATTERN_INTERVALTYPE_TRANSMISSION_IS_ALLOWED =                   0x01,
    HCI_MWS_PATTERN_INTERVALTYPE_RECEPTION_IS_ALLOWED =                      0x02,
    HCI_MWS_PATTERN_INTERVALTYPE_BOTH_TRANSMISSION_AND_RECEPTION_ARE_ALLOWED = 0x03
} tHCI_MWS_PATTERN_IntervalType;

/*---------------------------------------------------------------------------------*/
/*                         [099][Num_Transports][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Number of supported MWS coexistence transport layers. */

/*---------------------------------------------------------------------------------*/
/*                         [100][Num_Baud_Rates][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Number of different baud rates supported for one transport. */

/*---------------------------------------------------------------------------------*/
/*                 [101][Triggered_Clock_Capture_Enable][Enum][L:1]                */
/*---------------------------------------------------------------------------------*/
/* 0x02 - 0xFF Reserved. Disable triggered clock capturing on the specified
   Connection Handle (Default), or Enable it. */
typedef enum _tHCI_Triggered_Clock_Capture_Enable
{
    HCI_TRIGGERED_CLOCK_CAPTURE_ENABLE_DISABLED =                            0x00,
    HCI_TRIGGERED_CLOCK_CAPTURE_ENABLE_ENABLED =                             0x01
} tHCI_Triggered_Clock_Capture_Enable;

/*---------------------------------------------------------------------------------*/
/*                          [102][LPO_Allowed][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* clock accuracy better than  20 ppm when not sleep, otherwise,  250 ppm */
typedef enum _tHCI_LPO_Allowed
{
    HCI_LPO_ALLOWED_CONTROLLER_SHALL_NOT_SLEEP =                             0x00,
    HCI_LPO_ALLOWED_CONTROLLER_MAY_SLEEP =                                   0x01
} tHCI_LPO_Allowed;

/*---------------------------------------------------------------------------------*/
/*                  [103][Num_Clock_Captures_To_Filter][Enum][L:1]                 */
/*---------------------------------------------------------------------------------*/
/* 0x01-0xFF, Number of triggered clock captures filtered between sending a
   Triggered Clock Capture event to the Host. */
typedef enum _tHCI_Num_Clock_Captures_To_Filter
{
    HCI_NUM_CLOCK_CAPTURES_TO_FILTER_ALL =                                   0x00
} tHCI_Num_Clock_Captures_To_Filter;

/*---------------------------------------------------------------------------------*/
/*                      [104][Extended_Page_Timeout][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* The Extended_Page_Timeout configuration parameter together with Page_Timeout
   defines the maximum time the local Link Manager will wait for a baseband page
   response from the remote device at a locally initiated connection attempt. If
   this time expires and the remote device has not responded to the page at
   baseband level, the connection attempt will be considered to have failed.
   Default: 0x0000, Mandatory Range: 0x0000 to 0xFFFF Time = N * 0.625 msec, Time
   Range: 0 to 40.9 sec, Time Default: 0 sec */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                     [105][Extended_Inquiry_Length][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Extended_Inquiry_Length measured in Number of Baseband slots. Interval Length =
   N * 0.625 msec (1 Baseband slot) Range for N: 0x0000 - 0xFFFF, Time Range: 0 -
   40.9 Seconds */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                           [106][Max_Latency][Val][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* 0x0000-0x0003 Reserved,0xFFFF Don`t care,0x0004-0xFFFE This is a value in
   milliseconds representing the upper limit of the sum of the synchronous
   interval, and the size of the eSCO window, where the eSCO window is the
   reserved slots plus the retransmission window. (See Figure 8.7 in the Baseband
   specification) */
/* Range: 0x4 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                       [107][Max_Sniff_Latency][Time][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Subrating                               (0x0811) */
/* The Maximum Latency parameter shall be used to calculate the maximum_sniff
   subrate that the remote device may use,Default: Tsniff,Latency = N * 0.625 msec
   (1 Baseband slot),Range for N: 0x0002 - 0xFFFE,Time Range: 1.25msec - 40.9 sec */
/* Range: 0x2 ~ 0xfffe */
/* TimeRange[0.625000]: 1.250000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                     [108][Retransmission_Effort][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* 0x03-0xFE Reserved */
typedef enum _tHCI_Retransmission_Effort
{
    HCI_RETRANSMISSION_EFFORT_NO =                                           0x00,
    HCI_RETRANSMISSION_EFFORT_ONE_OPTIMIZE_FOR_POWER =                       0x01,
    HCI_RETRANSMISSION_EFFORT_ONE_OPTIMIZE_FOR_LINK_QUALITY =                0x02,
    HCI_RETRANSMISSION_EFFORT_DONOT_CARE =                                   0xFF
} tHCI_Retransmission_Effort;

/*---------------------------------------------------------------------------------*/
/*                         [109][Voice_Setting][Mask][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  Setup_Synchronous_Connection                  (0x0428) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* Return                   Read_Voice_Setting                            (0x0c25) */
/* Request                  Write_Voice_Setting                           (0x0c26) */
/* Input Coding */
typedef enum _tHCI_Voice_Setting
{
    HCI_VOICE_SETTING_INPUT_CODING_LINEAR =                                  0x0000,
    HCI_VOICE_SETTING_INPUT_CODING_ULAW =                                    0x0100,
    HCI_VOICE_SETTING_INPUT_CODING_ALAW =                                    0x0200,
    /* Input Data Format */
    HCI_VOICE_SETTING_INPUT_DATA_FORMAT_1S_COMPLEMENT =                      0x0000,
    HCI_VOICE_SETTING_INPUT_DATA_FORMAT_2S_COMPLEMENT =                      0x0040,
    HCI_VOICE_SETTING_INPUT_DATA_FORMAT_SIGNMAGNITUDE =                      0x0080,
    HCI_VOICE_SETTING_INPUT_DATA_FORMAT_UNSIGNED =                           0x00c0,
    /* Input Sample Size */
    HCI_VOICE_SETTING_INPUT_SAMPLE_SIZE_8_BIT =                              0x0000,
    HCI_VOICE_SETTING_INPUT_SAMPLE_SIZE_16_BIT =                             0x0020,
    /* Linear PCM Bit Position */
    /* Air Coding Format */
    HCI_VOICE_SETTING_AIR_CODING_FORMAT_CVSD =                               0x0000,
    HCI_VOICE_SETTING_AIR_CODING_FORMAT_ULAW =                               0x0001,
    HCI_VOICE_SETTING_AIR_CODING_FORMAT_ALAW =                               0x0002,
    HCI_VOICE_SETTING_AIR_CODING_FORMAT_TRANSPARENT_DATA =                   0x0003
} tHCI_Voice_Setting;

/*---------------------------------------------------------------------------------*/
/*                        [110][Class_of_Device][Mask][L:3]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Class_of_Device                          (0x0c23) */
/* Request                  Write_Class_of_Device                         (0x0c24) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Connection_Request                            (0x0004) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* The Class_of_Device parameter is used to indicate the capabilities of the local
   device to other devices. 11bits for service classes */
typedef enum _tHCI_Class_of_Device
{
    HCI_CLASS_OF_DEVICE_LIMITED_DISCOVERABLE_MODE =                          0x0001,
    HCI_CLASS_OF_DEVICE_POSITIONING =                                        0x0008,
    HCI_CLASS_OF_DEVICE_NETWORKING =                                         0x0010,
    HCI_CLASS_OF_DEVICE_RENDERING =                                          0x0020,
    HCI_CLASS_OF_DEVICE_CAPTURING =                                          0x0040,
    HCI_CLASS_OF_DEVICE_OBJECT_TRANSFER =                                    0x0080,
    HCI_CLASS_OF_DEVICE_AUDIO =                                              0x0100,
    HCI_CLASS_OF_DEVICE_TELEPHONY =                                          0x0200,
    HCI_CLASS_OF_DEVICE_INFORMATION =                                        0x0400,
    /* 5bits The Major Class segment is the highest level of granularity for defining a
       Bluetooth Device. The main function of a device is used to determine the major
       class grouping. There are 32 different possible major classes. The assignment
       of this Major Class field is defined in Table 1.3 */
    HCI_CLASS_OF_DEVICE_MISCELLANEOUS =                                      0x00,
    HCI_CLASS_OF_DEVICE_COMPUTER =                                           0x01,
    HCI_CLASS_OF_DEVICE_PHONE =                                              0x02,
    HCI_CLASS_OF_DEVICE_LAN_NETWORK =                                        0x03,
    HCI_CLASS_OF_DEVICE_AUDIO_VIDEO =                                        0x04,
    HCI_CLASS_OF_DEVICE_PERIPHERAL =                                         0x05,
    HCI_CLASS_OF_DEVICE_IMAGING =                                            0x06,
    HCI_CLASS_OF_DEVICE_WEARABLE =                                           0x07,
    HCI_CLASS_OF_DEVICE_TOY =                                                0x08,
    HCI_CLASS_OF_DEVICE_HEALTH =                                             0x09,
    HCI_CLASS_OF_DEVICE_UNCATEGORIZED_SPECIFIC_DEVICE_CODE_NOT_SPECIFIED =   0x1F,
    /* 6bits Minor Device Class field - Computer Major Class */
    HCI_CLASS_OF_DEVICE_COMPUTER_UNCATEGORIZED_CODE_FOR_DEVICE_NOT_ASSIGNED = 0x00,
    HCI_CLASS_OF_DEVICE_DESKTOP_WORKSTATION =                                0x01,
    HCI_CLASS_OF_DEVICE_SERVER_CLASS_COMPUTER =                              0x02,
    HCI_CLASS_OF_DEVICE_LAPTOP =                                             0x03,
    HCI_CLASS_OF_DEVICE_HANDHELD_PC_PDA_CLAM_SHELL =                         0x04,
    HCI_CLASS_OF_DEVICE_PALM_SIZED_PC_PDA =                                  0x05,
    HCI_CLASS_OF_DEVICE_WEARABLE_COMPUTER_WATCH_SIZED =                      0x06,
    /* 6bits Minor Device Class field - Phone Major Class */
    HCI_CLASS_OF_DEVICE_PHONE_UNCATEGORIZED_CODE_FOR_DEVICE_NOT_ASSIGNED =   0x00,
    HCI_CLASS_OF_DEVICE_CELLULAR =                                           0x01,
    HCI_CLASS_OF_DEVICE_CORDLESS =                                           0x02,
    HCI_CLASS_OF_DEVICE_SMART_PHONE =                                        0x03,
    HCI_CLASS_OF_DEVICE_WIRED_MODEM_OR_VOICE_GATEWAY =                       0x04,
    HCI_CLASS_OF_DEVICE_COMMON_ISDN_ACCESS =                                 0x05,
    /* 6bits Minor Device Class field - LAN/Network Access Point Major Class */
    HCI_CLASS_OF_DEVICE_FULLY_AVAILABLE =                                    0x00,
    HCI_CLASS_OF_DEVICE_1_17_UTILIZED =                                      0x01,
    HCI_CLASS_OF_DEVICE_17_33_UTILIZED =                                     0x02,
    HCI_CLASS_OF_DEVICE_33_50_UTILIZED =                                     0x03,
    HCI_CLASS_OF_DEVICE_50_67_UTILIZED =                                     0x04,
    HCI_CLASS_OF_DEVICE_67_83_UTILIZED =                                     0x05,
    HCI_CLASS_OF_DEVICE_83_99_UTILIZED =                                     0x06,
    HCI_CLASS_OF_DEVICE_NO_SERVICE_AVAILABLE =                               0x07,
    /* 6bits Minor Device Class field - Audio/Video Major Class */
    HCI_CLASS_OF_DEVICE_AV_UNCATEGORIZED_CODE_NOT_ASSIGNED =                 0x00,
    HCI_CLASS_OF_DEVICE_WEARABLE_HEADSET_DEVICE =                            0x01,
    HCI_CLASS_OF_DEVICE_HANDSFREE_DEVICE =                                   0x02,
    HCI_CLASS_OF_DEVICE_MICROPHONE =                                         0x04,
    HCI_CLASS_OF_DEVICE_LOUDSPEAKER =                                        0x05,
    HCI_CLASS_OF_DEVICE_HEADPHONES =                                         0x06,
    HCI_CLASS_OF_DEVICE_PORTABLE_AUDIO =                                     0x07,
    HCI_CLASS_OF_DEVICE_CAR_AUDIO =                                          0x08,
    HCI_CLASS_OF_DEVICE_SETTOP_BOX =                                         0x09,
    HCI_CLASS_OF_DEVICE_HIFI_AUDIO_DEVICE =                                  0x0a,
    HCI_CLASS_OF_DEVICE_VCR =                                                0x0b,
    HCI_CLASS_OF_DEVICE_VIDEO_CAMERA =                                       0x0c,
    HCI_CLASS_OF_DEVICE_CAMCORDER =                                          0x0d,
    HCI_CLASS_OF_DEVICE_VIDEO_MONITOR =                                      0x0e,
    HCI_CLASS_OF_DEVICE_VIDEO_DISPLAY_AND_LOUDSPEAKER =                      0x0f,
    HCI_CLASS_OF_DEVICE_VIDEO_CONFERENCING =                                 0x10,
    HCI_CLASS_OF_DEVICE_GAMING_TOY =                                         0x12,
    /* 6bits 7,6 part, 2bits, Minor Device Class field - Peripheral Major Class */
    HCI_CLASS_OF_DEVICE_NOT_KEYBOARD_NOT_POINTING_DEVICE =                   0x00,
    HCI_CLASS_OF_DEVICE_KEYBOARD =                                           0x01,
    HCI_CLASS_OF_DEVICE_POINTING_DEVICE =                                    0x02,
    HCI_CLASS_OF_DEVICE_COMBO_KEYBOARD_POINTING_DEVICE =                     0x03,
    /* 6bits 5,4,3,2 part, 4bits, Minor Device Class field - Peripheral Major Class */
    HCI_CLASS_OF_DEVICE_UNCATEGORIZED_DEVICE =                               0x00,
    HCI_CLASS_OF_DEVICE_JOYSTICK =                                           0x01,
    HCI_CLASS_OF_DEVICE_GAMEPAD =                                            0x02,
    HCI_CLASS_OF_DEVICE_REMOTE_CONTROL =                                     0x03,
    HCI_CLASS_OF_DEVICE_SENSING_DEVICE =                                     0x04,
    HCI_CLASS_OF_DEVICE_DIGITIZER_TABLET =                                   0x05,
    HCI_CLASS_OF_DEVICE_CARD_READER =                                        0x06,
    /* 6bits 7,6,5,4 part, 4bits, Minor Device Class field - Imaging Major Class */
    HCI_CLASS_OF_DEVICE_DISPLAY =                                            0x01,
    HCI_CLASS_OF_DEVICE_CAMERA =                                             0x02,
    HCI_CLASS_OF_DEVICE_SCANNER =                                            0x04,
    HCI_CLASS_OF_DEVICE_PRINTER =                                            0x08,
    /* 6bits Minor Device Class field - Wearable Major Class */
    HCI_CLASS_OF_DEVICE_WRIST_WATCH =                                        0x01,
    HCI_CLASS_OF_DEVICE_PAGER =                                              0x02,
    HCI_CLASS_OF_DEVICE_JACKET =                                             0x03,
    HCI_CLASS_OF_DEVICE_HELMET =                                             0x04,
    HCI_CLASS_OF_DEVICE_GLASSES =                                            0x05,
    /* 6bits Minor Device Class field - Toy Major Class */
    HCI_CLASS_OF_DEVICE_ROBOT =                                              0x01,
    HCI_CLASS_OF_DEVICE_VEHICLE =                                            0x02,
    HCI_CLASS_OF_DEVICE_DOLL_ACTION_FIGURE =                                 0x03,
    HCI_CLASS_OF_DEVICE_CONTROLLER =                                         0x04,
    HCI_CLASS_OF_DEVICE_GAME =                                               0x05,
    /* 6bits Minor Device Class field - Health Major Class */
    HCI_CLASS_OF_DEVICE_UNDEFINED =                                          0x00,
    HCI_CLASS_OF_DEVICE_BLOOD_PRESSURE_MONITOR =                             0x01,
    HCI_CLASS_OF_DEVICE_THERMOMETER =                                        0x02,
    HCI_CLASS_OF_DEVICE_WEIGHING_SCALE =                                     0x03,
    HCI_CLASS_OF_DEVICE_GLUCOSE_METER =                                      0x04,
    HCI_CLASS_OF_DEVICE_PULSE_OXIMETER =                                     0x05,
    HCI_CLASS_OF_DEVICE_HEART_PULSE_RATE_MONITOR =                           0x06,
    HCI_CLASS_OF_DEVICE_HEALTH_DATA_DISPLAY =                                0x07,
    HCI_CLASS_OF_DEVICE_STEP_COUNTER =                                       0x08
} tHCI_Class_of_Device;

/*---------------------------------------------------------------------------------*/
/*                      [111][Class_of_Device_Mask][Val][L:3]                      */
/*---------------------------------------------------------------------------------*/
/* Bit Mask used to determine which bits of the Class of Device parameter are dont
   care. Zero-value bits in the mask indicate the dont care bits of the Class of
   Device */

/*---------------------------------------------------------------------------------*/
/*                         [112][IO_Capability][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  IO_Capability_Request_Reply                   (0x042b) */
/* Event                    IO_Capability_Response                        (0x0032) */
typedef enum _tHCI_IO_Capability
{
    HCI_IO_CAPABILITY_DISPLAYONLY =                                          0x00,
    HCI_IO_CAPABILITY_DISPLAYYESNO =                                         0x01,
    HCI_IO_CAPABILITY_KEYBOARDONLY =                                         0x02,
    HCI_IO_CAPABILITY_NOINPUTNOOUTPUT =                                      0x03
} tHCI_IO_Capability;

/*---------------------------------------------------------------------------------*/
/*                        [113][OOB_Data_Present][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  IO_Capability_Request_Reply                   (0x042b) */
/* Event                    IO_Capability_Response                        (0x0032) */
typedef enum _tHCI_OOB_Data_Present
{
    HCI_OOB_DATA_PRESENT_NOT_PRESENT =                                       0x00,
    HCI_OOB_DATA_PRESENT_FROM_REMOTE_DEVICE_PRESENT =                        0x01
} tHCI_OOB_Data_Present;

/*---------------------------------------------------------------------------------*/
/*                  [114][Authentication_Requirements][Enum][L:1]                  */
/*---------------------------------------------------------------------------------*/
/* Request                  IO_Capability_Request_Reply                   (0x042b) */
/* Event                    IO_Capability_Response                        (0x0032) */
typedef enum _tHCI_Authentication_Requirements
{
    HCI_AUTHENTICATION_REQUIREMENTS_NOMITM_NO_BONDING_NUMERIC_COMPARE =      0x00,
    HCI_AUTHENTICATION_REQUIREMENTS_MITM_NO_BONDING_IO_CAPABILITIES =        0x01,
    HCI_AUTHENTICATION_REQUIREMENTS_NOMITM_DEDICATE_BONDING_NUMERIC_COMPARE = 0x02,
    HCI_AUTHENTICATION_REQUIREMENTS_MITM_DEDICATE_BONDING_IO_CAPABILITIES =  0x03,
    HCI_AUTHENTICATION_REQUIREMENTS_NOMITM_GENERAL_BONDING_NUMERIC_COMPARE = 0x04,
    HCI_AUTHENTICATION_REQUIREMENTS_MITM_GENERAL_BONDING_IO_CAPABILITIES =   0x05
} tHCI_Authentication_Requirements;

/*---------------------------------------------------------------------------------*/
/*                          [115][Service_Type][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  QoS_Setup                                     (0x0807) */
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
typedef enum _tHCI_Service_Type
{
    HCI_SERVICE_TYPE_NO_TRAFFIC =                                            0x00,
    HCI_SERVICE_TYPE_BEST_EFFORT =                                           0x01,
    HCI_SERVICE_TYPE_GUARANTEED =                                            0x02
} tHCI_Service_Type;

/*---------------------------------------------------------------------------------*/
/*                      [116][Link_Policy_Settings][Mask][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Link_Policy_Settings                     (0x080c) */
/* Request                  Write_Link_Policy_Settings                    (0x080d) */
/* Return                   Read_Default_Link_Policy_Settings             (0x080e) */
/* Request                  Write_Default_Link_Policy_Settings            (0x080f) */
/* The Link_Policy_Settings parameter determines the behavior of the local Link
   Manager when it receives a request from a remote Link Manager or it determines
   itself to change the master-slave role or to enter park state, hold, or sniff
   mode. The local Link Manager will automatically accept or reject such a request
   from the remote device, and may even autonomously request itself, depending on
   the value of the Link_Policy_Settings parameter for the corresponding
   Connection_Handle. When the value of the Link_Policy_Settings parameter is
   changed for a certain Connection_Handle, the new value will only be used for
   requests from a remote device or from the local Link Manager itself made after
   this command has been completed. */
typedef enum _tHCI_Link_Policy_Settings
{
    HCI_LINK_POLICY_SETTINGS_DISABLE_ALL_LM_MODES_DEFAULT =                  0x0000,
    HCI_LINK_POLICY_SETTINGS_ENABLE_ROLE_SWITCH =                            0x0001,
    HCI_LINK_POLICY_SETTINGS_ENABLE_HOLD_MODE =                              0x0002,
    HCI_LINK_POLICY_SETTINGS_ENABLE_SNIFF_MODE =                             0x0004,
    HCI_LINK_POLICY_SETTINGS_ENABLE_PARK_STATE =                             0x0008
} tHCI_Link_Policy_Settings;

/*---------------------------------------------------------------------------------*/
/*                         [117][Flow_direction][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
typedef enum _tHCI_Flow_direction
{
    HCI_FLOW_DIRECTION_OUTGOING_FLOW =                                       0x00,
    HCI_FLOW_DIRECTION_INCOMING_FLOW =                                       0x01
} tHCI_Flow_direction;

/*---------------------------------------------------------------------------------*/
/*                          [118][Filter_Type][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  Set_Event_Filter                              (0x0c05) */
typedef enum _tHCI_Filter_Type
{
    HCI_FILTER_TYPE_CLEAR_ALL_FILTERS =                                      0x00,
    HCI_FILTER_TYPE_INQUIRY_RESULT =                                         0x01,
    HCI_FILTER_TYPE_CONNECTION_SETUP =                                       0x02
} tHCI_Filter_Type;

/*---------------------------------------------------------------------------------*/
/*                     [119][Filter_Condition_Type][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Filter_Condition_Type
{
    HCI_FILTER_CONDITION_TYPE_ALL_DEVICES =                                  0x00,
    HCI_FILTER_CONDITION_TYPE_CLASS_OF_DEVICE =                              0x01,
    HCI_FILTER_CONDITION_TYPE_BD =                                           0x02
} tHCI_Filter_Condition_Type;

/*---------------------------------------------------------------------------------*/
/*                        [120][Auto_Accept_Flag][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Auto_Accept_Flag
{
    HCI_AUTO_ACCEPT_FLAG_DO_NOT =                                            0x01,
    HCI_AUTO_ACCEPT_FLAG_DISABLED =                                          0x02,
    HCI_AUTO_ACCEPT_FLAG_ENABLED =                                           0x03
} tHCI_Auto_Accept_Flag;

/*---------------------------------------------------------------------------------*/
/*                            [121][PIN_Type][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_PIN_Type                                 (0x0c09) */
/* Request                  Write_PIN_Type                                (0x0c0a) */
/* The PIN Type configuration parameter determines whether the Link Manager assumes
   that the Host supports variable PIN codes or a fixed PIN code. The host
   controller uses the PIN-type information during pairing */
typedef enum _tHCI_PIN_Type
{
    HCI_PIN_TYPE_VARIABLE_PIN =                                              0x00,
    HCI_PIN_TYPE_FIXED_PIN =                                                 0x01
} tHCI_PIN_Type;

/*---------------------------------------------------------------------------------*/
/*                            [122][All_Flag][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Request                  Read_Stored_Link_Key                          (0x0c0d) */
/* Request                  Delete_Stored_Link_Key                        (0x0c12) */
typedef enum _tHCI_All_Flag
{
    HCI_ALL_FLAG_LINK_KEY_FOR_BD_ADDR =                                      0x00,
    HCI_ALL_FLAG_ALL_STORED_LINK_KEYS =                                      0x01
} tHCI_All_Flag;

/*---------------------------------------------------------------------------------*/
/*                          [123][Max_Num_Keys][Val][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Stored_Link_Key                          (0x0c0d) */
/* Total Number of Link Keys that the Controller can store */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                            [124][Num_Keys][Val][L:2]                            */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Stored_Link_Key                          (0x0c0d) */
/* Return                   Delete_Stored_Link_Key                        (0x0c12) */
/* Event                    Return_Link_Keys                              (0x0015) */
/* Number of Link Keys Read/Deleted */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                        [125][Num_Keys_To_Write][Val][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Write_Stored_Link_Key                         (0x0c11) */
/* Number of Link Keys to Write */
/* Range: 0x1 ~ 0xb */

/*---------------------------------------------------------------------------------*/
/*                        [126][Num_Keys_Written][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Write_Stored_Link_Key                         (0x0c11) */
/* Number of Link Keys successfully written */
/* Range: 0x0 ~ 0xb */

/*---------------------------------------------------------------------------------*/
/*                     [127][Hold_Mode_Max_Interval][Time][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Request                  Hold_Mode                                     (0x0801) */
/* Maximum acceptable number of Baseband slots to wait in Hold Mode,Time Range: 1.
  25ms - 40.9 sec,Mandatory Range: 0x0014 to 0x8000 */
/* Range: 0x2 ~ 0xfffe */
/* TimeRange[0.625000]: 1.250000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                     [128][Hold_Mode_Min_Interval][Time][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Request                  Hold_Mode                                     (0x0801) */
/* Minimum acceptable number of Baseband slots to wait in Hold Mode,Time Range: 1.
  25ms - 40.8 sec,Mandatory Range: 0x0014 to 0x8000 */
/* Range: 0x2 ~ 0xff00 */
/* TimeRange[0.625000]: 1.250000 ~ 40800.000000 */

/*---------------------------------------------------------------------------------*/
/*                       [129][Sniff_Max_Interval][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Mode                                    (0x0803) */
/* Range: 0x0002 to 0xFFFE; only even values are valid, Mandatory Range: 0x0006 to
   0x0540, Time = N * 0.625 msec, Time Range: 1.25 msec to 40.9 sec */
/* Range: 0x2 ~ 0xfffe */
/* TimeRange[0.625000]: 1.250000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                       [130][Sniff_Min_Interval][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Mode                                    (0x0803) */
/* Range: 0x0002 to 0xFFFE; only even values are valid, Mandatory Range: 0x0006 to
   0x0540, Time = N * 0.625 msec, Time Range: 1.25 msec to 40.9 sec */
/* Range: 0x2 ~ 0xfffe */
/* TimeRange[0.625000]: 1.250000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                         [131][Sniff_Attempt][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Mode                                    (0x0803) */
/* Number of Baseband receive slots for sniff attempt,Length = N* 1.25 msec,Range
   for N: 0x0001 - 0x7FFF,Time Range: 1.25msec - 40.9 sec,Mandatory Range for
   Controller: 1 to Tsniff/2 */
/* Range: 0x1 ~ 0x7fff */
/* TimeRange[1.250000]: 1.250000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                         [132][Sniff_Timeout][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Mode                                    (0x0803) */
/* Number of Baseband receive slots for sniff timeout,Length = N * 1.25 msec,Range
   for N: 0x0000 - 0x7FFF,Time Range: 0 msec - 40.9 sec,Mandatory Range for
   Controller: 0 to 0x0028 */
/* Range: 0x0 ~ 0x7fff */
/* TimeRange[1.250000]: 0.000000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                [133][Secure_Connections_Host_Support][Enum][L:1]                */
/*---------------------------------------------------------------------------------*/
/* 0x02-0xFF    Reserved for future use. When Secure Connections Host Support is set
   to 'enabled' the Controller shall use the enhanced reporting mechanisms for the
   Encryption_Enabled parameter in the Encryption Change event (see Section 7.7.8)
   and the Key_Type parameter in the Link Key Notification event (see Section 7.7.
  24). */
typedef enum _tHCI_Secure_Connections_Host_Support
{
    HCI_SECURE_CONNECTIONS_HOST_SUPPORT_DISABLED =                           0x00,
    HCI_SECURE_CONNECTIONS_HOST_SUPPORT_ENABLED =                            0x01
} tHCI_Secure_Connections_Host_Support;

/*---------------------------------------------------------------------------------*/
/*                  [134][Secure_Connections_Only_Mode][Enum][L:1]                 */
/*---------------------------------------------------------------------------------*/
/* 0x02-0xFF    Reserved for future use. When Secure Connections Only Mode is set to
   'enabled' the Controller shall not pair with devices using legacy pairing or
   Secure Simple Pairing using the P192 elliptic curve and shall not use legacy
   (E0) encryption */
typedef enum _tHCI_Secure_Connections_Only_Mode
{
    HCI_SECURE_CONNECTIONS_ONLY_MODE_DISABLED =                              0x00,
    HCI_SECURE_CONNECTIONS_ONLY_MODE_ENABLED =                               0x01
} tHCI_Secure_Connections_Only_Mode;

/*---------------------------------------------------------------------------------*/
/*                      [135][Beacon_Max_Interval][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Park_State                                    (0x0805) */
/* Range: 0x000E to 0xFFFE; only even values are valid,Mandatory Range: 0x000E to
   0x1000,Time = N * 0.625 msec,Time Range: 8.75 msec to 40.9 sec */
/* Range: 0xe ~ 0xfffe */
/* TimeRange[0.625000]: 8.750000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                      [136][Beacon_Min_Interval][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Park_State                                    (0x0805) */
/* Range: 0x000E to 0xFFFE; only even values are valid,Mandatory Range: 0x000E to
   0x1000,Time = N * 0.625 msec,Time Range: 8.75 msec to 40.9 sec */
/* Range: 0xe ~ 0xfffe */
/* TimeRange[0.625000]: 8.750000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                      [137][Conn_Accept_Timeout][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Connection_Accept_Timeout                (0x0c15) */
/* Request                  Write_Connection_Accept_Timeout               (0x0c16) */
/* Connection Accept Timeout measured in Number of BR/EDR Baseband slots,Interval
   Length = N * 0.625 msec (1 Baseband slot),Time Range: 0.625 msec - 29 seconds,
  Time Default: BR/EDR 5 sec,AMP type dependent.The Connection_Accept_Timeout
   configuration parameter allows the BR/EDR Controller to automatically deny a
   connection request after a specified time period has occurred and the new
   connection is not accepted. The parameter defines the time duration from when
   the BR/EDR Controller sends a Connection Request event until the BR/EDR
   Controller will automatically reject an incoming connection.The
   Connection_Accept_Timeout configuration parameter allows each AMP Controller to
   limit the duration of the Create_Physical_Link command or Accept_Physical_Link
   command it is locally serving. The parameter defines the maximum time duration
   for all physical connection setup activities that occur between the
   Create_Physical_Link command or Accept_Physical_Link command and the
   corresponding Physical Link Compete event (including all authentication
   activity) before the AMP Controller will automatically reject the physical link
   setup. */
/* Range: 0x1 ~ 0xb540 */
/* TimeRange[0.625000]: 0.625000 ~ 29000.000000 */

/*---------------------------------------------------------------------------------*/
/*                          [138][Page_Timeout][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Page_Timeout                             (0x0c17) */
/* Request                  Write_Page_Timeout                            (0x0c18) */
/* Page Timeout measured in Number of Baseband slots,Default: 0x2000,Interval
   Length = N * 0.625 msec (1 Baseband slot),Time Range: 0.625 msec -40.9 Seconds.
  Time Default: 5.12 sec.The Page_Timeout configuration parameter defines the
   maximum time the local Link Manager will wait for a baseband page response from
   the remote device at a locally initiated connection attempt. If this time
   expires and the remote BR/EDR Controller has not responded to the page at
   baseband level, the connection attempt will be considered to have failed */
/* Range: 0x1 ~ 0xffff */
/* TimeRange[0.625000]: 0.625000 ~ 40959.375000 */

/*---------------------------------------------------------------------------------*/
/*                          [139][Scan_Enable][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Scan_Enable                              (0x0c19) */
/* Request                  Write_Scan_Enable                             (0x0c1a) */
/* The Scan_Enable parameter controls whether or not the BREDR Controller will
   periodically scan for page attempts and/or inquiry requests from other BREDR
   Controllers */
typedef enum _tHCI_Scan_Enable
{
    HCI_SCAN_ENABLE_NO_SCANS_ENABLED =                                       0x00,
    HCI_SCAN_ENABLE_INQUIRY_SCAN_ENABLED_PAGE_SCAN_DISABLED =                0x01,
    HCI_SCAN_ENABLE_INQUIRY_SCAN_DISABLED_PAGE_SCAN_ENABLED =                0x02,
    HCI_SCAN_ENABLE_INQUIRY_SCAN_ENABLED_PAGE_SCAN_ENABLED =                 0x03
} tHCI_Scan_Enable;

/*---------------------------------------------------------------------------------*/
/*                       [140][Page_Scan_Interval][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Page_Scan_Activity                       (0x0c1b) */
/* Request                  Write_Page_Scan_Activity                      (0x0c1c) */
/* Range: 11.25 msec - 2560 msec; only even values are valid,Default: 0x0800,Time
   Default: 1.28 sec.The Page_Scan_Interval configuration parameter defines the
   amount of time between consecutive page scans. This time interval is defined
   from when the Controller started its last page scan until it begins the next
   page scan */
/* Range: 0x12 ~ 0x1000 */
/* TimeRange[0.625000]: 11.250000 ~ 2560.000000 */

/*---------------------------------------------------------------------------------*/
/*                        [141][Page_Scan_Window][Time][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Page_Scan_Activity                       (0x0c1b) */
/* Request                  Write_Page_Scan_Activity                      (0x0c1c) */
/* Only even values are valid,Range: 11.25 msec - 2560 msec,Time Default: 2.56 sec.
  The Page_Scan_Window configuration parameter defines the amount of time for the
   duration of the page scan. The Page_Scan_Window can only be less than or equal
   to the Page_Scan_Interval */
/* Range: 0x12 ~ 0x1000 */
/* TimeRange[0.625000]: 11.250000 ~ 2560.000000 */

/*---------------------------------------------------------------------------------*/
/*                     [142][Inquiry_Scan_Interval][Time][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Inquiry_Scan_Activity                    (0x0c1d) */
/* Request                  Write_Inquiry_Scan_Activity                   (0x0c1e) */
/* Range: 11.25 - 2560 msec; only even values are valid.The Inquiry_Scan_Interval
   configuration parameter defines the amount of time between consecutive inquiry
   scans. This is defined as the time interval from when the BR/EDR Controller
   started its last inquiry scan until it begins the next inquiry scan */
/* Range: 0x12 ~ 0x1000 */
/* TimeRange[0.625000]: 11.250000 ~ 2560.000000 */

/*---------------------------------------------------------------------------------*/
/*                      [143][Inquiry_Scan_Window][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Inquiry_Scan_Activity                    (0x0c1d) */
/* Request                  Write_Inquiry_Scan_Activity                   (0x0c1e) */
/* Range: 10.625 msec - 2560 msec,Default: 0x0012,The Inquiry_Scan_Window
   configuration parameter defines the amount of time for the duration of the
   inquiry scan. The Inquiry_Scan_Window can only be less than or equal to the
   Inquiry_Scan_Interval */
/* Range: 0x11 ~ 0x1000 */
/* TimeRange[0.625000]: 10.625000 ~ 2560.000000 */

/*---------------------------------------------------------------------------------*/
/*                     [144][Authentication_Enable][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Authentication_Enable                    (0x0c1f) */
/* Request                  Write_Authentication_Enable                   (0x0c20) */
/* The Authentication_Enable parameter controls if the local device requires to
   authenticate the remote device at connection setup (between the
   Create_Connection command or acceptance of an incoming ACL connection and the
   corresponding Connection Complete event). At connection setup, only the
   device(s) with the Authentication_Enable parameter enabled will try to
   authenticate the other device.Note: Changing this parameter does not affect
   existing connections */
typedef enum _tHCI_Authentication_Enable
{
    HCI_AUTHENTICATION_ENABLE_NOT_REQUIRED =                                 0x00,
    HCI_AUTHENTICATION_ENABLE_REQUIRED_FOR_ALL_CONNECTIONS =                 0x01
} tHCI_Authentication_Enable;

/*---------------------------------------------------------------------------------*/
/*                         [145][Flush_Timeout][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Automatic_Flush_Timeout                  (0x0c27) */
/* Request                  Write_Automatic_Flush_Timeout                 (0x0c28) */
/* 0 Timeout unlimited, No Automatic Flush,N = 0xXXXX,Flush Timeout = N * 0.625
   msec,Size: 11 bits,Time Range: 0.625 msec to 1279.375 msec.The Flush_Timeout
   configuration parameter is used for ACL connections on a BR/EDR Controller only */
/* Range: 0x0 ~ 0x7ff */
/* TimeRange[0.625000]: 0.000000 ~ 1279.375000 */

/*---------------------------------------------------------------------------------*/
/*                  [146][Num_Broadcast_Retransmissions][Val][L:1]                 */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Num_Broadcast_Retransmissions            (0x0c29) */
/* Request                  Write_Num_Broadcast_Retransmissions           (0x0c2a) */
/* Broadcast packets are not acknowledged and are unreliable. The Number of
   Broadcast Retransmissions parameter, N, is used to increase the reliability of
   a broadcast message by retransmitting the broadcast message multiple times.
   This sets the value NBC in the baseband to one greater than the Num Broadcast
   Retransmissions value. */
/* Range: 0x0 ~ 0xfe */

/*---------------------------------------------------------------------------------*/
/*                       [147][Hold_Mode_Activity][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Hold_Mode_Activity                       (0x0c2b) */
/* Request                  Write_Hold_Mode_Activity                      (0x0c2c) */
/* The Hold_Mode_Activity value is used to determine what activities should be
   suspended when the BR/EDR Controller is in hold mode. After the hold period has
   expired, the device will return to the previous mode of operation. Multiple
   hold mode activities may be specified for the Hold_Mode_Activity parameter by
   performing a bitwise OR operation of the different activity types. If no
   activities are suspended, then all of the current Periodic Inquiry, Inquiry
   Scan, and Page Scan settings remain valid during the Hold Mode. If the
   Hold_Mode_Activity parameter is set to Suspend Page Scan, Suspend Inquiry Scan,
   and Suspend Periodic Inquiries, then the device can enter a low-power state
   during the Hold Mode period, and all activities are suspended. Suspending
   multiple activities can be specified for the Hold_Mode_Activity parameter by
   performing a bitwise OR operation of the different activity types. The Hold
   Mode Activity is only valid if all connections are in Hold Mode */
typedef enum _tHCI_Hold_Mode_Activity
{
    HCI_HOLD_MODE_ACTIVITY_MAINTAIN_CURRENT_POWER_STATE =                    0x00,
    HCI_HOLD_MODE_ACTIVITY_SUSPEND_PAGE_SCAN =                               0x01,
    HCI_HOLD_MODE_ACTIVITY_SUSPEND_INQUIRY_SCAN =                            0x02,
    HCI_HOLD_MODE_ACTIVITY_SUSPEND_PERIODIC_INQUIRIES =                      0x04
} tHCI_Hold_Mode_Activity;

/*---------------------------------------------------------------------------------*/
/*                              [148][Type][Enum][L:1]                             */
/*---------------------------------------------------------------------------------*/
/* Request                  Read_Transmit_Power_Level                     (0x0c2d) */
/* Request                  Read_Enhanced_Transmit_Power_Level            (0x0c68) */
typedef enum _tHCI_Type
{
    HCI_TYPE_READ_CURRENT_TRANSMIT_POWER_LEVEL =                             0x00,
    HCI_TYPE_READ_MAXIMUM_TRANSMIT_POWER_LEVEL =                             0x01
} tHCI_Type;

/*---------------------------------------------------------------------------------*/
/*                      [149][Transmit_Power_Level][Val][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Transmit_Power_Level                     (0x0c2d) */
/* Return                   LE_Read_Advertising_Channel_Tx_Power          (0x2007) */
/* Size: 1 Octet (signed integer),Range: -30>=N<=20,Units: dBm */

/*---------------------------------------------------------------------------------*/
/*                [150][Synchronous_Flow_Control_Enable][Enum][L:1]                */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Synchronous_Flow_Control_Enable          (0x0c2e) */
/* Request                  Write_Synchronous_Flow_Control_Enable         (0x0c2f) */
/* The Synchronous Flow Control Enable configuration parameter allows the Host to
   decide if the BR/EDR Controller will send Number Of Completed Packets events
   for synchronous Connection_Handles. This setting allows the Host to enable and
   disable synchronous flow control */
typedef enum _tHCI_Synchronous_Flow_Control_Enable
{
    HCI_SYNCHRONOUS_FLOW_CONTROL_ENABLE_DISABLED =                           0x00,
    HCI_SYNCHRONOUS_FLOW_CONTROL_ENABLE_ENABLED =                            0x01
} tHCI_Synchronous_Flow_Control_Enable;

/*---------------------------------------------------------------------------------*/
/*                      [151][Flow_Control_Enable][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Set_Controller_To_Host_Flow_Control           (0x0c31) */
typedef enum _tHCI_Flow_Control_Enable
{
    HCI_FLOW_CONTROL_ENABLE_ACL_OFF_SCO_OFF_DEFAULT =                        0x00,
    HCI_FLOW_CONTROL_ENABLE_ACL_ON_SCO_OFF =                                 0x01,
    HCI_FLOW_CONTROL_ENABLE_ACL_OFF_SCO_ON =                                 0x02,
    HCI_FLOW_CONTROL_ENABLE_ACL_ON_SCO_ON =                                  0x03
} tHCI_Flow_Control_Enable;

/*---------------------------------------------------------------------------------*/
/*                   [152][Host_ACL_Data_Packet_Length][Val][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* Request                  Host_Buffer_Size                              (0x0c33) */
/* Maximum length (in octets) of the data portion of each HCI ACL Data Packet that
   the Host is able to accept */

/*---------------------------------------------------------------------------------*/
/*               [153][Host_Synchronous_Data_Packet_Length][Val][L:1]              */
/*---------------------------------------------------------------------------------*/
/* Request                  Host_Buffer_Size                              (0x0c33) */
/* Maximum length (in octets) of the data portion of each HCI synchronous Data
   Packet that the Host is able to accept */

/*---------------------------------------------------------------------------------*/
/*                 [154][Host_Total_Num_ACL_Data_Packets][Val][L:2]                */
/*---------------------------------------------------------------------------------*/
/* Request                  Host_Buffer_Size                              (0x0c33) */
/* Total number of HCI ACL Data Packets that can be stored in the data buffers of
   the Host */

/*---------------------------------------------------------------------------------*/
/*             [155][Host_Total_Num_Synchronous_Data_Packets][Val][L:2]            */
/*---------------------------------------------------------------------------------*/
/* Request                  Host_Buffer_Size                              (0x0c33) */
/* Total number of HCI synchronous Data Packets that can be stored in the data
   buffers of the Host */

/*---------------------------------------------------------------------------------*/
/*                        [156][Number_Of_Handles][Val][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Host_Number_Of_Completed_Packets              (0x0c35) */
/* Event                    Number_Of_Completed_Packets                   (0x0013) */
/* Event                    Number_Of_Completed_Data_Blocks               (0x0048) */
/* The number of Connection Handles and Host_Num_Of_Completed_Packets parameters
   pairs contained in this command */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                  [157][Host_Num_Of_Completed_Packets][Val][L:2]                 */
/*---------------------------------------------------------------------------------*/
/* Request                  Host_Number_Of_Completed_Packets              (0x0c35) */
/* The number of HCI Data Packets that have been completed for the associated
   Connection Handle since the previous time the event was returned */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                    [158][Link_Supervision_Timeout][Time][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Link_Supervision_Timeout                 (0x0c36) */
/* Request                  Write_Link_Supervision_Timeout                (0x0c37) */
/* Event                    Link_Supervision_Timeout_Changed              (0x0038) */
/* 0x0000 No Link_Supervision_Timeout,Measured in Number of BR/EDR Baseband slots,
  Link_Supervision_Timeout = N * 0.625 msec (1 Baseband slot),Range for N: 0x0001
   - 0xFFFF,Time Range: 0.625ms - 40.9 sec.Time Default: BR/EDR 20 sec,AMP 10 sec.
  The Link_Supervision_Timeout parameter is used by the  Controller to monitor
   link loss. If, for any reason, no  packets are received from that Handle (a
   Connection_Handle for the BR/EDR Controller or the Physical_Link_Handle for an
   AMP Controller) for a duration longer than the Link_Supervision_Timeout, the
   connection is disconnected */
/* Range: 0x0 ~ 0xffff */
/* TimeRange[0.625000]: 0.000000 ~ 40959.375000 */

/*---------------------------------------------------------------------------------*/
/*                         [159][Num_Support_IAC][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Number_Of_Supported_IAC                  (0x0c38) */
/* Specifies the number of Supported IAC that the local BR/EDR Controller can
   simultaneous listen for during an Inquiry Scan */
/* Range: 0x1 ~ 0x40 */

/*---------------------------------------------------------------------------------*/
/*                         [160][Num_Current_IAC][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Current_IAC_LAP                          (0x0c39) */
/* Request                  Write_Current_IAC_LAP                         (0x0c3a) */
/* Specifies the number of IACs which are currently in use by the local BR/EDR
   Controller to simultaneously listen for during an Inquiry Scan */
/* Range: 0x1 ~ 0x40 */

/*---------------------------------------------------------------------------------*/
/*                              [161][LAP][Enum][L:3]                              */
/*---------------------------------------------------------------------------------*/
/* Request                  Inquiry                                       (0x0401) */
/* Request                  Periodic_Inquiry_Mode                         (0x0403) */
/* Return                   Read_Current_IAC_LAP                          (0x0c39) */
/* Request                  Write_Current_IAC_LAP                         (0x0c3a) */
/* 0x9E8B00-0x9E8B3F,This is the LAP from which the inquiry access code should be
   derived when the inquiry procedure is made; see Bluetooth Assigned Numbers.
  LAP(s) used to create IAC which is currently in use by the local BR/EDR
   Controller to simultaneously listen for during an Inquiry Scan.The GIAC is the
   default IAC to be used. If additional IACs are supported,additional default IAC
   will be determined by the manufacturer */
typedef enum _tHCI_LAP
{
    HCI_LAP_GENERAL_UNLIMITED_INQUIRY_ACCESS_CODE_GIAC =                     0x9E8B33,
    HCI_LAP_LIMITED_DEDICATED_INQUIRY_ACCESS_CODE_LIAC =                     0x9E8B00
} tHCI_LAP;

/*---------------------------------------------------------------------------------*/
/*                [162][AFH_Host_Channel_Classification][Enum][L:10]               */
/*---------------------------------------------------------------------------------*/
/* Request                  Set_AFH_Host_Channel_Classification           (0x0c3f) */
/* This parameter contains 79 1-bit field.The nth such field (in the range 0 to 78)
   contains the value for channel n:Channel n is bad = 0,Channel n is unknown = 1,
  The most significant bit is reserved and shall be set to 0,At least Nmin
   channels shall be marked as unknown */
typedef enum _tHCI_AFH_Host_Channel_Classification
{
    HCI_AFH_HOST_CHANNEL_CLASSIFICATION_BAD =                                0x00,
    HCI_AFH_HOST_CHANNEL_CLASSIFICATION_UNKNOWN =                            0x01
} tHCI_AFH_Host_Channel_Classification;

/*---------------------------------------------------------------------------------*/
/*                       [163][Inquiry_Scan_Type][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Inquiry_Scan_Type                        (0x0c42) */
/* Request                  Write_Inquiry_Scan_Type                       (0x0c43) */
typedef enum _tHCI_Inquiry_Scan_Type
{
    HCI_INQUIRY_SCAN_TYPE_STANDARD_SCAN_DEFAULT =                            0x00,
    HCI_INQUIRY_SCAN_TYPE_INTERLACED_SCAN =                                  0x01
} tHCI_Inquiry_Scan_Type;

/*---------------------------------------------------------------------------------*/
/*                          [164][Inquiry_Mode][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Inquiry_Mode                             (0x0c44) */
/* Request                  Write_Inquiry_Mode                            (0x0c45) */
/* The Inquiry_Mode configuration parameter indicates whether inquiry returns
   Inquiry Result events in the standard format, with RSSI, or with RSSI and
   extended inquiry response information */
typedef enum _tHCI_Inquiry_Mode
{
    HCI_INQUIRY_MODE_STANDARD_EVENT_FORMAT =                                 0x00,
    HCI_INQUIRY_MODE_FORMAT_WITH_RSSI =                                      0x01,
    HCI_INQUIRY_MODE_WITH_RSSI_OR_EXTENDED_FORMAT =                          0x02
} tHCI_Inquiry_Mode;

/*---------------------------------------------------------------------------------*/
/*                         [165][Page_Scan_Type][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Page_Scan_Type                           (0x0c46) */
/* Request                  Write_Page_Scan_Type                          (0x0c47) */
/* The Page_Scan_Type parameter indicates whether inquiry scanning will be done
   using non-interlaced scan or interlaced scan */
typedef enum _tHCI_Page_Scan_Type
{
    HCI_PAGE_SCAN_TYPE_MANDATORY_STANDARD_SCAN_DEFAULT =                     0x00,
    HCI_PAGE_SCAN_TYPE_OPTIONAL_INTERLACED_SCAN =                            0x01
} tHCI_Page_Scan_Type;

/*---------------------------------------------------------------------------------*/
/*                  [166][AFH_Channel_Assessment_Mode][Enum][L:1]                  */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_AFH_Channel_Assessment_Mode              (0x0c48) */
/* Request                  Write_AFH_Channel_Assessment_Mode             (0x0c49) */
typedef enum _tHCI_AFH_Channel_Assessment_Mode
{
    HCI_AFH_CHANNEL_ASSESSMENT_MODE_DISABLED =                               0x00,
    HCI_AFH_CHANNEL_ASSESSMENT_MODE_ENABLED =                                0x01
} tHCI_AFH_Channel_Assessment_Mode;

/*---------------------------------------------------------------------------------*/
/*                          [167][FEC_Required][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Extended_Inquiry_Response                (0x0c51) */
/* Request                  Write_Extended_Inquiry_Response               (0x0c52) */
typedef enum _tHCI_FEC_Required
{
    HCI_FEC_REQUIRED_NOT_REQUIRED =                                          0x00,
    HCI_FEC_REQUIRED_REQUIRED =                                              0x01
} tHCI_FEC_Required;

/*---------------------------------------------------------------------------------*/
/*                   [168][Extended_Inquiry_Response][Val][L:240]                  */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Extended_Inquiry_Response                (0x0c51) */
/* Request                  Write_Extended_Inquiry_Response               (0x0c52) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* Information about the local device that will be sent in an extended inquiry
   response packet to remote devices during inquiry response. */

/*---------------------------------------------------------------------------------*/
/*                           [169][EIR_Flags][Mask][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* The Flags field may be zero or more octets long. This allows the Flags field to
   be extended while using the minimum number of octets within the data packet.
   All octets that are 0x00 are not transmitted as long as all other octets after
   that octet are also 0x00. */
typedef enum _tHCI_EIR_Flags
{
    HCI_EIR_FLAGS_LE_LIMITED_DISCOVERABLE_MODE =                             0x01,
    HCI_EIR_FLAGS_LE_GENERAL_DISCOVERABLE_MODE =                             0x02,
    HCI_EIR_FLAGS_BREDR_NOT_SUPPORTED =                                      0x04,
    HCI_EIR_FLAGS_LE_AND_BREDR_TO_SAME_DEVICE_CAPABLE_CONTROLLER =           0x08,
    HCI_EIR_FLAGS_LE_AND_BREDR_TO_SAME_DEVICE_CAPABLE_HOST =                 0x10
} tHCI_EIR_Flags;

/*---------------------------------------------------------------------------------*/
/*                           [170][OOB_Flags][Mask][L:1]                           */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_OOB_Flags
{
    HCI_OOB_FLAGS_OOB_FLAGS_FIELD =                                          0x01,
    HCI_OOB_FLAGS_LE_SUPPORTED_HOST =                                        0x02,
    HCI_OOB_FLAGS_SIMULTANEOUS_LE_AND_BREDR_TO_SAME_DEVICE_CAPABLE_HOST =    0x04,
    HCI_OOB_FLAGS_ADDRESS_TYPE =                                             0x08
} tHCI_OOB_Flags;

/*---------------------------------------------------------------------------------*/
/*                          [171][EIR_DataType][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* 18  APPENDIX C (NORMATIVE): EIR AND AD FORMATS, data format used in the EIR data
   field and in the AD format */
typedef enum _tHCI_EIR_DataType
{
    HCI_EIR_DATATYPE_FLAGS =                                                 0x01,
    HCI_EIR_DATATYPE_INCOMPLETE_LIST_OF_16BIT_SERVICE_CLASS_UUIDS =          0x02,
    HCI_EIR_DATATYPE_COMPLETE_LIST_OF_16BIT_SERVICE_CLASS_UUIDS =            0x03,
    HCI_EIR_DATATYPE_INCOMPLETE_LIST_OF_32BIT_SERVICE_CLASS_UUIDS =          0x04,
    HCI_EIR_DATATYPE_COMPLETE_LIST_OF_32BIT_SERVICE_CLASS_UUIDS =            0x05,
    HCI_EIR_DATATYPE_INCOMPLETE_LIST_OF_128BIT_SERVICE_CLASS_UUIDS =         0x06,
    HCI_EIR_DATATYPE_COMPLETE_LIST_OF_128BIT_SERVICE_CLASS_UUIDS =           0x07,
    HCI_EIR_DATATYPE_SHORTENED_LOCAL_NAME =                                  0x08,
    HCI_EIR_DATATYPE_COMPLETE_LOCAL_NAME =                                   0x09,
    HCI_EIR_DATATYPE_TX_POWER_LEVEL =                                        0x0A,
    HCI_EIR_DATATYPE_CLASS_OF_DEVICE =                                       0x0D,
    HCI_EIR_DATATYPE_SIMPLE_PAIRING_HASH_C =                                 0x0E,
    HCI_EIR_DATATYPE_SIMPLE_PAIRING_RANDOMIZER_R =                           0x0F,
    HCI_EIR_DATATYPE_DEVICE_ID =                                             0x10,
    HCI_EIR_DATATYPE_SECURITY_MANAGER_TK_VALUE =                             0x10,
    HCI_EIR_DATATYPE_SECURITY_MANAGER_OUT_OF_BAND_FLAGS =                    0x11,
    HCI_EIR_DATATYPE_SLAVE_CONNECTION_INTERVAL_RANGE =                       0x12,
    HCI_EIR_DATATYPE_LIST_OF_16BIT_SERVICE_SOLICITATION_UUIDS =              0x14,
    HCI_EIR_DATATYPE_LIST_OF_128BIT_SERVICE_SOLICITATION_UUIDS =             0x15,
    HCI_EIR_DATATYPE_SERVICE_DATA =                                          0x16,
    HCI_EIR_DATATYPE_PUBLIC_TARGET_ADDRESS =                                 0x17,
    HCI_EIR_DATATYPE_RANDOM_TARGET_ADDRESS =                                 0x18,
    HCI_EIR_DATATYPE_APPEARANCE =                                            0x19,
    HCI_EIR_DATATYPE_MANUFACTURER_SPECIFIC_DATA =                            0xFF
} tHCI_EIR_DataType;

/*---------------------------------------------------------------------------------*/
/*                      [172][Simple_Pairing_Mode][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Simple_Pairing_Mode                      (0x0c55) */
/* Request                  Write_Simple_Pairing_Mode                     (0x0c56) */
typedef enum _tHCI_Simple_Pairing_Mode
{
    HCI_SIMPLE_PAIRING_MODE_NOT_SET_DEFAULT =                                0x00,
    HCI_SIMPLE_PAIRING_MODE_ENABLED =                                        0x01
} tHCI_Simple_Pairing_Mode;

/*---------------------------------------------------------------------------------*/
/*                               [173][C][Val][L:16]                               */
/*---------------------------------------------------------------------------------*/
/* Request                  Remote_OOB_Data_Request_Reply                 (0x0430) */
/* Return                   Read_Local_OOB_Data                           (0x0c57) */
/* Simple Pairing Hash C */

/*---------------------------------------------------------------------------------*/
/*                               [174][R][Val][L:16]                               */
/*---------------------------------------------------------------------------------*/
/* Request                  Remote_OOB_Data_Request_Reply                 (0x0430) */
/* Return                   Read_Local_OOB_Data                           (0x0c57) */
/* Simple Pairing Randomizer R */

/*---------------------------------------------------------------------------------*/
/*                            [175][TX Power][Val][L:1]                            */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Inquiry_Response_Transmit_Power_Level    (0x0c58) */
/* Request                  Write_Inquiry_Transmit_Power_Level            (0x0c59) */
/* Size: 1 Octet (signed integer) Range: -70<=N<=20,Units: dBm */

/*---------------------------------------------------------------------------------*/
/*                       [176][Notification_Type][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Send_Keypress_Notification                    (0x0c60) */
/* Event                    Keypress_Notification                         (0x003c) */
typedef enum _tHCI_Notification_Type
{
    HCI_NOTIFICATION_TYPE_PASSKEY_ENTRY_STARTED =                            0x00,
    HCI_NOTIFICATION_TYPE_PASSKEY_DIGIT_ENTERED =                            0x01,
    HCI_NOTIFICATION_TYPE_PASSKEY_DIGIT_ERASED =                             0x02,
    HCI_NOTIFICATION_TYPE_PASSKEY_CLEARED =                                  0x03,
    HCI_NOTIFICATION_TYPE_PASSKEY_ENTRY_COMPLETED =                          0x04
} tHCI_Notification_Type;

/*---------------------------------------------------------------------------------*/
/*                    [177][Erroneous_Data_Reporting][Enum][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Default_Erroneous_Data_Reporting         (0x0c5a) */
/* Request                  Write_Default_Erroneous_Data_Reporting        (0x0c5b) */
/* The Erroneous_Data_Reporting configuration parameter shall be used for SCO and
   eSCO connections only. This parameter determines if the BR/EDR Controller is
   required to provide data to the Host for every (e)SCO interval, with the
   Packet_Status_Flag in HCI Synchronous Data Packets set */
typedef enum _tHCI_Erroneous_Data_Reporting
{
    HCI_ERRONEOUS_DATA_REPORTING_DISABLED =                                  0x00,
    HCI_ERRONEOUS_DATA_REPORTING_ENABLED =                                   0x01
} tHCI_Erroneous_Data_Reporting;

/*---------------------------------------------------------------------------------*/
/*                       [178][Packet_Type_Flush][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Enhanced_Flush                                (0x0c5f) */
typedef enum _tHCI_Packet_Type_Flush
{
    HCI_PACKET_TYPE_FLUSH_AUTOMATICALLY_FLUSHABLE_ONLY =                     0x00
} tHCI_Packet_Type_Flush;

/*---------------------------------------------------------------------------------*/
/*                  [179][Logical_Link_Accept_Timeout][Time][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* Logical_Link Accept Timeout measured in Number of BR/EDR Baseband slots.Interval
   Length = N * 0.625 msec (1 BR/EDR Baseband slot),Range for N: 0x0001 - 0xB540,
  Time Range: 0.625 msec -29 seconds. The Logical_Link_Accept_Timeout
   configuration parameter allows the AMP Controller to automatically deny a
   logical link request after a specified time period has elapsed and the new
   logical link has not completed. The parameter defines the timeout duration,
   which includes all logical link setup activities that occur between the
   Create_Logical_Link or Accept_Logical_Link commands and the Logical Link
   Compete event. If these activities are not completed within the specified time,
   the AMP Controller will automatically reject the logical link set up */
/* Range: 0x1 ~ 0xb540 */
/* TimeRange[0.625000]: 0.625000 ~ 29000.000000 */

/*---------------------------------------------------------------------------------*/
/*                     [180][Location_Domain_Aware][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* The Location_Domain_Aware parameter indicates if the transmitter has information
   about the current regulatory domain */
typedef enum _tHCI_Location_Domain_Aware
{
    HCI_LOCATION_DOMAIN_AWARE_REGULATORY_DOMAIN_UNKNOWN =                    0x00,
    HCI_LOCATION_DOMAIN_AWARE_REGULATORY_DOMAIN_KNOWN =                      0x01
} tHCI_Location_Domain_Aware;

/*---------------------------------------------------------------------------------*/
/*                         [181][Location_Domain][Val][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* The Location_Domain parameter specifies the country or other location code if
   known,Shall be set to XX (0x5858) for a non-country entity or when
   Location_Domain_Aware is set to regulatory domain unknown. When the regulatory
   domain is known, it shall be set according to the two Octet country code as
   defined in ISO 3166-1. */

/*---------------------------------------------------------------------------------*/
/*                    [182][Location_Domain_Options][Enum][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* The Location_Domain_Options parameter may specify additional information
   specific to that country, or that the location is not a single country */
typedef enum _tHCI_Location_Domain_Options
{
    HCI_LOCATION_DOMAIN_OPTIONS_SPACE_FOR_ENTIRE_COUNTRY =                   0x20,
    HCI_LOCATION_DOMAIN_OPTIONS_O_FOR_USE_OUTDOORS_ONLY =                    0x4F,
    HCI_LOCATION_DOMAIN_OPTIONS_I_FOR_USE_INDOORS_ONLY =                     0x49,
    HCI_LOCATION_DOMAIN_OPTIONS_X_FOR_A_NON_COUNTRY_ENTITY =                 0x58
} tHCI_Location_Domain_Options;

/*---------------------------------------------------------------------------------*/
/*                        [183][Location_Options][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* The Location_Options parameter indicates if the transmitter has information
   about any options that may affect operation in different locations */
typedef enum _tHCI_Location_Options
{
    HCI_LOCATION_OPTIONS_NOT_MAINS_POWERED =                                 0x00,
    HCI_LOCATION_OPTIONS_MAINS_POWERED =                                     0x01
} tHCI_Location_Options;

/*---------------------------------------------------------------------------------*/
/*                       [184][Flow_Control_Mode][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Flow_Control_Mode                        (0x0c66) */
/* Request                  Write_Flow_Control_Mode                       (0x0c67) */
/* The Flow_Control_Mode configuration parameter allows the Host to select the HCI
   Data flow control mode used by the Controller for ACL Data traffic */
typedef enum _tHCI_Flow_Control_Mode
{
    HCI_FLOW_CONTROL_MODE_PACKET_BASED =                                     0x00,
    HCI_FLOW_CONTROL_MODE_DATA_BLOCK_BASED =                                 0x01
} tHCI_Flow_Control_Mode;

/*---------------------------------------------------------------------------------*/
/*                    [185][Transmit_Power_Level_GFSK][Val][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Enhanced_Transmit_Power_Level            (0x0c68) */
/* Size: 1 Octet (signed integer),Range: -100<=N<=20,Units: dBm */

/*---------------------------------------------------------------------------------*/
/*                   [186][Transmit_Power_Level_DQPSK][Val][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Enhanced_Transmit_Power_Level            (0x0c68) */
/* Size: 1 Octet (signed integer),Range: -100<=N<=20,Units: dBm */

/*---------------------------------------------------------------------------------*/
/*                   [187][Transmit_Power_Level_8DPSK][Val][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Enhanced_Transmit_Power_Level            (0x0c68) */
/* Size: 1 Octet (signed integer),Range: -100<=N<=20,Units: dBm */

/*---------------------------------------------------------------------------------*/
/*                    [188][Best_Effort_Flush_Timeout][Val][L:4]                   */
/*---------------------------------------------------------------------------------*/
/* Range: 0x0 ~ 0x0 */

/*---------------------------------------------------------------------------------*/
/*                       [189][Logical_Link_Handle][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Logical_Link_Handle for the logical link */
/* Range: 0x0 ~ 0xeff */

/*---------------------------------------------------------------------------------*/
/*                      [190][Physical_Link_Handle][Val][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Physical Link Handle identifying the physical link to be created (see Section 5.
  3.2) */
/* Range: 0x1 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                    [191][Dedicated_AMP_Key_Length][Val][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* See Assigned Numbers. */
/* Range: 0x1 ~ 0x20 */

/*---------------------------------------------------------------------------------*/
/*                     [192][Dedicated_AMP_Key_Type][Enum][L:1]                    */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Dedicated_AMP_Key_Type
{
    HCI_DEDICATED_AMP_KEY_TYPE_DEBUG_COMBINATION_KEYS =                      0x03,
    HCI_DEDICATED_AMP_KEY_TYPE_UNAUTHENTICATED_COMBINATION_KEY =             0x04,
    HCI_DEDICATED_AMP_KEY_TYPE_AUTHENTICATED_COMBINATION_KEY =               0x05
} tHCI_Dedicated_AMP_Key_Type;

/*---------------------------------------------------------------------------------*/
/*                        [193][Dedicated_AMP_Key][Val][L:X]                       */
/*---------------------------------------------------------------------------------*/
/* Dedicated AMP Key for the associated AMP. The Dedicated AMP Key is a multi-octet
   integer */

/*---------------------------------------------------------------------------------*/
/*                        [194][Short_Range_Mode][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Configuration setting of Short Range Mode, State of Short Range Mode in
   controller */
typedef enum _tHCI_Short_Range_Mode
{
    HCI_SHORT_RANGE_MODE_DISABLED_DEFAULT =                                  0x00,
    HCI_SHORT_RANGE_MODE_ENABLED =                                           0x01
} tHCI_Short_Range_Mode;

/*---------------------------------------------------------------------------------*/
/*                       [195][LE_Supported_Host][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_LE_Host_Support                          (0x0c6c) */
/* Request                  Write_LE_Host_Support                         (0x0c6d) */
/* The LE_Supported_Host parameter allows the Host to read and set the Link Manager
   Protocol feature bit LE Supported Host */
typedef enum _tHCI_LE_Supported_Host
{
    HCI_LE_SUPPORTED_HOST_DISABLED_DEFAULT =                                 0x00,
    HCI_LE_SUPPORTED_HOST_ENABLED =                                          0x01
} tHCI_LE_Supported_Host;

/*---------------------------------------------------------------------------------*/
/*                      [196][Simultaneous_LE_Host][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_LE_Host_Support                          (0x0c6c) */
/* Request                  Write_LE_Host_Support                         (0x0c6d) */
/* The Simultaneous_LE_Host parameter allows the Host to read and set the Link
   Manager Protocol feature bit Simultaneous LE and BR/EDR to Same Device Capable
   Host */
typedef enum _tHCI_Simultaneous_LE_Host
{
    HCI_SIMULTANEOUS_LE_HOST_DISABLED_DEFAULT =                              0x00,
    HCI_SIMULTANEOUS_LE_HOST_ENABLED =                                       0x01
} tHCI_Simultaneous_LE_Host;

/*---------------------------------------------------------------------------------*/
/*                          [197][HCI_Version][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Version_Information                (0x1001) */
/* See Bluetooth Assigned Numbers */
typedef enum _tHCI_HCI_Version
{
    HCI_HCI_VERSION_1_0B =                                                   0x00,
    HCI_HCI_VERSION_1_1 =                                                    0x01,
    HCI_HCI_VERSION_1_2 =                                                    0x02,
    HCI_HCI_VERSION_2_0EDR =                                                 0x03,
    HCI_HCI_VERSION_2_1 =                                                    0x04,
    HCI_HCI_VERSION_3_0HS =                                                  0x05,
    HCI_HCI_VERSION_4_0 =                                                    0x06
} tHCI_HCI_Version;

/*---------------------------------------------------------------------------------*/
/*                          [198][HCI_Revision][Val][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Version_Information                (0x1001) */
/* Revision of the Current HCI in the BR/EDR Controller */

/*---------------------------------------------------------------------------------*/
/*                          [199][LMP_Version][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Version_Information                (0x1001) */
/* Event                    Read_Remote_Version_Information_Complete      (0x000c) */
/* Version of the Current LMP or PAL in the Controller. See Bluetooth Assigned
   Numbers */
typedef enum _tHCI_LMP_Version
{
    HCI_LMP_VERSION_1_0B =                                                   0x00,
    HCI_LMP_VERSION_1_1 =                                                    0x01,
    HCI_LMP_VERSION_1_2 =                                                    0x02,
    HCI_LMP_VERSION_2_0EDR =                                                 0x03,
    HCI_LMP_VERSION_2_1 =                                                    0x04,
    HCI_LMP_VERSION_3_0HS =                                                  0x05,
    HCI_LMP_VERSION_4_0 =                                                    0x06
} tHCI_LMP_Version;

/*---------------------------------------------------------------------------------*/
/*                       [200][Manufacturer_Name][Enum][L:0]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Version_Information                (0x1001) */
/* Event                    Read_Remote_Version_Information_Complete      (0x000c) */
/* Manufacturer Name of the BR/EDR Controller. See Bluetooth Assigned Numbers */
typedef enum _tHCI_Manufacturer_Name
{
    HCI_MANUFACTURER_NAME_ERICSSON_TECHNOLOGY_LICENSING =                    0x0000,
    HCI_MANUFACTURER_NAME_NOKIA_MOBILE_PHONES =                              0x0001,
    HCI_MANUFACTURER_NAME_INTEL_CORP =                                       0x0002,
    HCI_MANUFACTURER_NAME_IBM_CORP =                                         0x0003,
    HCI_MANUFACTURER_NAME_TOSHIBA_CORP =                                     0x0004,
    HCI_MANUFACTURER_NAME_3COM =                                             0x0005,
    HCI_MANUFACTURER_NAME_MICROSOFT =                                        0x0006,
    HCI_MANUFACTURER_NAME_LUCENT =                                           0x0007,
    HCI_MANUFACTURER_NAME_MOTOROLA =                                         0x0008,
    HCI_MANUFACTURER_NAME_INFINEON_TECHNOLOGIES_AG =                         0x0009,
    HCI_MANUFACTURER_NAME_CAMBRIDGE_SILICON_RADIO =                          0x000A,
    HCI_MANUFACTURER_NAME_SILICON_WAVE =                                     0x000B,
    HCI_MANUFACTURER_NAME_DIGIANSWER_AS =                                    0x000C,
    HCI_MANUFACTURER_NAME_TEXAS_INSTRUMENTS_INC =                            0x000D,
    HCI_MANUFACTURER_NAME_PARTHUS_TECHNOLOGIES_INC =                         0x000E,
    HCI_MANUFACTURER_NAME_BROADCOM_CORPORATION =                             0x000F,
    HCI_MANUFACTURER_NAME_MITEL_SEMICONDUCTOR =                              0x0010,
    HCI_MANUFACTURER_NAME_WIDCOMM_INC =                                      0x0011,
    HCI_MANUFACTURER_NAME_ZEEVO_INC =                                        0x0012,
    HCI_MANUFACTURER_NAME_ATMEL_CORPORATION =                                0x0013,
    HCI_MANUFACTURER_NAME_MITSUBISHI_ELECTRIC_CORPORATION =                  0x0014,
    HCI_MANUFACTURER_NAME_RTX_TELECOM_AS =                                   0x0015,
    HCI_MANUFACTURER_NAME_KC_TECHNOLOGY_INC =                                0x0016,
    HCI_MANUFACTURER_NAME_NEWLOGIC =                                         0x0017,
    HCI_MANUFACTURER_NAME_TRANSILICA_INC =                                   0x0018,
    HCI_MANUFACTURER_NAME_ROHDE_SCHWARZ_GMBH_CO_KG =                         0x0019,
    HCI_MANUFACTURER_NAME_TTPCOM_LIMITED =                                   0x001A,
    HCI_MANUFACTURER_NAME_SIGNIA_TECHNOLOGIES_INC =                          0x001B,
    HCI_MANUFACTURER_NAME_CONEXANT_SYSTEMS_INC =                             0x001C,
    HCI_MANUFACTURER_NAME_QUALCOMM =                                         0x001D,
    HCI_MANUFACTURER_NAME_INVENTEL =                                         0x001E,
    HCI_MANUFACTURER_NAME_AVM_BERLIN =                                       0x001F,
    HCI_MANUFACTURER_NAME_BANDSPEED_INC =                                    0x0020,
    HCI_MANUFACTURER_NAME_MANSELLA_LTD =                                     0x0021,
    HCI_MANUFACTURER_NAME_NEC_CORPORATION =                                  0x0022,
    HCI_MANUFACTURER_NAME_WAVEPLUS_TECHNOLOGY_CO_LTD =                       0x0023,
    HCI_MANUFACTURER_NAME_ALCATEL =                                          0x0024,
    HCI_MANUFACTURER_NAME_PHILIPS_SEMICONDUCTORS =                           0x0025,
    HCI_MANUFACTURER_NAME_C_TECHNOLOGIES =                                   0x0026,
    HCI_MANUFACTURER_NAME_OPEN_INTERFACE =                                   0x0027,
    HCI_MANUFACTURER_NAME_R_F_MICRO_DEVICES =                                0x0028,
    HCI_MANUFACTURER_NAME_HITACHI_LTD =                                      0x0029,
    HCI_MANUFACTURER_NAME_SYMBOL_TECHNOLOGIES_INC =                          0x002A,
    HCI_MANUFACTURER_NAME_TENOVIS =                                          0x002B,
    HCI_MANUFACTURER_NAME_MACRONIX_INTERNATIONAL_CO_LTD =                    0x002C,
    HCI_MANUFACTURER_NAME_GCT_SEMICONDUCTOR =                                0x002D,
    HCI_MANUFACTURER_NAME_NORWOOD_SYSTEMS =                                  0x002E,
    HCI_MANUFACTURER_NAME_MEWTEL_TECHNOLOGY_INC =                            0x002F,
    HCI_MANUFACTURER_NAME_ST_MICROELECTRONICS =                              0x0030,
    HCI_MANUFACTURER_NAME_SYNOPSYS =                                         0x0031,
    HCI_MANUFACTURER_NAME_REDM_COMMUNICATIONS_LTD =                          0x0032,
    HCI_MANUFACTURER_NAME_COMMIL_LTD =                                       0x0033,
    HCI_MANUFACTURER_NAME_COMPUTER_ACCESS_TECHNOLOGY_CORPORATION_CATC =      0x0034,
    HCI_MANUFACTURER_NAME_ECLIPSE_HQ_ESPANA_SL =                             0x0035,
    HCI_MANUFACTURER_NAME_RENESAS_TECHNOLOGY_CORP =                          0x0036,
    HCI_MANUFACTURER_NAME_MOBILIAN_CORPORATION =                             0x0037,
    HCI_MANUFACTURER_NAME_TERAX =                                            0x0038,
    HCI_MANUFACTURER_NAME_INTEGRATED_SYSTEM_SOLUTION_CORP =                  0x0039,
    HCI_MANUFACTURER_NAME_MATSUSHITA_ELECTRIC_INDUSTRIAL_CO_LTD =            0x003A,
    HCI_MANUFACTURER_NAME_GENNUM_CORPORATION =                               0x003B,
    HCI_MANUFACTURER_NAME_RESEARCH_IN_MOTION =                               0x003C,
    HCI_MANUFACTURER_NAME_IPEXTREME_INC =                                    0x003D,
    HCI_MANUFACTURER_NAME_SYSTEMS_AND_CHIPS_INC =                            0x003E,
    HCI_MANUFACTURER_NAME_BLUETOOTH_SIG_INC =                                0x003F,
    HCI_MANUFACTURER_NAME_SEIKO_EPSON_CORPORATION =                          0x0040,
    HCI_MANUFACTURER_NAME_INTEGRATED_SILICON_SOLUTION_TAIWAN_INC =           0x0041,
    HCI_MANUFACTURER_NAME_CONWISE_TECHNOLOGY_CORPORATION_LTD =               0x0042,
    HCI_MANUFACTURER_NAME_PARROT_SA =                                        0x0043,
    HCI_MANUFACTURER_NAME_SOCKET_MOBILE =                                    0x0044,
    HCI_MANUFACTURER_NAME_ATHEROS_COMMUNICATIONS_INC =                       0x0045,
    HCI_MANUFACTURER_NAME_MEDIATEK_INC =                                     0x0046,
    HCI_MANUFACTURER_NAME_BLUEGIGA =                                         0x0047,
    HCI_MANUFACTURER_NAME_MARVELL_TECHNOLOGY_GROUP_LTD =                     0x0048,
    HCI_MANUFACTURER_NAME_3DSP_CORPORATION =                                 0x0049,
    HCI_MANUFACTURER_NAME_ACCEL_SEMICONDUCTOR_LTD =                          0x004A,
    HCI_MANUFACTURER_NAME_CONTINENTAL_AUTOMOTIVE_SYSTEMS =                   0x004B,
    HCI_MANUFACTURER_NAME_APPLE_INC =                                        0x004C,
    HCI_MANUFACTURER_NAME_STACCATO_COMMUNICATIONS_INC =                      0x004D,
    HCI_MANUFACTURER_NAME_AVAGO_TECHNOLOGIES =                               0x004E,
    HCI_MANUFACTURER_NAME_APT_LICENSING_LTD =                                0x004F,
    HCI_MANUFACTURER_NAME_SIRF_TECHNOLOGY_INC =                              0x0050,
    HCI_MANUFACTURER_NAME_TZERO_TECHNOLOGIES_INC =                           0x0051,
    HCI_MANUFACTURER_NAME_J_M_CORPORATION =                                  0x0052,
    HCI_MANUFACTURER_NAME_FREE2MOVE_AB =                                     0x0053,
    HCI_MANUFACTURER_NAME_3DIJOY_CORPORATION =                               0x0054,
    HCI_MANUFACTURER_NAME_PLANTRONICS_INC =                                  0x0055,
    HCI_MANUFACTURER_NAME_SONY_ERICSSON_MOBILE_COMMUNICATIONS =              0x0056,
    HCI_MANUFACTURER_NAME_HARMAN_INTERNATIONAL_INDUSTRIES_INC =              0x0057,
    HCI_MANUFACTURER_NAME_VIZIO_INC =                                        0x0058,
    HCI_MANUFACTURER_NAME_NORDIC_SEMICONDUCTOR_ASA =                         0x0059,
    HCI_MANUFACTURER_NAME_EM_MICROELECTRONIC_MARIN_SA =                      0x005A,
    HCI_MANUFACTURER_NAME_RALINK_TECHNOLOGY_CORPORATION =                    0x005B,
    HCI_MANUFACTURER_NAME_BELKIN_INTERNATIONAL_INC =                         0x005C,
    HCI_MANUFACTURER_NAME_REALTEK_SEMICONDUCTOR_CORPORATION =                0x005D,
    HCI_MANUFACTURER_NAME_STONESTREET_ONE_LLC =                              0x005E,
    HCI_MANUFACTURER_NAME_WICENTRIC_INC =                                    0x005F,
    HCI_MANUFACTURER_NAME_RIVIERAWAVES_SAS =                                 0x0060,
    HCI_MANUFACTURER_NAME_RDA_MICROELECTRONICS =                             0x0061,
    HCI_MANUFACTURER_NAME_GIBSON_GUITARS =                                   0x0062,
    HCI_MANUFACTURER_NAME_MICOMMAND_INC =                                    0x0063,
    HCI_MANUFACTURER_NAME_BAND_XI_INTERNATIONAL_LLC =                        0x0064,
    HCI_MANUFACTURER_NAME_HEWLETT_PACKARD_COMPANY =                          0x0065,
    HCI_MANUFACTURER_NAME_9SOLUTIONS_OY =                                    0x0066,
    HCI_MANUFACTURER_NAME_GN_NETCOM_AS =                                     0x0067,
    HCI_MANUFACTURER_NAME_GENERAL_MOTORS =                                   0x0068,
    HCI_MANUFACTURER_NAME_A_D_ENGINEERING_INC =                              0x0069,
    HCI_MANUFACTURER_NAME_MINDTREE_LTD =                                     0x006A,
    HCI_MANUFACTURER_NAME_POLAR_ELECTRO_OY =                                 0x006B,
    HCI_MANUFACTURER_NAME_IOP_RESERVE =                                      0xFFFF
} tHCI_Manufacturer_Name;

/*---------------------------------------------------------------------------------*/
/*                         [201][LMP_Subversion][Val][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Version_Information                (0x1001) */
/* Event                    Read_Remote_Version_Information_Complete      (0x000c) */
/* Subversion of the Current LMP or PAL in the Controller. This value is
   implementation dependent. */

/*---------------------------------------------------------------------------------*/
/*                           [202][Page Number][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  Read_Remote_Extended_Features                 (0x041c) */
/* Request,Return           Read_Local_Extended_Features                  (0x1004) */
/* Event                    Read_Remote_Extended_Features_Complete        (0x0023) */
/* 0x00 Requests the normal LMP features as returned by the
   Read_Remote_Supported_Features command,0x01-0xFF Return the corresponding page
   of features */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                         [203][Max Page Number][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Extended_Features                  (0x1004) */
/* Event                    Read_Remote_Extended_Features_Complete        (0x0023) */
/* The highest features page number which contains non-zero bits for the local
   device */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                               [204][bd][Val][L:6]                               */
/*---------------------------------------------------------------------------------*/
/* Request                  Create_Connection                             (0x0405) */
/* Request,Return           Create_Connection_Cancel                      (0x0408) */
/* Request                  Accept_Connection_Request                     (0x0409) */
/* Request                  Reject_Connection_Request                     (0x040a) */
/* Request,Return           Link_Key_Request_Reply                        (0x040b) */
/* Request,Return           Link_Key_Request_Negative_Reply               (0x040c) */
/* Request,Return           PIN_Code_Request_Reply                        (0x040d) */
/* Request,Return           PIN_Code_Request_Negative_Reply               (0x040e) */
/* Request                  Remote_Name_Request                           (0x0419) */
/* Request,Return           Remote_Name_Request_Cancel                    (0x041a) */
/* Request                  Accept_Synchronous_Connection_Request         (0x0429) */
/* Request                  Reject_Synchronous_Connection_Request         (0x042a) */
/* Request,Return           IO_Capability_Request_Reply                   (0x042b) */
/* Request,Return           User_Confirmation_Request_Reply               (0x042c) */
/* Request,Return           User_Confirmation_Request_Negative_Reply      (0x042d) */
/* Request,Return           User_Passkey_Request_Reply                    (0x042e) */
/* Request,Return           User_Passkey_Request_Negative_Reply           (0x042f) */
/* Request,Return           Remote_OOB_Data_Request_Reply                 (0x0430) */
/* Request,Return           Remote_OOB_Data_Request_Negative_Reply        (0x0433) */
/* Request,Return           IO_Capability_Request_Negative_Reply          (0x0434) */
/* Request                  Switch_Role                                   (0x080b) */
/* Request                  Read_Stored_Link_Key                          (0x0c0d) */
/* Request                  Write_Stored_Link_Key                         (0x0c11) */
/* Request                  Delete_Stored_Link_Key                        (0x0c12) */
/* Request,Return           Send_Keypress_Notification                    (0x0c60) */
/* Return                   Read_BD_ADDR                                  (0x1009) */
/* Event                    Inquiry_Result                                (0x0002) */
/* Event                    Connection_Complete                           (0x0003) */
/* Event                    Connection_Request                            (0x0004) */
/* Event                    Remote_Name_Request_Complete                  (0x0007) */
/* Event                    Role_Change                                   (0x0012) */
/* Event                    Return_Link_Keys                              (0x0015) */
/* Event                    PIN_Code_Request                              (0x0016) */
/* Event                    Link_Key_Request                              (0x0017) */
/* Event                    Link_Key_Notification                         (0x0018) */
/* Event                    Page_Scan_Mode_Change                         (0x001f) */
/* Event                    Page_Scan_Repetition_Mode_Change              (0x0020) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* Event                    IO_Capability_Request                         (0x0031) */
/* Event                    IO_Capability_Response                        (0x0032) */
/* Event                    User_Confirmation_Request                     (0x0033) */
/* Event                    User_Passkey_Request                          (0x0034) */
/* Event                    Remote_OOB_Data_Request                       (0x0035) */
/* Event                    Simple_Pairing_Complete                       (0x0036) */
/* Event                    User_Passkey_Notification                     (0x003b) */
/* Event                    Keypress_Notification                         (0x003c) */
/* Event                    Remote_Host_Supported_Features_Notification   (0x003d) */
/* BD_ADDR of the Device */

/*---------------------------------------------------------------------------------*/
/*                    [205][HC_ACL_Data_Packet_Length][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Buffer_Size                              (0x1005) */
/* Maximum length (in octets) of the data portion of each HCI ACL Data Packet that
   the Controller is able to accept */

/*---------------------------------------------------------------------------------*/
/*                [206][HC_Synchronous_Data_Packet_Length][Val][L:2]               */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Buffer_Size                              (0x1005) */
/* Maximum length (in octets) of the data portion of each HCI Synchronous Data
   Packet that the Controller is able to accept */

/*---------------------------------------------------------------------------------*/
/*                  [207][HC_Total_Num_ACL_Data_Packets][Val][L:2]                 */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Buffer_Size                              (0x1005) */
/* Total number of HCI ACL Data Packets that can be stored in the data buffers of
   the Controller */

/*---------------------------------------------------------------------------------*/
/*              [208][HC_Total_Num_Synchronous_Data_Packets][Val][L:2]             */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Buffer_Size                              (0x1005) */
/* Total number of HCI Synchronous Data Packets that can be stored in the data
   buffers of the Controller */

/*---------------------------------------------------------------------------------*/
/*                   [209][Max_ACL_Data_Packet_Length][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Data_Block_Size                          (0x100a) */
/* Maximum length (in octets) of the data portion of an HCI ACL Data Packet that
   the Controller is able to accept for transmission. For AMP Controllers this
   always equals to Max_PDU_Size */

/*---------------------------------------------------------------------------------*/
/*                        [210][Data_Block_Length][Val][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Data_Block_Size                          (0x100a) */
/* Maximum length (in octets) of the data portion of each HCI ACL Data Packet that
   the Controller is able to hold in each of its data block buffers */

/*---------------------------------------------------------------------------------*/
/*                      [211][Total_Num_Data_Blocks][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Data_Block_Size                          (0x100a) */
/* Event                    Number_Of_Completed_Data_Blocks               (0x0048) */
/* Total number of data block buffers available in the Controller for the storage
   of data packets scheduled for transmission */

/*---------------------------------------------------------------------------------*/
/*                             [212][Handle][Val][L:2]                             */
/*---------------------------------------------------------------------------------*/
/* Request                  Enhanced_Flush                                (0x0c5f) */
/* Request,Return           Read_Failed_Contact_Counter                   (0x1401) */
/* Request,Return           Reset_Failed_Contact_Counter                  (0x1402) */
/* Request,Return           Read_Link_Quality                             (0x1403) */
/* Request,Return           Read_RSSI                                     (0x1405) */
/* Event                    Flush_Occurred                                (0x0011) */
/* Event                    QoS_Violation                                 (0x001e) */
/* Event                    Enhanced_Flush_Complete                       (0x0039) */
/* Event                    Number_Of_Completed_Data_Blocks               (0x0048) */
/* Connection_Handle if the receiving Controller is a BR/EDR Controller.
   Logical_Link_Handle, if the receiving Controller is an AMP Controller,
   identifying the logical link to be changed */
/* Range: 0x0 ~ 0xeff */

/*---------------------------------------------------------------------------------*/
/*                     [213][Failed_Contact_Counter][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Failed_Contact_Counter                   (0x1401) */
/* The Failed_Contact_Counter records the number of consecutive incidents in which
   either the  local or remote device did not respond after the flush timeout had
   expired, and the L2CAP PDU that was currently being transmitted was
   automatically flushed. When this occurs, the Failed_Contact_Counter is
   incremented by 1.The Failed Contact Counter is maintained for each
   Connection_Handle and Logical_Link_Handle */

/*---------------------------------------------------------------------------------*/
/*                          [214][Link_Quality][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Link_Quality                             (0x1403) */
/* The current quality of the Link connection between the local device and the
   remote device specified by the Handle.The higher the value, the better the link
   quality is */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                              [215][RSSI][Val][L:1]                              */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_RSSI                                     (0x1405) */
/* Event                    Inquiry_Result_with_RSSI                      (0x0022) */
/* Event                    Extended_Inquiry_Result                       (0x002f) */
/* BR/EDR Range: -128 to127 (signed integer),Units: dB,AMP: Range: AMP type
   specific (signed integer),Units: dBm,LE:Range: -127 to 20, 127 (signed integer)
   RSSI is not available,Units: dBm */

/*---------------------------------------------------------------------------------*/
/*                            [216][AFH_Mode][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_AFH_Channel_Map                          (0x1406) */
typedef enum _tHCI_AFH_Mode
{
    HCI_AFH_MODE_AFH_DISABLED =                                              0x00,
    HCI_AFH_MODE_AFH_ENABLED =                                               0x01
} tHCI_AFH_Mode;

/*---------------------------------------------------------------------------------*/
/*                        [217][AFH_Channel_Map][Val][L:10]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_AFH_Channel_Map                          (0x1406) */
/* If AFH_Mode is AFH enabled then this parameter contains 79 1-bit fields,
   otherwise the contents are reserved.The nth such field (in the range 0 to 78)
   contains the value for channel n:Channel n is unused = 0 Channel n is used = 1
   Range: 0x00000000000000000000-0x7FFFFFFFFFFFFFFFFFFF
   (0x80000000000000000000-0xFFFFFFFFFFFFFFFFFFFF Reserved for future use) */

/*---------------------------------------------------------------------------------*/
/*                          [218][Which_Clock][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  Read_Clock                                    (0x1407) */
/* Connection_Handle does not have to be valid for Local Clock, Connection_Handle
   shall be valid for Piconet Clock, 0x02-0xFF are reserved. */
typedef enum _tHCI_Which_Clock
{
    HCI_WHICH_CLOCK_LOCAL =                                                  0x00,
    HCI_WHICH_CLOCK_PICONET =                                                0x01
} tHCI_Which_Clock;

/*---------------------------------------------------------------------------------*/
/*                              [219][Clock][Val][L:4]                             */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Clock                                    (0x1407) */
/* Bluetooth clock of the device requested with bits 1 and 0 set to 0b. */

/*---------------------------------------------------------------------------------*/
/*                           [220][Slot_Offset][Val][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* 0-1249 us, Other values reserved for future use. */

/*---------------------------------------------------------------------------------*/
/*                            [221][Accuracy][Time][L:2]                           */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Clock                                    (0x1407) */
/* +/- maximum Bluetooth Clock error. Value of 0xFFFF means Unknown.Accuracy = +/-
   N * 0.3125 msec (1 Bluetooth Clock),Range for N: 0x0000 - 0xFFFE,Time Range for
   N: 0 - 20479.375 msec */
/* Range: 0x0 ~ 0xfffe */
/* TimeRange[0.312500]: 0.000000 ~ 20479.375000 */

/*---------------------------------------------------------------------------------*/
/*                            [222][Key_Size][Val][L:1]                            */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Encryption_Key_Size                      (0x1408) */
/* Encryption key size */

/*---------------------------------------------------------------------------------*/
/*                           [223][AMP_Status][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_AMP_Status
{
    HCI_AMP_STATUS_AVAILABLE_BUT_POWERED_DOWN =                              0x00,
    HCI_AMP_STATUS_ONLY_USED_BY_BLUETOOTH =                                  0x01,
    HCI_AMP_STATUS_NO_CAPACITY =                                             0x02,
    HCI_AMP_STATUS_LOW_CAPACITY =                                            0x03,
    HCI_AMP_STATUS_MEDIUM_CAPACITY =                                         0x04,
    HCI_AMP_STATUS_HIGH_CAPACITY =                                           0x05,
    HCI_AMP_STATUS_FULL_CAPACITY =                                           0x06
} tHCI_AMP_Status;

/*---------------------------------------------------------------------------------*/
/*                         [224][Total_Bandwidth][Val][L:4]                        */
/*---------------------------------------------------------------------------------*/
/* An upper bound on the total data rate that can be achieved by the AMP over HCI.
   It accounts for the total bandwidth provided by the HCI transport. No sustained
   combination of transmit and receive operations shall exceed this value. This
   can be used to help in AMP selection and admission control. Expressed in kbps */

/*---------------------------------------------------------------------------------*/
/*                    [225][Max_Guaranteed_Bandwidth][Val][L:4]                    */
/*---------------------------------------------------------------------------------*/
/* An upper bound on the maximum data the AMP can guarantee for a single logical
   link over HCI. Any request made by an application above this threshold would be
   rejected. It accounts for any bandwidth limitations of the HCI transport. No
   sustained combination of transmit and receive operations shall exceed this
   value. This can be used to help in AMP selection and admission control.
   Expressed in kbps */

/*---------------------------------------------------------------------------------*/
/*                           [226][Min_Latency][Val][L:4]                          */
/*---------------------------------------------------------------------------------*/
/* A lower bound on the latency in microseconds that the AMP can guarantee for a
   logical channel. It accounts for the minimum latency of the HCI transport. This
   can be used to help in AMP selection and admission control */

/*---------------------------------------------------------------------------------*/
/*                          [227][Max_PDU_Size][Val][L:4]                          */
/*---------------------------------------------------------------------------------*/
/* An upper bound on the size of L2CAP PDU which may be provided for transmission
   or reception on this AMP. The Host shall not require the AMP to transport L2CAP
   PDUs larger than this value. Expressed in octets. The Maximum PDU Size
   parameter described in [Vol 3] Part A, Section 5.4 for any connection over this
   AMP should not exceed this value */

/*---------------------------------------------------------------------------------*/
/*                        [228][PAL_Capabilities][Mask][L:2]                       */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_PAL_Capabilities
{
    HCI_PAL_CAPABILITIES_SERVICE_TYPE_GUARANTEED_IS_SUPPORTED_BY_PAL =       0x01
} tHCI_PAL_Capabilities;

/*---------------------------------------------------------------------------------*/
/*                        [229][Max_Flush_Timeout][Val][L:4]                       */
/*---------------------------------------------------------------------------------*/
/* Maximum time period, in microseconds, which the AMP device uses to attempt to
   transmit a frame on a Guaranteed Logical Link. If the Controller is configured
   to retry frames for an unbounded time (i.e. there is no flushing at all), then
   it shall set this value to 0xFFFFFFFF */

/*---------------------------------------------------------------------------------*/
/*                    [230][Best_Effort_Flush_Timeout][Val][L:4]                   */
/*---------------------------------------------------------------------------------*/
/* The typical time period, in microseconds, which the AMP device may use to
   attempt to transmit a frame on a Best Effort Logical Link. The value shall not
   exceed the value given in Max_Flush_Timeout.If the Controller is configured to
   retry frames for an unbounded time (i.e. there is no flushing at all), then it
   shall set this value to 0xFFFFFFFF */

/*---------------------------------------------------------------------------------*/
/*                          [231][Length_So_Far][Val][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Set Length_So_Far to 0 for the first fragment. Increment parameter by the length
   of the previous fragment, for each subsequent call */

/*---------------------------------------------------------------------------------*/
/*                      [232][Max_AMP_ASSOC_Length][Val][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* AMP_ASSOC maximum length for this local AMP Controller. For use with Read and
   Write AMP_ASSOC commands [Section 7.5.8 and Section 7.5.9]. This value is sent
   to the remote AMP Manager in the AMP Get Info Response */

/*---------------------------------------------------------------------------------*/
/*                   [233][AMP_ASSOC_Remaining_Length][Val][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* Length, in octets, of the remainder of the AMP_ASSOC, including this fragment.
   Max_AMP_ASSOC_Length as reported in Read_Local_AMP_Info command. */

/*---------------------------------------------------------------------------------*/
/*                       [234][AMP_ASSOC_fragment][Val][L:0]                       */
/*---------------------------------------------------------------------------------*/
/* A fragment of the AMP_ASSOC structure created by a remote AMP of the same
   Controller type.The fragment length shall be 248 bytes for all but the last
   fragment */

/*---------------------------------------------------------------------------------*/
/*                         [235][Loopback_Mode][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Loopback_Mode                            (0x1801) */
/* Request                  Write_Loopback_Mode                           (0x1802) */
typedef enum _tHCI_Loopback_Mode
{
    HCI_LOOPBACK_MODE_NO_LOOPBACK_MODE_ENABLED =                             0x00,
    HCI_LOOPBACK_MODE_ENABLE_LOCAL_LOOPBACK =                                0x01,
    HCI_LOOPBACK_MODE_ENABLE_REMOTE_LOOPBACK =                               0x02
} tHCI_Loopback_Mode;

/*---------------------------------------------------------------------------------*/
/*                   [236][Simple_Pairing_Debug_Mode][Enum][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Request                  Write_Simple_Pairing_Debug_Mode               (0x1804) */
typedef enum _tHCI_Simple_Pairing_Debug_Mode
{
    HCI_SIMPLE_PAIRING_DEBUG_MODE_DISABLED_DEFAULT =                         0x00,
    HCI_SIMPLE_PAIRING_DEBUG_MODE_ENABLED =                                  0x01
} tHCI_Simple_Pairing_Debug_Mode;

/*---------------------------------------------------------------------------------*/
/*                            [237][Reports][Enum][L:1]                            */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Reports
{
    HCI_REPORTS_DISABLE =                                                    0x00,
    HCI_REPORTS_ENABLE =                                                     0x01
} tHCI_Reports;

/*---------------------------------------------------------------------------------*/
/*                         [238][Test_Parameters][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Controller Type */

/*---------------------------------------------------------------------------------*/
/*                           [239][Link_Type][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Event                    Connection_Complete                           (0x0003) */
/* Event                    Connection_Request                            (0x0004) */
/* Event                    Data_Buffer_Overflow                          (0x001a) */
/* Event                    Synchronous_Connection_Complete               (0x002c) */
typedef enum _tHCI_Link_Type
{
    HCI_LINK_TYPE_SCO =                                                      0x00,
    HCI_LINK_TYPE_ACL =                                                      0x01,
    HCI_LINK_TYPE_ESCO =                                                     0x02,
    HCI_LINK_TYPE_PHY =                                                      0xC0,
    HCI_LINK_TYPE_LOG =                                                      0xC1,
    HCI_LINK_TYPE_LE =                                                       0xC2
} tHCI_Link_Type;

/*---------------------------------------------------------------------------------*/
/*                         [240][Local_Name][String][L:248]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  Write_Local_Name                              (0x0c13) */
/* Return                   Read_Local_Name                               (0x0c14) */
/* A UTF-8 encoded User-Friendly Descriptive Name for the device.If the name
   contained in the parameter is shorter than 248 octets, the end of the name is
   indicated by a NULL octet (0x00), and the following octets (to fill up 248
   octets, which is the length of the parameter) do not have valid values.Null
   terminated Zero length String. Default */

/*---------------------------------------------------------------------------------*/
/*                        [241][Remote_Name][String][L:248]                        */
/*---------------------------------------------------------------------------------*/
/* Event                    Remote_Name_Request_Complete                  (0x0007) */
/* A UTF-8 encoded user-friendly descriptive name for the remote device. If the
   name contained in the parameter is shorter than 248 octets, the end of the name
   is indicated by a NULL octet (0x00), and the following octets (to fill up 248
   octets, which is the length of the parameter) do not have valid values */

/*---------------------------------------------------------------------------------*/
/*                           [242][Token_Rate][Val][L:4]                           */
/*---------------------------------------------------------------------------------*/
/* Request                  QoS_Setup                                     (0x0807) */
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Token Rate in octets per second */

/*---------------------------------------------------------------------------------*/
/*                        [243][Token Bucket Size][Val][L:4]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Token Bucket Size in octets */

/*---------------------------------------------------------------------------------*/
/*                         [244][Peak_Bandwidth][Val][L:4]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  QoS_Setup                                     (0x0807) */
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Peak Bandwidth in octets per second */

/*---------------------------------------------------------------------------------*/
/*                             [245][Latency][Val][L:4]                            */
/*---------------------------------------------------------------------------------*/
/* Request                  QoS_Setup                                     (0x0807) */
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Latency in microseconds */

/*---------------------------------------------------------------------------------*/
/*                         [246][Delay_Variation][Val][L:4]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  QoS_Setup                                     (0x0807) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Delay Variation in microseconds */

/*---------------------------------------------------------------------------------*/
/*                     [247][Num_HCI_Command_Packets][Val][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Event                    Command_Complete                              (0x000e) */
/* Event                    Command_Status                                (0x000f) */
/* The Number of HCI command packets which are allowed to be sent to the Controller
   from the Host */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                         [248][Command_Opcode][Val][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Event                    Command_Complete                              (0x000e) */
/* Event                    Command_Status                                (0x000f) */
/* Opcode of the command which caused this event and is pending completion */

/*---------------------------------------------------------------------------------*/
/*                        [249][Return_Parameters][Val][L:X]                       */
/*---------------------------------------------------------------------------------*/
/* Event                    Command_Complete                              (0x000e) */
/* This is the return parameter(s) for the command specified in the Command_Opcode
   event parameter. See each commands definition for the list of return
   parameters associated with that command */

/*---------------------------------------------------------------------------------*/
/*                          [250][Hardware_Code][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Event                    Hardware_Error                                (0x0010) */
/* These Hardware_Codes will be implementation-specific, and can be assigned to
   indicate various hardware problems. */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                   [251][HC_Num_Of_Completed_Packets][Val][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* Event                    Number_Of_Completed_Packets                   (0x0013) */
/* The number of HCI Data Packets that have been completed (transmitted or flushed)
   for the associated Connection_Handle since the previous time the event was
   returned. */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                          [252][Current_Mode][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Event                    Mode_Change                                   (0x0014) */
typedef enum _tHCI_Current_Mode
{
    HCI_CURRENT_MODE_ACTIVE =                                                0x00,
    HCI_CURRENT_MODE_HOLD =                                                  0x01,
    HCI_CURRENT_MODE_SNIFF =                                                 0x02,
    HCI_CURRENT_MODE_PARK_STATE =                                            0x03
} tHCI_Current_Mode;

/*---------------------------------------------------------------------------------*/
/*                            [253][Interval][Time][L:2]                           */
/*---------------------------------------------------------------------------------*/
/* Event                    Mode_Change                                   (0x0014) */
/* Hold:Number of Baseband slots to wait in Hold Mode.Hold Interval = N * 0.625
   msec (1 Baseband slot) Range for N: 0x0002-0xFFFE Time Range: 1.25 msec-40.9
   sec Sniff:Number of Baseband slots between sniff anchor points. Time between
   sniff anchor points = N * 0.625 msec (1 Baseband slot)Range for N:
   0x0002-0xFFFE Time Range: 1.25 msec-40.9 sec Park: Number of Baseband slots
   between consecutive beacons.Interval Length = N * 0.625 msec (1 Baseband slot)
   Range for N: 0x0002-0xFFFE Time Range: 1.25 msec-40.9 Seconds */
/* Range: 0x2 ~ 0xfffe */
/* TimeRange[0.625000]: 1.250000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                            [254][Link_Key][Val][L:16]                           */
/*---------------------------------------------------------------------------------*/
/* Request                  Link_Key_Request_Reply                        (0x040b) */
/* Request                  Write_Stored_Link_Key                         (0x0c11) */
/* Event                    Return_Link_Keys                              (0x0015) */
/* Event                    Link_Key_Notification                         (0x0018) */
/* The Controller can store a limited number of link keys for other BR/EDR
   Controllers. Link keys are shared between two BR/EDR Controllers, and are used
   for all security transactions between the two BR/EDR Controllers. A Host device
   may have additional storage capabilities, which can be used to save additional
   link keys to be reloaded to the BR/EDR Controller when needed. A Link Key is
   associated with a BD_ADDR */

/*---------------------------------------------------------------------------------*/
/*                            [255][Key_Type][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Event                    Link_Key_Notification                         (0x0018) */
/* 0x04 When Secure_Connections_Host_Support is disabled: Unauthenticated
   Combination Key generated from P192 or P256; When
   Secure_Connections_Host_Support is enabled: Unauthenticated Combination Key
   generated from P192 0x05 When Secure_Connections_Host_Support is
   disabled:Authenticated Combination Keygenerated from P192 or P256; When
   Secure_Connections_Host_Support is enabled: Authenticated Combination Key
   generated from P192; 0x07    Unauthenticated Combination Key generated from P256;
   0x08 Authenticated Combination Key generated from P256 */
typedef enum _tHCI_Key_Type
{
    HCI_KEY_TYPE_COMBINATION_KEY =                                           0x00,
    HCI_KEY_TYPE_LOCAL_UNIT_KEY =                                            0x01,
    HCI_KEY_TYPE_REMOTE_UNIT_KEY =                                           0x02,
    HCI_KEY_TYPE_DEBUG_COMBINATION_KEY =                                     0x03,
    HCI_KEY_TYPE_UNAUTHENTICATED_COMBINATION_KEY =                           0x04,
    HCI_KEY_TYPE_AUTHENTICATED_COMBINATION_KEY =                             0x05,
    HCI_KEY_TYPE_CHANGED_COMBINATION_KEY =                                   0x06,
    HCI_KEY_TYPE_UNAUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256 =       0x07,
    HCI_KEY_TYPE_AUTHENTICATED_COMBINATION_KEY_GENERATED_FROM_P256 =         0x08
} tHCI_Key_Type;

/*---------------------------------------------------------------------------------*/
/*                       [256][HCI_Command_Packet][Val][L:X]                       */
/*---------------------------------------------------------------------------------*/
/* Event                    Loopback_Command                              (0x0019) */
/* HCI Command Packet, including header */

/*---------------------------------------------------------------------------------*/
/*                          [257][LMP_Max_Slots][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Event                    Max_Slots_Change                              (0x001b) */
/* 0x01,0x03,0x05,Maximum number of slots allowed to use for baseband packets */

/*---------------------------------------------------------------------------------*/
/*                              [258][Flags][Val][L:1]                             */
/*---------------------------------------------------------------------------------*/
/* Request                  QoS_Setup                                     (0x0807) */
/* Request                  Flow_Specification                            (0x0810) */
/* Event                    QoS_Setup_Complete                            (0x000d) */
/* Event                    Flow_Specification_Complete                   (0x0021) */
/* Reserved for future use */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                      [259][Transmission_Interval][Val][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Synchronous_Connection_Changed                (0x002d) */
/* Time between two consecutive eSCO instants measured in slots. Must be zero for
   SCO links */

/*---------------------------------------------------------------------------------*/
/*                      [260][Retransmission window][Val][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Synchronous_Connection_Changed                (0x002d) */
/* The size of the retransmission window measured in slots. Must be zero for SCO
   links */

/*---------------------------------------------------------------------------------*/
/*                        [261][Rx_Packet_Length][Val][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Synchronous_Connection_Changed                (0x002d) */
/* Length in bytes of the eSCO payload in the receive direction. Must be zero for
   SCO links */

/*---------------------------------------------------------------------------------*/
/*                        [262][Tx_Packet_Length][Val][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Event                    Synchronous_Connection_Complete               (0x002c) */
/* Event                    Synchronous_Connection_Changed                (0x002d) */
/* Length in bytes of the eSCO payload in the transmit direction. Must be zero for
   SCO links. */

/*---------------------------------------------------------------------------------*/
/*                            [263][Air Mode][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* Event                    Synchronous_Connection_Complete               (0x002c) */
typedef enum _tHCI_Air_Mode
{
    HCI_AIR_MODE_ULAW_LOG =                                                  0x00,
    HCI_AIR_MODE_ALAW_LOG =                                                  0x01,
    HCI_AIR_MODE_CVSD =                                                      0x02,
    HCI_AIR_MODE_TRANSPARENT_DATA =                                          0x03
} tHCI_Air_Mode;

/*---------------------------------------------------------------------------------*/
/*                      [264][Max_Transmit_Latency][Time][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Event                    Sniff_Subrating                               (0x002e) */
/* Maximum latency for data being transmitted from the local device to the remote
   device,Time Range: 0 sec - 40.9 sec */
/* Range: 0x0 ~ 0xfffe */
/* TimeRange[0.625000]: 0.000000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                      [265][Max_Receive_Latency][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Event                    Sniff_Subrating                               (0x002e) */
/* Maximum latency for data being received by the local device from the remote
   device,Time Range: 0 sec - 40.9 sec */
/* Range: 0x0 ~ 0xfffe */
/* TimeRange[0.625000]: 0.000000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                       [266][Min_Remote_Timeout][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Subrating                               (0x0811) */
/* Event                    Sniff_Subrating                               (0x002e) */
/* Minimum base sniff subrate timeout that the remote device may use Default:
   0x0000,Latency = N * 0.625 msec (1 Baseband slot),Range for N: 0x0000 - 0xFFFE,
  Time Range: 0 sec - 40.9 sec */
/* Range: 0x0 ~ 0xfffe */
/* TimeRange[0.625000]: 0.000000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                       [267][Min_Local_Timeout][Time][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  Sniff_Subrating                               (0x0811) */
/* Event                    Sniff_Subrating                               (0x002e) */
/* Minimum base sniff subrate timeout that the local device may use,Default: 0x0000,
  Latency = N * 0.625 msec (1 Baseband slot),Range for N: 0x0000 - 0xFFFE,Time
   Range: 0 sec - 40.9 sec */
/* Range: 0x0 ~ 0xfffe */
/* TimeRange[0.625000]: 0.000000 ~ 40958.750000 */

/*---------------------------------------------------------------------------------*/
/*                          [268][Numeric_Value][Val][L:4]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  User_Passkey_Request_Reply                    (0x042e) */
/* Event                    User_Confirmation_Request                     (0x0033) */
/* Numeric value (passkey) entered by user. Valid values are decimal 000000 -
   999999 */
/* Range: 0x0 ~ 0xf423f */

/*---------------------------------------------------------------------------------*/
/*                             [269][Passkey][Val][L:4]                            */
/*---------------------------------------------------------------------------------*/
/* Event                    User_Passkey_Notification                     (0x003b) */
/* Passkey to be displayed. Valid values are decimal 000000 - 999999 */
/* Range: 0x0 ~ 0xf423f */

/*---------------------------------------------------------------------------------*/
/*                        [270][Link_Loss_Reason][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Link_Loss_Reason
{
    HCI_LINK_LOSS_REASON_UNKNOWN =                                           0x00,
    HCI_LINK_LOSS_REASON_RANGE_RELATED =                                     0x01,
    HCI_LINK_LOSS_REASON_BANDWIDTH_RELATED =                                 0x02,
    HCI_LINK_LOSS_REASON_RESOLVING_CONFLICT =                                0x03,
    HCI_LINK_LOSS_REASON_INTERFERENCE =                                      0x04
} tHCI_Link_Loss_Reason;

/*---------------------------------------------------------------------------------*/
/*                          [271][TX_Flow_Spec][Val][L:16]                         */
/*---------------------------------------------------------------------------------*/
/* Extended Flow Specification value defining transmitted traffic */

/*---------------------------------------------------------------------------------*/
/*                          [272][RX_Flow_Spec][Val][L:16]                         */
/*---------------------------------------------------------------------------------*/
/* Extended Flow Specification value defining received traffic */

/*---------------------------------------------------------------------------------*/
/*                         [273][TX_Flow_Spec_ID][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Flow Spec ID identifying the logical link whose creation is being cancelled.
   This matches the ID field of the Tx_Flow_Spec in the matching Create or Accept
   Logical Link command */

/*---------------------------------------------------------------------------------*/
/*                    [274][Num_Of_Completed_Packets][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Event                    Number_Of_Completed_Data_Blocks               (0x0048) */
/* The number of HCI ACL Data Packets that have been completed (transmitted or
   flushed) for the associated Handle since the previous time that a Number Of
   Completed Data Blocks event provided information about this Handle */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                     [275][Num_Of_Completed_Blocks][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Event                    Number_Of_Completed_Data_Blocks               (0x0048) */
/* The number of data blocks that have been freed for the associated Handle since
   the previous time that a Number Of Completed Data Blocks event provided
   information about this Handle */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                          [276][Test Scenario][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* See the Test Commands section of the Protocol Adaptation Layer Functional
   Specification for the Controller type */

/*---------------------------------------------------------------------------------*/
/*                           [277][Event_type][Enum][L:4]                          */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_Event_type
{
    HCI_EVENT_TYPE_FRAMES_RECEIVED_REPORT =                                  0x00,
    HCI_EVENT_TYPE_FRAMES_RECEIVED_AND_BITS_IN_ERROR_REPORT =                0x01
} tHCI_Event_type;

/*---------------------------------------------------------------------------------*/
/*                        [278][Number_Of_Frames][Val][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Number of frames received so far */

/*---------------------------------------------------------------------------------*/
/*                     [279][Number_Of_Error_Frames][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Number of frames with errors received so far */

/*---------------------------------------------------------------------------------*/
/*                         [280][Number_Of_Bits][Val][L:4]                         */
/*---------------------------------------------------------------------------------*/
/* Number of bits received so far.Shall be set to 0x00000000 if the Event_type is
   not equal to 0x01 */

/*---------------------------------------------------------------------------------*/
/*                      [281][Number_Of_Error_Bits][Val][L:4]                      */
/*---------------------------------------------------------------------------------*/
/* Number of bit errors received so far.Shall be set to 0x00000000 if the
   Event_type is not equal to 0x01 */

/*---------------------------------------------------------------------------------*/
/*                          [282][Sub_EventCode][Val][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Event                    LE_Meta                                       (0x003e) */
/* Subevent code for LE event */

/*---------------------------------------------------------------------------------*/
/*                              [283][Param][Val][L:X]                             */
/*---------------------------------------------------------------------------------*/
/* Event                    LE_Meta                                       (0x003e) */
/* LEEvent                  LE_Advertising_Report                         (0x0002) */
/* LE Meta Event Param */

/*---------------------------------------------------------------------------------*/
/*                           [284][VendorData][Val][L:X]                           */
/*---------------------------------------------------------------------------------*/
/* Event                    Vendor                                        (0x00ff) */
/* Vendor Data */

/*---------------------------------------------------------------------------------*/
/*                       [285][Peer_Address_Type][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Add_Device_To_White_List                   (0x2011) */
/* Request                  LE_Remove_Device_From_White_List              (0x2012) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
typedef enum _tHCI_Peer_Address_Type
{
    HCI_PEER_ADDRESS_TYPE_PUBLIC_DEVICE_ADDRESS =                            0x00,
    HCI_PEER_ADDRESS_TYPE_RANDOM_DEVICE_ADDRESS =                            0x01
} tHCI_Peer_Address_Type;

/*---------------------------------------------------------------------------------*/
/*                        [286][Own_Address_Type][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* Request                  LE_Set_Scan_Parameters                        (0x200b) */
/* Request                  LE_Create_Connection                          (0x200d) */
typedef enum _tHCI_Own_Address_Type
{
    HCI_OWN_ADDRESS_TYPE_PUBLIC_DEVICE_ADDRESS =                             0x00,
    HCI_OWN_ADDRESS_TYPE_RANDOM_DEVICE_ADDRESS =                             0x01
} tHCI_Own_Address_Type;

/*---------------------------------------------------------------------------------*/
/*                      [287][Direct_Address_Type][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
typedef enum _tHCI_Direct_Address_Type
{
    HCI_DIRECT_ADDRESS_TYPE_PUBLIC_DEVICE_ADDRESS =                          0x00,
    HCI_DIRECT_ADDRESS_TYPE_RANDOM_DEVICE_ADDRESS =                          0x01
} tHCI_Direct_Address_Type;

/*---------------------------------------------------------------------------------*/
/*                          [288][Peer_Address][Val][L:6]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Add_Device_To_White_List                   (0x2011) */
/* Request                  LE_Remove_Device_From_White_List              (0x2012) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
/* Public Device Address or Random Device Address of the peer device */

/*---------------------------------------------------------------------------------*/
/*                         [289][Direct_Address][Val][L:6]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* Public Device Address or Random Device Address of the device to be connected */

/*---------------------------------------------------------------------------------*/
/*                         [290][Random_Address][Val][L:6]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Random_Address                         (0x2005) */
/* Random Device Address */

/*---------------------------------------------------------------------------------*/
/*                         [291][Conn_Interval][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
/* LEEvent                  LE_Connection_Update_Complete                 (0x0003) */
/* Connection interval used on this connection.Time = N * 1.25 msec,Time Range: 7.5
   msec to 4000 msec */
/* Range: 0x6 ~ 0xc80 */
/* TimeRange[1.250000]: 7.500000 ~ 4000.000000 */

/*---------------------------------------------------------------------------------*/
/*                      [292][Supervision_Timeout][Time][L:2]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
/* LEEvent                  LE_Connection_Update_Complete                 (0x0003) */
/* Connection supervision timeout.Time = N * 10 msec,Time Range: 100 msec to 32
   seconds */
/* Range: 0xa ~ 0xc80 */
/* TimeRange[10.000000]: 100.000000 ~ 32000.000000 */

/*---------------------------------------------------------------------------------*/
/*                     [293][Master_Clock_Accuracy][Enum][L:1]                     */
/*---------------------------------------------------------------------------------*/
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
typedef enum _tHCI_Master_Clock_Accuracy
{
    HCI_MASTER_CLOCK_ACCURACY_500_PPM =                                      0x00,
    HCI_MASTER_CLOCK_ACCURACY_250_PPM =                                      0x01,
    HCI_MASTER_CLOCK_ACCURACY_150_PPM =                                      0x02,
    HCI_MASTER_CLOCK_ACCURACY_100_PPM =                                      0x03,
    HCI_MASTER_CLOCK_ACCURACY_75_PPM =                                       0x04,
    HCI_MASTER_CLOCK_ACCURACY_50_PPM =                                       0x05,
    HCI_MASTER_CLOCK_ACCURACY_30_PPM =                                       0x06,
    HCI_MASTER_CLOCK_ACCURACY_20_PPM =                                       0x07
} tHCI_Master_Clock_Accuracy;

/*---------------------------------------------------------------------------------*/
/*                           [294][Num_Reports][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* LEEvent                  LE_Advertising_Report                         (0x0002) */
/* Number of responses in event */
/* Range: 0x1 ~ 0x19 */

/*---------------------------------------------------------------------------------*/
/*                           [295][Length_Data][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Length of the Data[i] field for each device which responded. */
/* Range: 0x0 ~ 0x1f */

/*---------------------------------------------------------------------------------*/
/*                              [296][Data][Val][L:X]                              */
/*---------------------------------------------------------------------------------*/
/* Length_Data[i] octets of advertising or scan response data */

/*---------------------------------------------------------------------------------*/
/*                          [297][LE_Features][Mask][L:8]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Read_Local_Supported_Features              (0x2003) */
/* LEEvent                  LE_Read_Remote_Used_Features_Complete         (0x0004) */
/* Bit Mask List of used LE features. For details see LE Link Layer specification */
typedef enum _tHCI_LE_Features
{
    HCI_LE_FEATURES_LE_ENCRYPTION =                                          0x01
} tHCI_LE_Features;

/*---------------------------------------------------------------------------------*/
/*                          [298][Random_Number][Val][L:8]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Rand                                       (0x2018) */
/* Request                  LE_Start_Encryption                           (0x2019) */
/* LEEvent                  LE_Long_Term_Key_Request                      (0x0005) */
/* 64 bit random number. */

/*---------------------------------------------------------------------------------*/
/*                     [299][Encryption_Diversifier][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Start_Encryption                           (0x2019) */
/* 16 bit encrypted diversifier. */

/*---------------------------------------------------------------------------------*/
/*                  [300][HC_LE_ACL_Data_Packet_Length][Val][L:2]                  */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Read_Buffer_Size                           (0x2002) */
/* 0x0000 No dedicated LE Buffer - use Read_Buffer_Size command. 0x0001 - 0xFFFF
   Maximum length (in octets) of the data portion of each HCI ACL Data Packet that
   the Controller is able to accept */
/* Range: 0x0 ~ 0xffff */

/*---------------------------------------------------------------------------------*/
/*                [301][HC_Total_Num_LE_ACL_Data_Packets][Val][L:1]                */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Read_Buffer_Size                           (0x2002) */
/* 0x00 No dedicated LE Buffer - use Read_Buffer_Size command.0x01 - 0xFF Total
   number of HCI ACL Data Packets that can be stored in the data buffers of the
   Controller */
/* Range: 0x0 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                    [302][Advertising_Interval_Min][Time][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* Minimum advertising interval for non-directed advertising.Default: N = 0x0800 (1.
  28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */
/* Range: 0x20 ~ 0x4000 */
/* TimeRange[0.625000]: 20.000000 ~ 10240.000000 */

/*---------------------------------------------------------------------------------*/
/*                    [303][Advertising_Interval_Max][Time][L:2]                   */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* Maximum advertising interval for non-directed advertising.Range: 0x0020 to
   0x4000 Default: N = 0x0800 (1.28 seconds) Time = N * 0.625 msec Time Range: 20
   ms to 10.24 sec */
/* Range: 0x20 ~ 0x4000 */
/* TimeRange[0.625000]: 20.000000 ~ 10240.000000 */

/*---------------------------------------------------------------------------------*/
/*                          [304][LEEvent_Type][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
typedef enum _tHCI_LEEvent_Type
{
    HCI_LEEVENT_TYPE_ADVERTISING_CONNECTABLE_UNDIRECTED =                    0x00,
    HCI_LEEVENT_TYPE_ADVERTISING_CONNECTABLE_DIRECTED =                      0x01,
    HCI_LEEVENT_TYPE_ADVERTISING_SCANNABLE_UNDIRECTED =                      0x02,
    HCI_LEEVENT_TYPE_ADVERTISING_NON_CONNECTABLE_UNDIRECTED =                0x03,
    HCI_LEEVENT_TYPE_SCAN_RESPONSE =                                         0x04
} tHCI_LEEvent_Type;

/*---------------------------------------------------------------------------------*/
/*                        [305][Advertising_Type][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* The Advertising_Type is used to determine the packet type that is used for
   advertising when advertising is enabled */
typedef enum _tHCI_Advertising_Type
{
    HCI_ADVERTISING_TYPE_CONNECTABLE_UNDIRECTED =                            0x00,
    HCI_ADVERTISING_TYPE_CONNECTABLE_DIRECTED =                              0x01,
    HCI_ADVERTISING_TYPE_SCANNABLE_UNDIRECTED =                              0x02,
    HCI_ADVERTISING_TYPE_NON_CONNECTABLE_UNDIRECTED =                        0x03
} tHCI_Advertising_Type;

/*---------------------------------------------------------------------------------*/
/*                    [306][Advertising_Channel_Map][Mask][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* The Advertising_Channel_Map is a bit field that indicates the advertising
   channels that shall be used when transmitting advertising packets. At least one
   channel bit shall be set in the Advertising_Channel_Map parameter. */
typedef enum _tHCI_Advertising_Channel_Map
{
    HCI_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_37_USE =                      0x01,
    HCI_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_38_USE =                      0x02,
    HCI_ADVERTISING_CHANNEL_MAP_ENABLE_CHANNEL_39_USE =                      0x04,
    HCI_ADVERTISING_CHANNEL_MAP_DEFAULT =                                    0x07
} tHCI_Advertising_Channel_Map;

/*---------------------------------------------------------------------------------*/
/*                   [307][Advertising_Filter_Policy][Enum][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Parameters                 (0x2006) */
/* The Advertising_Filter_Policy parameter shall be ignored when directed
   advertising is enabled */
typedef enum _tHCI_Advertising_Filter_Policy
{
    HCI_ADVERTISING_FILTER_POLICY_SCAN_ANY_CONNECT_ANY =                     0x00,
    HCI_ADVERTISING_FILTER_POLICY_SCAN_WHITE_LIST_CONNECT_ANY =              0x01,
    HCI_ADVERTISING_FILTER_POLICY_SCAN_ANY_CONNECT_WHITE_LIST =              0x02,
    HCI_ADVERTISING_FILTER_POLICY_SCAN_WHITE_LIST_CONNECT_WHITE_LIST =       0x03
} tHCI_Advertising_Filter_Policy;

/*---------------------------------------------------------------------------------*/
/*                      [308][Transmit_Power_Level][Val][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Transmit_Power_Level                     (0x0c2d) */
/* Return                   LE_Read_Advertising_Channel_Tx_Power          (0x2007) */
/* Size: 1 Octet (signed integer) Range: -20 to 10 Units: dBm Accuracy: +/- 4 dBm */

/*---------------------------------------------------------------------------------*/
/*                     [309][Advertising_Data_Length][Val][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Data                       (0x2008) */
/* The number of significant octets in the Advertising_Data */
/* Range: 0x0 ~ 0x1f */

/*---------------------------------------------------------------------------------*/
/*                        [310][Advertising_Data][Val][L:31]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertising_Data                       (0x2008) */
/* 31 octets of advertising data */

/*---------------------------------------------------------------------------------*/
/*                    [311][Scan_Response_Data_Length][Val][L:1]                   */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Response_Data                     (0x2009) */
/* The number of significant octets in the Scan_Response_Data */
/* Range: 0x0 ~ 0x1f */

/*---------------------------------------------------------------------------------*/
/*                       [312][Scan_Response_Data][Val][L:31]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Response_Data                     (0x2009) */
/* 31 octets of Scan_Response_Data */

/*---------------------------------------------------------------------------------*/
/*                       [313][Advertising_Enable][Enum][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Advertise_Enable                       (0x200a) */
/* The LE_Set_Advertise_Enable command is used to request the Controller to start
   or stop advertising. The Controller manages the timing of advertisements as per
   the advertising parameters given in the LE_Set_Advertising_Parameters command.
   The Controller shall continue advertising until the Host issues an
   LE_Set_Advertise_Enable command with Advertising_Enable set to 0x00
   (Advertising is disabled) or until a connection is created or until the
   Advertising is timed out due to Directed Advertising. In these cases,
   advertising is then disabled */
typedef enum _tHCI_Advertising_Enable
{
    HCI_ADVERTISING_ENABLE_DISABLED_DEFAULT =                                0x00,
    HCI_ADVERTISING_ENABLE_ENABLED =                                         0x01
} tHCI_Advertising_Enable;

/*---------------------------------------------------------------------------------*/
/*                          [314][LE_Scan_Type][Enum][L:1]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Parameters                        (0x200b) */
/* The LE_Scan_Type parameter controls the type of scan to perform */
typedef enum _tHCI_LE_Scan_Type
{
    HCI_LE_SCAN_TYPE_PASSIVE_SCANNING =                                      0x00,
    HCI_LE_SCAN_TYPE_ACTIVE_SCANNING =                                       0x01
} tHCI_LE_Scan_Type;

/*---------------------------------------------------------------------------------*/
/*                        [315][LE_Scan_Interval][Time][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Parameters                        (0x200b) */
/* Request                  LE_Create_Connection                          (0x200d) */
/* This is defined as the time interval from when the Controller started its last
   LE scan until it begins the subsequent LE scan. Default: 0x0010 (10 ms) Time =
   N * 0.625 msec Time Range: 2.5 msec to 10.24 seconds */
/* Range: 0x4 ~ 0x4000 */
/* TimeRange[0.625000]: 2.500000 ~ 10240.000000 */

/*---------------------------------------------------------------------------------*/
/*                         [316][LE_Scan_Window][Time][L:2]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Parameters                        (0x200b) */
/* Request                  LE_Create_Connection                          (0x200d) */
/* The duration of the LE scan. LE_Scan_Window shall be less than or equal to
   LE_Scan_Interval Default: 0x0010 (10 ms) Time = N * 0.625 msec Time Range: 2.5
   msec to 10240 msec */
/* Range: 0x4 ~ 0x4000 */
/* TimeRange[0.625000]: 2.500000 ~ 10240.000000 */

/*---------------------------------------------------------------------------------*/
/*                     [317][Scanning_Filter_Policy][Enum][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Parameters                        (0x200b) */
typedef enum _tHCI_Scanning_Filter_Policy
{
    HCI_SCANNING_FILTER_POLICY_ACCEPT_ALL =                                  0x00,
    HCI_SCANNING_FILTER_POLICY_ONLY_WHITE_LIST =                             0x01
} tHCI_Scanning_Filter_Policy;

/*---------------------------------------------------------------------------------*/
/*                         [318][LE_Scan_Enable][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Enable                            (0x200c) */
/* The LE_Set_Scan_Enable command is used to start scanning. Scanning is used to
   discover advertising devices nearby */
typedef enum _tHCI_LE_Scan_Enable
{
    HCI_LE_SCAN_ENABLE_SCANNING_DISABLED =                                   0x00,
    HCI_LE_SCAN_ENABLE_SCANNING_ENABLED =                                    0x01
} tHCI_LE_Scan_Enable;

/*---------------------------------------------------------------------------------*/
/*                       [319][Filter_Duplicates][Enum][L:1]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Scan_Enable                            (0x200c) */
/* The Filter_Duplicates parameter controls whether the Link Layer shall filter
   duplicate advertising reports to the Host, or if it shall generate advertising
   reports for each packet received */
typedef enum _tHCI_Filter_Duplicates
{
    HCI_FILTER_DUPLICATES_DUPLICATE_FILTERING_DISABLED =                     0x00,
    HCI_FILTER_DUPLICATES_DUPLICATE_FILTERING_ENABLED =                      0x01
} tHCI_Filter_Duplicates;

/*---------------------------------------------------------------------------------*/
/*                    [320][Initiator_Filter_Policy][Enum][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* The Initiator_Filter_Policy is used to determine whether the White List is used.
   If the White List is not used, the Peer_Address_Type and the Peer_Address
   parameters specify the address type and address of the advertising device to
   connect to. */
typedef enum _tHCI_Initiator_Filter_Policy
{
    HCI_INITIATOR_FILTER_POLICY_WHITE_LIST_NOT_USED_TO_CONNECT_ADVERTISER =  0x00,
    HCI_INITIATOR_FILTER_POLICY_WHITE_LIST_USED_TO_CONNECT_ADVERTISER =      0x01
} tHCI_Initiator_Filter_Policy;

/*---------------------------------------------------------------------------------*/
/*                       [321][Conn_Interval_Min][Time][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* Minimum value for the connection event interval. This shall be less than or
   equal to Conn_Interval_Max.Time = N * 1.25 msec Time Range: 7.5 msec to 4
   seconds */
/* Range: 0x6 ~ 0xc80 */
/* TimeRange[1.250000]: 7.500000 ~ 4000.000000 */

/*---------------------------------------------------------------------------------*/
/*                       [322][Conn_Interval_Max][Time][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* Maximum value for the connection event interval. This shall be greater than or
   equal to Conn_Interval_Min.Time = N * 1.25 msec Time Range: 7.5 msec to 4
   seconds */
/* Range: 0x6 ~ 0xc80 */
/* TimeRange[1.250000]: 7.500000 ~ 4000.000000 */

/*---------------------------------------------------------------------------------*/
/*                         [323][LEConn_Latency][Val][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* LEEvent                  LE_Connection_Complete                        (0x0001) */
/* LEEvent                  LE_Connection_Update_Complete                 (0x0003) */
/* Slave latency for the connection in number of connection events */
/* Range: 0x0 ~ 0x1f4 */

/*---------------------------------------------------------------------------------*/
/*                         [324][Min_CE_Length][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* Information parameter about the minimum length of connection needed for this LE
   connection */
/* Range: 0x0 ~ 0xffff */
/* TimeRange[0.625000]: 0.000000 ~ 40959.375000 */

/*---------------------------------------------------------------------------------*/
/*                         [325][Max_CE_Length][Time][L:2]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Create_Connection                          (0x200d) */
/* Request                  LE_Connection_Update                          (0x2013) */
/* Information parameter about the maximum length of connection needed for this LE
   connection.  */
/* Range: 0x0 ~ 0xffff */
/* TimeRange[0.625000]: 0.000000 ~ 40959.375000 */

/*---------------------------------------------------------------------------------*/
/*                         [326][White_List_Size][Val][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Read_White_List_Size                       (0x200f) */
/* Total number of white list entries that can be stored in the Controller */
/* Range: 0x1 ~ 0xff */

/*---------------------------------------------------------------------------------*/
/*                           [327][Channel_Map][Val][L:5]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Host_Channel_Classification            (0x2014) */
/* Return                   LE_Read_Channel_Map                           (0x2015) */
/* This parameter contains 37 1-bit fields.The nth such field (in the range 0 to
   36) contains the value for the link layer channel index n.Channel n is bad = 0.
  Channel n is unknown = 1.The most significant bits are reserved and shall be set
   to 0.At least one channel shall be marked as unknown. */

/*---------------------------------------------------------------------------------*/
/*                              [328][Key][Val][L:16]                              */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Encrypt                                    (0x2017) */
/* 128 bit key for the encryption of the data given in the command.The most
   significant octet of the key corresponds to key[0] using the notation specified
   in FIPS 197. */

/*---------------------------------------------------------------------------------*/
/*                         [329][Plaintext_Data][Val][L:16]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Encrypt                                    (0x2017) */
/* 128 bit data block that is requested to be encrypted.The most significant octet
   of the PlainText_Data corresponds to in[0] using the notation specified in FIPS
   197. */

/*---------------------------------------------------------------------------------*/
/*                         [330][Encrypted_Data][Val][L:16]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Encrypt                                    (0x2017) */
/* 128 bit encrypted data block.The most significant octet of the Encrypted_Data
   corresponds to out[0] using the notation specified in FIPS 197 */

/*---------------------------------------------------------------------------------*/
/*                          [331][Random_Number][Val][L:8]                         */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Rand                                       (0x2018) */
/* Request                  LE_Start_Encryption                           (0x2019) */
/* LEEvent                  LE_Long_Term_Key_Request                      (0x0005) */
/* 64 bit random number. */

/*---------------------------------------------------------------------------------*/
/*                      [332][Encrypted_Diversifier][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* LEEvent                  LE_Long_Term_Key_Request                      (0x0005) */
/* 16 bit encrypted diversifier */

/*---------------------------------------------------------------------------------*/
/*                         [333][Long_Term_Key][Val][L:16]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Start_Encryption                           (0x2019) */
/* Request                  LE_Long_Term_Key_Request_Reply                (0x201a) */
/* 128 bit long term key. */

/*---------------------------------------------------------------------------------*/
/*                          [334][RX_Frequency][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Receiver_Test                              (0x201d) */
/* N = (F - 2402) / 2 Range: 0x00 - 0x27. Frequency Range : 2402 MHz to 2480 MHz */
/* Range: 0x0 ~ 0x27 */

/*---------------------------------------------------------------------------------*/
/*                          [335][TX_Frequency][Val][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Transmitter_Test                           (0x201e) */
/* N = (F - 2402) / 2 Range: 0x00 - 0x27. Frequency Range : 2402 MHz to 2480 MHz */
/* Range: 0x0 ~ 0x27 */

/*---------------------------------------------------------------------------------*/
/*                       [336][Length_Of_Test_Data][Val][L:1]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Transmitter_Test                           (0x201e) */
/* Length in bytes of payload data in each packet */
/* Range: 0x0 ~ 0x25 */

/*---------------------------------------------------------------------------------*/
/*                         [337][Packet_Payload][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Transmitter_Test                           (0x201e) */
typedef enum _tHCI_Packet_Payload
{
    HCI_PACKET_PAYLOAD_PSEUDO_RANDOM_BIT_SEQUENCE_9 =                        0x00,
    HCI_PACKET_PAYLOAD_PATTERN_OF_ALTERNATING_BITS_11110000 =                0x01,
    HCI_PACKET_PAYLOAD_PATTERN_OF_ALTERNATING_BITS_10101010 =                0x02,
    HCI_PACKET_PAYLOAD_PSEUDO_RANDOM_BIT_SEQUENCE_15 =                       0x03,
    HCI_PACKET_PAYLOAD_PATTERN_OF_ALL_1_BITS =                               0x04,
    HCI_PACKET_PAYLOAD_PATTERN_OF_ALL_0_BITS =                               0x05,
    HCI_PACKET_PAYLOAD_PATTERN_OF_ALTERNATING_BITS_00001111 =                0x06,
    HCI_PACKET_PAYLOAD_PATTERN_OF_ALTERNATING_BITS_0101 =                    0x07
} tHCI_Packet_Payload;

/*---------------------------------------------------------------------------------*/
/*                        [338][Number_Of_Packets][Val][L:2]                       */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Test_End                                   (0x201f) */
/* Number of packets received */

/*---------------------------------------------------------------------------------*/
/*                          [339][Device_Type][Enum][L:1]                          */
/*---------------------------------------------------------------------------------*/
/* https://www.bluetooth.org/Technical/AssignedNumbers/A2MP.htm, Was named
   Controller type */
typedef enum _tHCI_Device_Type
{
    HCI_DEVICE_TYPE_BREDR =                                                  0x00,
    HCI_DEVICE_TYPE_WIFI =                                                   0x01,
    HCI_DEVICE_TYPE_UWB =                                                    0x02,
    HCI_DEVICE_TYPE_UDP_FAKE_PAL =                                           0xEF,
    HCI_DEVICE_TYPE_IVT_FAKE_PAL =                                           0xF0,
    HCI_DEVICE_TYPE_UNKNOWN =                                                0xFF
} tHCI_Device_Type;

/*---------------------------------------------------------------------------------*/
/*                          [340][Event_Mask][Mask64][L:8]                         */
/*---------------------------------------------------------------------------------*/
/* Request                  Set_Event_Mask                                (0x0c01) */

enum
{

    /* Event_Mask[0] */
    HCI_EVENT_MASK_NO_EVENTS_SPECIFIED                              = 0,           /* [1][0,0x00] */
    HCI_EVENT_MASK_INQUIRY_COMPLETE                                 = (0 * 8 + 0), /* [2][0,0x01] */
    HCI_EVENT_MASK_INQUIRY_RESULT                                   = (0 * 8 + 1), /* [3][0,0x02] */
    HCI_EVENT_MASK_CONNECTION_COMPLETE                              = (0 * 8 + 2), /* [4][0,0x04] */
    HCI_EVENT_MASK_CONNECTION_REQUEST                               = (0 * 8 + 3), /* [5][0,0x08] */
    HCI_EVENT_MASK_DISCONNECTION_COMPLETE                           = (0 * 8 + 4), /* [6][0,0x10] */
    HCI_EVENT_MASK_AUTHENTICATION_COMPLETE                          = (0 * 8 + 5), /* [7][0,0x20] */
    HCI_EVENT_MASK_REMOTE_NAME_REQUEST_COMPLETE                     = (0 * 8 + 6), /* [8][0,0x40] */
    HCI_EVENT_MASK_ENCRYPTION_CHANGE                                = (0 * 8 + 7), /* [9][0,0x80] */

    /* Event_Mask[1] */
    HCI_EVENT_MASK_CHANGE_CONNECTION_LINK_KEY_COMPLETE              = (1 * 8 + 0), /* [10][1,0x01] */
    HCI_EVENT_MASK_MASTER_LINK_KEY_COMPLETE                         = (1 * 8 + 1), /* [11][1,0x02] */
    HCI_EVENT_MASK_READ_REMOTE_SUPPORTED_FEATURES_COMPLETE          = (1 * 8 + 2), /* [12][1,0x04] */
    HCI_EVENT_MASK_READ_REMOTE_VERSION_INFORMATION_COMPLETE         = (1 * 8 + 3), /* [13][1,0x08] */
    HCI_EVENT_MASK_QOS_SETUP_COMPLETE                               = (1 * 8 + 4), /* [14][1,0x10] */
    HCI_EVENT_MASK_HARDWARE_ERROR                                   = (1 * 8 + 7), /* [15][1,0x80] */

    /* Event_Mask[2] */
    HCI_EVENT_MASK_FLUSH_OCCURRED                                   = (2 * 8 + 0), /* [16][2,0x01] */
    HCI_EVENT_MASK_ROLE_CHANGE                                      = (2 * 8 + 1), /* [17][2,0x02] */
    HCI_EVENT_MASK_MODE_CHANGE                                      = (2 * 8 + 3), /* [18][2,0x08] */
    HCI_EVENT_MASK_RETURN_LINK_KEYS                                 = (2 * 8 + 4), /* [19][2,0x10] */
    HCI_EVENT_MASK_PIN_CODE_REQUEST                                 = (2 * 8 + 5), /* [20][2,0x20] */
    HCI_EVENT_MASK_LINK_KEY_REQUEST                                 = (2 * 8 + 6), /* [21][2,0x40] */
    HCI_EVENT_MASK_LINK_KEY_NOTIFICATION                            = (2 * 8 + 7), /* [22][2,0x80] */

    /* Event_Mask[3] */
    HCI_EVENT_MASK_LOOPBACK_COMMAND                                 = (3 * 8 + 0), /* [23][3,0x01] */
    HCI_EVENT_MASK_DATA_BUFFER_OVERFLOW                             = (3 * 8 + 1), /* [24][3,0x02] */
    HCI_EVENT_MASK_MAX_SLOTS_CHANGE                                 = (3 * 8 + 2), /* [25][3,0x04] */
    HCI_EVENT_MASK_READ_CLOCK_OFFSET_COMPLETE                       = (3 * 8 + 3), /* [26][3,0x08] */
    HCI_EVENT_MASK_CONNECTION_PACKET_TYPE_CHANGED                   = (3 * 8 + 4), /* [27][3,0x10] */
    HCI_EVENT_MASK_QOS_VIOLATION                                    = (3 * 8 + 5), /* [28][3,0x20] */
    HCI_EVENT_MASK_PAGE_SCAN_MODE_CHANGE                            = (3 * 8 + 6), /* [29][3,0x40] */
    HCI_EVENT_MASK_PAGE_SCAN_REPETITION_MODE_CHANGE                 = (3 * 8 + 7), /* [30][3,0x80] */

    /* Event_Mask[4] */
    HCI_EVENT_MASK_FLOW_SPECIFICATION_COMPLETE                      = (4 * 8 + 0), /* [31][4,0x01] */
    HCI_EVENT_MASK_INQUIRY_RESULT_WITH_RSSI                         = (4 * 8 + 1), /* [32][4,0x02] */
    HCI_EVENT_MASK_READ_REMOTE_EXTENDED_FEATURES_COMPLETE           = (4 * 8 + 2), /* [33][4,0x04] */

    /* Event_Mask[5] */
    HCI_EVENT_MASK_SYNCHRONOUS_CONNECTION_COMPLETE                  = (5 * 8 + 3), /* [34][5,0x08] */
    HCI_EVENT_MASK_SYNCHRONOUS_CONNECTION_CHANGED                   = (5 * 8 + 4), /* [35][5,0x10] */
    HCI_EVENT_MASK_SNIFF_SUBRATING                                  = (5 * 8 + 5), /* [36][5,0x20] */
    HCI_EVENT_MASK_EXTENDED_INQUIRY_RESULT                          = (5 * 8 + 6), /* [37][5,0x40] */
    HCI_EVENT_MASK_ENCRYPTION_KEY_REFRESH_COMPLETE                  = (5 * 8 + 7), /* [38][5,0x80] */

    /* Event_Mask[6] */
    HCI_EVENT_MASK_IO_CAPABILITY_REQUEST                            = (6 * 8 + 0), /* [39][6,0x01] */
    HCI_EVENT_MASK_IO_CAPABILITY_RESPONSE                           = (6 * 8 + 1), /* [40][6,0x02] */
    HCI_EVENT_MASK_USER_CONFIRMATION_REQUEST                        = (6 * 8 + 2), /* [41][6,0x04] */
    HCI_EVENT_MASK_USER_PASSKEY_REQUEST                             = (6 * 8 + 3), /* [42][6,0x08] */
    HCI_EVENT_MASK_REMOTE_OOB_DATA_REQUEST                          = (6 * 8 + 4), /* [43][6,0x10] */
    HCI_EVENT_MASK_SIMPLE_PAIRING_COMPLETE                          = (6 * 8 + 5), /* [44][6,0x20] */
    HCI_EVENT_MASK_LINK_SUPERVISION_TIMEOUT_CHANGED                 = (6 * 8 + 7), /* [45][6,0x80] */

    /* Event_Mask[7] */
    HCI_EVENT_MASK_ENHANCED_FLUSH_COMPLETE                          = (7 * 8 + 0), /* [46][7,0x01] */
    HCI_EVENT_MASK_USER_PASSKEY_NOTIFICATION                        = (7 * 8 + 2), /* [47][7,0x04] */
    HCI_EVENT_MASK_KEYPRESS_NOTIFICATION                            = (7 * 8 + 3), /* [48][7,0x08] */
    HCI_EVENT_MASK_REMOTE_HOST_SUPPORTED_FEATURES_NOTIFICATION      = (7 * 8 + 4), /* [49][7,0x10] */
    HCI_EVENT_MASK_LE_META                                          = (7 * 8 + 5), /* [50][7,0x20] */
};

/*---------------------------------------------------------------------------------*/
/*                      [341][Event_Mask_Page_2][Mask64][L:8]                      */
/*---------------------------------------------------------------------------------*/
/* Request                  Set_Event_Mask_Page_2                         (0x0c63) */

enum
{

    /* Event_Mask_Page_2[0] */
    HCI_EVENT_MASK_PAGE_2_NO_EVENTS_SPECIFIED_DEFAULT               = 0,           /* [1][0,0x00] */
    HCI_EVENT_MASK_PAGE_2_PHYSICAL_LINK_COMPLETE                    = (0 * 8 + 0), /* [2][0,0x01] */
    HCI_EVENT_MASK_PAGE_2_CHANNEL_SELECTED                          = (0 * 8 + 1), /* [3][0,0x02] */
    HCI_EVENT_MASK_PAGE_2_DISCONNECTION_PHYSICAL_LINK_COMPLETE      = (0 * 8 + 2), /* [4][0,0x04] */
    HCI_EVENT_MASK_PAGE_2_PHYSICAL_LINK_LOSS_EARLY_WARNING          = (0 * 8 + 3), /* [5][0,0x08] */
    HCI_EVENT_MASK_PAGE_2_PHYSICAL_LINK_RECOVERY                    = (0 * 8 + 4), /* [6][0,0x10] */
    HCI_EVENT_MASK_PAGE_2_LOGICAL_LINK_COMPLETE                     = (0 * 8 + 5), /* [7][0,0x20] */
    HCI_EVENT_MASK_PAGE_2_DISCONNECTION_LOGICAL_LINK_COMPLETE       = (0 * 8 + 6), /* [8][0,0x40] */
    HCI_EVENT_MASK_PAGE_2_FLOW_SPEC_MODIFY_COMPLETE                 = (0 * 8 + 7), /* [9][0,0x80] */

    /* Event_Mask_Page_2[1] */
    HCI_EVENT_MASK_PAGE_2_NUMBER_OF_COMPLETED_DATA_BLOCKS           = (1 * 8 + 0), /* [10][1,0x01] */
    HCI_EVENT_MASK_PAGE_2_AMP_START_TEST                            = (1 * 8 + 1), /* [11][1,0x02] */
    HCI_EVENT_MASK_PAGE_2_AMP_TEST_END                              = (1 * 8 + 2), /* [12][1,0x04] */
    HCI_EVENT_MASK_PAGE_2_AMP_RECEIVER_REPORT                       = (1 * 8 + 3), /* [13][1,0x08] */
    HCI_EVENT_MASK_PAGE_2_SHORT_RANGE_MODE_CHANGE_COMPLETE          = (1 * 8 + 4), /* [14][1,0x10] */
    HCI_EVENT_MASK_PAGE_2_AMP_STATUS_CHANGE                         = (1 * 8 + 5), /* [15][1,0x20] */
    HCI_EVENT_MASK_PAGE_2_TRIGGERED_CLOCK_CAPTURE                   = (1 * 8 + 6), /* [16][1,0x40] */
    HCI_EVENT_MASK_PAGE_2_SYNCHRONIZATION_TRAIN_COMPLETE            = (1 * 8 + 7), /* [17][1,0x80] */

    /* Event_Mask_Page_2[2] */
    HCI_EVENT_MASK_PAGE_2_SYNCHRONIZATION_TRAIN_RECEIVED            = (2 * 8 + 0), /* [18][2,0x01] */
    HCI_EVENT_MASK_PAGE_2_CONNECTIONLESS_BROADCAST_RECEIVED         = (2 * 8 + 1), /* [19][2,0x02] */
    HCI_EVENT_MASK_PAGE_2_CONNECTIONLESS_BROADCAST_TIMEOUT          = (2 * 8 + 2), /* [20][2,0x04] */
    HCI_EVENT_MASK_PAGE_2_TRUNCATED_PAGE_COMPLETE                   = (2 * 8 + 3), /* [21][2,0x08] */
    HCI_EVENT_MASK_PAGE_2_SLAVE_PAGE_RESPONSE_TIMEOUT               = (2 * 8 + 4), /* [22][2,0x10] */
    HCI_EVENT_MASK_PAGE_2_CHANNEL_MAP_CHANGE                        = (2 * 8 + 5), /* [23][2,0x20] */
    HCI_EVENT_MASK_PAGE_2_INQUIRY_RESPONSE_NOTIFICATION             = (2 * 8 + 6), /* [24][2,0x40] */
};

/*---------------------------------------------------------------------------------*/
/*                     [342][Supported Commands][Mask64][L:64]                     */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Supported_Commands                 (0x1002) */
/* Bit mask for each HCI Command. If a bit is 1, the Controller supports the
   corresponding command and the features required for the command. Unsupported or
   undefined commands shall be set to 0. */

/*---------------------------------------------------------------------------------*/
/*                       Supported Command Mask->OpCode Table                      */
/*---------------------------------------------------------------------------------*/


#define HCI_GT_SUPPORTCMD           (sizeof(hci_table_supportcmd) / sizeof(UINT16))
/*---------------------------------------------------------------------------------*/
/*                        [343][LE_Event_Mask][Mask64][L:8]                        */
/*---------------------------------------------------------------------------------*/
/* Request                  LE_Set_Event_Mask                             (0x2001) */

enum
{

    /* LE_Event_Mask[0] */
    HCI_LE_EVENT_MASK_NO_LE_EVENTS_SPECIFIED                        = 0,           /* [1][0,0x00] */
    HCI_LE_EVENT_MASK_LE_CONNECTION_COMPLETE                        = (0 * 8 + 0), /* [2][0,0x01] */
    HCI_LE_EVENT_MASK_LE_ADVERTISING_REPORT                         = (0 * 8 + 1), /* [3][0,0x02] */
    HCI_LE_EVENT_MASK_LE_CONNECTION_UPDATE_COMPLETE                 = (0 * 8 + 2), /* [4][0,0x04] */
    HCI_LE_EVENT_MASK_LE_READ_REMOTE_USED_FEATURES_COMPLETE         = (0 * 8 + 3), /* [5][0,0x08] */
    HCI_LE_EVENT_MASK_LE_LONG_TERM_KEY_REQUEST                      = (0 * 8 + 4), /* [6][0,0x10] */
};

/*---------------------------------------------------------------------------------*/
/*                          [344][LE_States][Mask64][L:8]                          */
/*---------------------------------------------------------------------------------*/
/* Return                   LE_Read_Supported_States                      (0x201c) */

enum
{

    /* LE_States[0] */
    HCI_LE_STATES_ADVERTISING_NON_CONNECTABLE                       = (0 * 8 + 0), /* [1][0,0x01] */
    HCI_LE_STATES_ADVERTISING_SCANNABLE                             = (0 * 8 + 1), /* [2][0,0x02] */
    HCI_LE_STATES_ADVERTISING_CONNECTABLE                           = (0 * 8 + 2), /* [3][0,0x04] */
    HCI_LE_STATES_ADVERTISING_DIRECTED                              = (0 * 8 + 3), /* [4][0,0x08] */
    HCI_LE_STATES_SCANNING_PASSIVE                                  = (0 * 8 + 4), /* [5][0,0x10] */
    HCI_LE_STATES_SCANNING_ACTIVE                                   = (0 * 8 + 5), /* [6][0,0x20] */
    HCI_LE_STATES_INITIATING                                        = (0 * 8 + 6), /* [7][0,0x40] */
    HCI_LE_STATES_CONNECTION_IN_SLAVE                               = (0 * 8 + 7), /* [8][0,0x80] */

    /* LE_States[1] */
    HCI_LE_STATES_ADVERTISING_NON_CONNECTABLE_SCANNING_PASSIVE      = (1 * 8 + 0), /* [9][1,0x01] */
    HCI_LE_STATES_ADVERTISING_SCANNABLE_SCANNING_PASSIVE            = (1 * 8 + 1), /* [10][1,0x02] */
    HCI_LE_STATES_ADVERTISING_CONNECTABLE_SCANNING_PASSIVE          = (1 * 8 + 2), /* [11][1,0x04] */
    HCI_LE_STATES_ADVERTISING_DIRECTED_SCANNING_PASSIVE             = (1 * 8 + 3), /* [12][1,0x08] */
    HCI_LE_STATES_ADVERTISING_NON_CONNECTABLE_SCANNING_ACTIVE       = (1 * 8 + 4), /* [13][1,0x10] */
    HCI_LE_STATES_ADVERTISING_SCANNABLE_SCANNING_ACTIVE             = (1 * 8 + 5), /* [14][1,0x20] */
    HCI_LE_STATES_ADVERTISING_CONNECTABLE_SCANNING_ACTIVE           = (1 * 8 + 6), /* [15][1,0x40] */
    HCI_LE_STATES_ADVERTISING_DIRECTED_SCANNING_ACTIVE              = (1 * 8 + 7), /* [16][1,0x80] */

    /* LE_States[2] */
    HCI_LE_STATES_ADVERTISING_NON_CONNECTABLE_INITIATING            = (2 * 8 + 0), /* [17][2,0x01] */
    HCI_LE_STATES_ADVERTISING_SCANNABLE_INITIATING                  = (2 * 8 + 1), /* [18][2,0x02] */
    HCI_LE_STATES_ADVERTISING_NON_CONNECTABLE_MASTER                = (2 * 8 + 2), /* [19][2,0x04] */
    HCI_LE_STATES_ADVERTISING_SCANNABLE_MASTER                      = (2 * 8 + 3), /* [20][2,0x08] */
    HCI_LE_STATES_ADVERTISING_NON_CONNECTABLE_SLAVE                 = (2 * 8 + 4), /* [21][2,0x10] */
    HCI_LE_STATES_ADVERTISING_SCANNABLE_SLAVE                       = (2 * 8 + 5), /* [22][2,0x20] */
    HCI_LE_STATES_SCANNING_PASSIVE_INITIATING                       = (2 * 8 + 6), /* [23][2,0x40] */
    HCI_LE_STATES_SCANNING_ACTIVE_INITIATING                        = (2 * 8 + 7), /* [24][2,0x80] */

    /* LE_States[3] */
    HCI_LE_STATES_SCANNING_PASSIVE_MASTER                           = (3 * 8 + 0), /* [25][3,0x01] */
    HCI_LE_STATES_SCANNING_ACTIVE_MASTER                            = (3 * 8 + 1), /* [26][3,0x02] */
    HCI_LE_STATES_SCANNING_PASSIVE_SLAVE                            = (3 * 8 + 2), /* [27][3,0x04] */
    HCI_LE_STATES_SCANNING_ACTIVE_SLAVE                             = (3 * 8 + 3), /* [28][3,0x08] */
    HCI_LE_STATES_INITIATING_MASTER                                 = (3 * 8 + 4), /* [29][3,0x10] */
};

/*---------------------------------------------------------------------------------*/
/*                         [345][LMP_Features][Mask64][L:8]                        */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Supported_Features                 (0x1003) */
/* Event                    Read_Remote_Supported_Features_Complete       (0x000b) */

enum
{

    /* LMP_Features[0] */
    HCI_LMP_FEATURES_3_SLOT_PACKETS                                 = (0 * 8 + 0), /* [1][0,0x01] */
    HCI_LMP_FEATURES_5_SLOT_PACKETS                                 = (0 * 8 + 1), /* [2][0,0x02] */
    HCI_LMP_FEATURES_ENCRYPTION                                     = (0 * 8 + 2), /* [3][0,0x04] */
    HCI_LMP_FEATURES_SLOT_OFFSET                                    = (0 * 8 + 3), /* [4][0,0x08] */
    HCI_LMP_FEATURES_TIMING_ACCURACY                                = (0 * 8 + 4), /* [5][0,0x10] */
    HCI_LMP_FEATURES_ROLE_SWITCH                                    = (0 * 8 + 5), /* [6][0,0x20] */
    HCI_LMP_FEATURES_HOLD_MODE                                      = (0 * 8 + 6), /* [7][0,0x40] */
    HCI_LMP_FEATURES_SNIFF_MODE                                     = (0 * 8 + 7), /* [8][0,0x80] */

    /* LMP_Features[1] */
    HCI_LMP_FEATURES_PARK_STATE                                     = (1 * 8 + 0), /* [9][1,0x01] */
    HCI_LMP_FEATURES_POWER_CONTROL_REQUESTS                         = (1 * 8 + 1), /* [10][1,0x02] */
    HCI_LMP_FEATURES_CHANNEL_QUALITY_DRIVEN_DATA_RATE_CQDDR         = (1 * 8 + 2), /* [11][1,0x04] */
    HCI_LMP_FEATURES_SCO_LINK                                       = (1 * 8 + 3), /* [12][1,0x08] */
    HCI_LMP_FEATURES_HV2_PACKETS                                    = (1 * 8 + 4), /* [13][1,0x10] */
    HCI_LMP_FEATURES_HV3_PACKETS                                    = (1 * 8 + 5), /* [14][1,0x20] */
    HCI_LMP_FEATURES_ULAW_LOG_SYNCHRONOUS_DATA                      = (1 * 8 + 6), /* [15][1,0x40] */
    HCI_LMP_FEATURES_ALAW_LOG_SYNCHRONOUS_DATA                      = (1 * 8 + 7), /* [16][1,0x80] */

    /* LMP_Features[2] */
    HCI_LMP_FEATURES_CVSD_SYNCHRONOUS_DATA                          = (2 * 8 + 0), /* [17][2,0x01] */
    HCI_LMP_FEATURES_PAGING_PARAMETER_NEGOTIATION                   = (2 * 8 + 1), /* [18][2,0x02] */
    HCI_LMP_FEATURES_POWER_CONTROL                                  = (2 * 8 + 2), /* [19][2,0x04] */
    HCI_LMP_FEATURES_TRANSPARENT_SYNCHRONOUS_DATA                   = (2 * 8 + 3), /* [20][2,0x08] */
    HCI_LMP_FEATURES_FLOW_CONTROL_LAG_LSB                           = (2 * 8 + 4), /* [21][2,0x10] */
    HCI_LMP_FEATURES_FLOW_CONTROL_LAG_MIDB                          = (2 * 8 + 5), /* [22][2,0x20] */
    HCI_LMP_FEATURES_FLOW_CONTROL_LAG_MSB                           = (2 * 8 + 6), /* [23][2,0x40] */
    HCI_LMP_FEATURES_BROADCAST_ENCRYPTION                           = (2 * 8 + 7), /* [24][2,0x80] */

    /* LMP_Features[3] */
    HCI_LMP_FEATURES_CLOCK_NUDGING                                  = (3 * 8 + 0), /* [25][3,0x01] */
    HCI_LMP_FEATURES_ENHANCED_DATA_RATE_ACL_2_MBPS_MODE             = (3 * 8 + 1), /* [26][3,0x02] */
    HCI_LMP_FEATURES_ENHANCED_DATA_RATE_ACL_3_MBPS_MODE             = (3 * 8 + 2), /* [27][3,0x04] */
    HCI_LMP_FEATURES_ENHANCED_INQUIRY_SCAN                          = (3 * 8 + 3), /* [28][3,0x08] */
    HCI_LMP_FEATURES_INTERLACED_INQUIRY_SCAN                        = (3 * 8 + 4), /* [29][3,0x10] */
    HCI_LMP_FEATURES_INTERLACED_PAGE_SCAN                           = (3 * 8 + 5), /* [30][3,0x20] */
    HCI_LMP_FEATURES_RSSI_WITH_INQUIRY_RESULTS                      = (3 * 8 + 6), /* [31][3,0x40] */
    HCI_LMP_FEATURES_EXTENDED_SCO_LINK_EV3_PACKETS                  = (3 * 8 + 7), /* [32][3,0x80] */

    /* LMP_Features[4] */
    HCI_LMP_FEATURES_EV4_PACKETS                                    = (4 * 8 + 0), /* [33][4,0x01] */
    HCI_LMP_FEATURES_EV5_PACKETS                                    = (4 * 8 + 1), /* [34][4,0x02] */
    HCI_LMP_FEATURES_GENERALIZED_INTERLACED_SCAN                    = (4 * 8 + 2), /* [35][4,0x04] */
    HCI_LMP_FEATURES_AFH_CAPABLE_SLAVE                              = (4 * 8 + 3), /* [36][4,0x08] */
    HCI_LMP_FEATURES_AFH_CLASSIFICATION_SLAVE                       = (4 * 8 + 4), /* [37][4,0x10] */
    HCI_LMP_FEATURES_BREDR_NOT_SUPPORTED                            = (4 * 8 + 5), /* [38][4,0x20] */
    HCI_LMP_FEATURES_LE_SUPPORTED_CONTROLLER                        = (4 * 8 + 6), /* [39][4,0x40] */
    HCI_LMP_FEATURES_3SLOT_ENHANCED_DATA_RATE_ACL_PACKETS           = (4 * 8 + 7), /* [40][4,0x80] */

    /* LMP_Features[5] */
    HCI_LMP_FEATURES_5SLOT_ENHANCED_DATA_RATE_ACL_PACKETS           = (5 * 8 + 0), /* [41][5,0x01] */
    HCI_LMP_FEATURES_SNIFF_SUBRATING                                = (5 * 8 + 1), /* [42][5,0x02] */
    HCI_LMP_FEATURES_PAUSE_ENCRYPTION                               = (5 * 8 + 2), /* [43][5,0x04] */
    HCI_LMP_FEATURES_AFH_CAPABLE_MASTER                             = (5 * 8 + 3), /* [44][5,0x08] */
    HCI_LMP_FEATURES_AFH_CLASSIFICATION_MASTER                      = (5 * 8 + 4), /* [45][5,0x10] */
    HCI_LMP_FEATURES_ENHANCED_DATA_RATE_SYNCHRONOUS_2_MBPS_MODE     = (5 * 8 + 5), /* [46][5,0x20] */
    HCI_LMP_FEATURES_ENHANCED_DATA_RATE_SYNCHRONOUS_3_MBPS_MODE     = (5 * 8 + 6), /* [47][5,0x40] */
    HCI_LMP_FEATURES_3SLOT_ENHANCED_DATA_RATE_SYNCHRONOUS_PACKETS   = (5 * 8 + 7), /* [48][5,0x80] */

    /* LMP_Features[6] */
    HCI_LMP_FEATURES_EXTENDED_INQUIRY_RESPONSE                      = (6 * 8 + 0), /* [49][6,0x01] */
    HCI_LMP_FEATURES_SIMULTANEOUS_LE_BREDR_CONTROLLER               = (6 * 8 + 1), /* [50][6,0x02] */
    HCI_LMP_FEATURES_SECURE_SIMPLE_PAIRING                          = (6 * 8 + 3), /* [51][6,0x08] */
    HCI_LMP_FEATURES_ENCAPSULATED_PDU                               = (6 * 8 + 4), /* [52][6,0x10] */
    HCI_LMP_FEATURES_ERRONEOUS_DATA_REPORTING                       = (6 * 8 + 5), /* [53][6,0x20] */
    HCI_LMP_FEATURES_NON_FLUSHABLE_PACKET_BOUNDARY_FLAG             = (6 * 8 + 6), /* [54][6,0x40] */

    /* LMP_Features[7] */
    HCI_LMP_FEATURES_LINK_SUPERVISION_TIMEOUT_CHANGED_EVENT         = (7 * 8 + 0), /* [55][7,0x01] */
    HCI_LMP_FEATURES_INQUIRY_TX_POWER_LEVEL                         = (7 * 8 + 1), /* [56][7,0x02] */
    HCI_LMP_FEATURES_ENHANCED_POWER_CONTROL                         = (7 * 8 + 2), /* [57][7,0x04] */
    HCI_LMP_FEATURES_SECURE_CONNECTIONS                             = (7 * 8 + 3), /* [58][7,0x08] */
    HCI_LMP_FEATURES_EXTENDED_FEATURES                              = (7 * 8 + 7), /* [59][7,0x80] */
};

/*---------------------------------------------------------------------------------*/
/*                    [346][Host_Supported_Features][Mask][L:8]                    */
/*---------------------------------------------------------------------------------*/
/* Event                    Remote_Host_Supported_Features_Notification   (0x003d) */
/* Bit map of Host Supported Features page of LMP extended features */

/*---------------------------------------------------------------------------------*/
/*                    [347][Extended_LMP_Features][Mask64][L:8]                    */
/*---------------------------------------------------------------------------------*/
/* Return                   Read_Local_Extended_Features                  (0x1004) */
/* Event                    Read_Remote_Extended_Features_Complete        (0x0023) */
/* Host Supported Features Page, Page 1 */

enum
{

    /* Extended_LMP_Features[0] */
    HCI_EXTENDED_LMP_FEATURES_SECURE_SIMPLE_PAIRING_HOST            = (0 * 8 + 0), /* [1][0,0x01] */
    HCI_EXTENDED_LMP_FEATURES_LE_SUPPORTED_HOST                     = (0 * 8 + 1), /* [2][0,0x02] */
    HCI_EXTENDED_LMP_FEATURES_SIMULTANEOUS_LE_BREDR_HOST            = (0 * 8 + 2), /* [3][0,0x04] */
    /* Connectionless Slave Broadcast Features Page, Page 2 */

    /* Extended_LMP_Features[0] */
    HCI_EXTENDED_LMP_FEATURES_CONNECTIONLESS_SLAVE_BROADCAST_MASTER_OPERATION = (0 * 8 + 0),/* [4][0,0x01] */
    HCI_EXTENDED_LMP_FEATURES_CONNECTIONLESS_SLAVE_BROADCAST_SLAVE_OPERATION = (0 * 8 + 1),/* [5][0,0x02] */
    HCI_EXTENDED_LMP_FEATURES_SYNCHRONIZATION_TRAIN                 = (0 * 8 + 2), /* [6][0,0x04] */
    HCI_EXTENDED_LMP_FEATURES_SYNCHRONIZATION_SCAN                  = (0 * 8 + 3), /* [7][0,0x08] */
    HCI_EXTENDED_LMP_FEATURES_INQUIRY_RESPONSE_NOTIFICATION_EVENT   = (0 * 8 + 4), /* [8][0,0x10] */
};

/*---------------------------------------------------------------------------------*/
/*                             [348][LT_ADDR][Val][L:1]                            */
/*---------------------------------------------------------------------------------*/
/* 0x01-0x07, LT_ADDR used for Connectionless Broadcast, 0x00, 0x08-0xFF are
   reserved for future use */

/*---------------------------------------------------------------------------------*/
/*                          [349][Interval_Min][Val][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* Minimum interval between Connectionless Broadcasts in slots. Range:
   0x0002-0xFFFE; only even values are valid Time = 1.25 ms C 40.9 seconds */

/*---------------------------------------------------------------------------------*/
/*                          [350][Interval_Max][Val][L:2]                          */
/*---------------------------------------------------------------------------------*/
/* Maximum interval between Connectionless Broadcasts in slots. Range:
   0x0002-0xFFFE; only even values are valid Time = 1.25 ms C 40.9 seconds */

/*---------------------------------------------------------------------------------*/
/*                     [351][Sync_Train_Ref_Interval][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Reference interval in slots between consecutive Synchronization Train packets on
   the same channel. Range: 0x0020-0xFFFE; only even values are valid Time = 20 ms
   C 40.9 seconds */

/*---------------------------------------------------------------------------------*/
/*                             [352][Timeout][Val][L:2]                            */
/*---------------------------------------------------------------------------------*/
/* Amount of time in slots to continue sending the synchronization train Range:
   0x0002-0xFFFE; only even values are valid */

/*---------------------------------------------------------------------------------*/
/*                             [353][Enable][Enum][L:1]                            */
/*---------------------------------------------------------------------------------*/
/* 0x02-0xFF Reserved for future use */
typedef enum _tHCI_Enable
{
    HCI_ENABLE_DISABLED =                                                    0x00,
    HCI_ENABLE_ENABLED =                                                     0x01
} tHCI_Enable;

/*---------------------------------------------------------------------------------*/
/*               [354][Next_Connectionless_Broadcast_Clock][Val][L:4]              */
/*---------------------------------------------------------------------------------*/
/* Bits 27-0    Broadcaster CLK for next Connectionless Broadcast instant Bits 31-28.
   Reserved. Set to 0000. */

/*---------------------------------------------------------------------------------*/
/*                     [355][Remote_Timing_Accuracy:][Val][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Timing accuracy of the Broadcaster in ppm. Typical values are 20ppm and 250ppm. */

/*---------------------------------------------------------------------------------*/
/*                              [356][Skip][Val][L:1]                              */
/*---------------------------------------------------------------------------------*/
/* Number of Broadcast Instants to skip after successfully receiving a Broadcast */

/*---------------------------------------------------------------------------------*/
/*                     [357][Sync_Train_Scan_Timeout][Val][L:2]                    */
/*---------------------------------------------------------------------------------*/
/* Amount of time in slots to search for the synchronization train, Range:
   0x0002-0xFFFE; only even values are valid */

/*---------------------------------------------------------------------------------*/
/*                     [358][Sync_Train_Scan_Window][Val][L:2]                     */
/*---------------------------------------------------------------------------------*/
/* Amount of time in slots to listen for a synchronization train packet on a single
   frequency Range: 0x0002-0xFFFE; only even values are valid */

/*---------------------------------------------------------------------------------*/
/*                    [359][Sync_Train_Scan_Interval][Val][L:1]                    */
/*---------------------------------------------------------------------------------*/
/* Amount of time in slots between listening for synchronization train packets
   Range: 0x0002-0xFFFE; only even values are valid */

/*---------------------------------------------------------------------------------*/
/*                               [360][CLK][Val][L:4]                              */
/*---------------------------------------------------------------------------------*/
/* Bits 27-0 CLK (Piconet) when Connectionless Broadcast data was received. Bits
   31-28 Shall be set to 0000b and ignored upon receipt. */

/*---------------------------------------------------------------------------------*/
/*                             [361][Offset][Val][L:4]                             */
/*---------------------------------------------------------------------------------*/
/* Bits 27-0 CLKslave - CLKmaster. Bits 31-28 Shall be set to 0000b and ignored
   upon receipt. */

/*---------------------------------------------------------------------------------*/
/*                            [362][Fragment][Enum][L:1]                           */
/*---------------------------------------------------------------------------------*/
/* 0x04-0xFF Reserved for future use */
typedef enum _tHCI_Fragment
{
    HCI_FRAGMENT_CONTINUATION_FRAGMENT =                                     0x00,
    HCI_FRAGMENT_STARTING_FRAGMENT =                                         0x01,
    HCI_FRAGMENT_ENDING_FRAGMENT =                                           0x02,
    HCI_FRAGMENT_NO_FRAGMENTATION =                                          0x03
} tHCI_Fragment;

/*---------------------------------------------------------------------------------*/
/*                         [363][Receive_Status][Enum][L:1]                        */
/*---------------------------------------------------------------------------------*/
/* Other values are reserved */
typedef enum _tHCI_Receive_Status
{
    HCI_RECEIVE_STATUS_PACKET_RECEIVED_SUCCESSFULLY =                        0x00,
    HCI_RECEIVE_STATUS_PACKET_NOT_RECEIVED =                                 0x01
} tHCI_Receive_Status;

/*---------------------------------------------------------------------------------*/
/*                     [364][Broadcast_Channel_Info][Val][L:7]                     */
/*---------------------------------------------------------------------------------*/
/* ??? */

/*---------------------------------------------------------------------------------*/
/*             VOLUME 3, PART C (GAP), APPENDIX A TIMERS AND CONSTANTS             */
/*---------------------------------------------------------------------------------*/

enum
{
    HCI_TGAP_LIM_ADV_TIMEOUT =                       180000, /* 0x2bf20, 180.000s, U:1.000 */
    /* **Required**, Maximum time to remain advertising when in the limited discoverable mode */

    HCI_TGAP_GEN_DISC_SCAN_MIN =                     10239, /* 0x27ff, 10.240s, U:1.000 */
    /* Minimum time to perform scanning when performing the general discovery procedure */

    HCI_TGAP_LIM_DISC_SCAN_MIN =                     10239, /* 0x27ff, 10.240s, U:1.000 */
    /* Minimum time to perform scanning when performing the limited discovery procedure */

    HCI_TGAP_LIM_DISC_SCAN_INT =                     17, /* 0x0011, 11.250ms, U:0.625 */
    /* Scan interval used in the limited discovery procedure */

    HCI_TGAP_CONN_PARAM_TIMEOUT =                    30000, /* 0x7530, 30.000s, U:1.000 */
    /* Connection parameter update notification timer when performing the connection parameter update procedure */

    HCI_TGAP_SCAN_FAST_PERIOD =                      30720, /* 0x7800, 30.720s, U:1.000 */
    /* Minimum time to perform scanning when user initiated */

    HCI_TGAP_SCAN_FAST_INTERVAL_MIN =                48, /* 0x0030, 30.000ms, U:0.625 */
    /* 30 ms to 60 ms Scan interval in any discovery or connection establishment procedure when user initiated  */

    HCI_TGAP_SCAN_FAST_INTERVAL_MAX =                96, /* 0x0060, 60.000ms, U:0.625 */
    /* 30 ms to 60 ms Scan interval in any discovery or connection establishment procedure when user initiated  */

    HCI_TGAP_SCAN_FAST_WINDOW =                      48, /* 0x0030, 30.000ms, U:0.625 */
    /* Scan window in any discovery or connection establishment procedure when user initiated */

    HCI_TGAP_SCAN_SLOW_INTERVAL1 =                   2048, /* 0x0800, 1.280s, U:0.625 */
    /* Scan interval in any discovery or connection establishment procedure when background scanning */

    HCI_TGAP_SCAN_SLOW_WINDOW1 =                     17, /* 0x0011, 11.250ms, U:0.625 */
    /* Scan window in any discovery or connection establishment procedure when background scanning */

    HCI_TGAP_SCAN_SLOW_INTERVAL2 =                   4096, /* 0x1000, 2.560s, U:0.625 */
    /* Scan interval in any discovery or connection establishment procedure when background scanning */

    HCI_TGAP_SCAN_SLOW_WINDOW2 =                     35, /* 0x0023, 22.500ms, U:0.625 */
    /* Scan window in any discovery or connection establishment procedure when background scanning */

    HCI_TGAP_ADV_FAST_PERIOD =                       30000, /* 0x7530, 30.000s, U:1.000 */
    /* Minimum time to perform advertising when user initiated */

    HCI_TGAP_ADV_FAST_INTERVAL_NONCONN_MIN =         160, /* 0x00a0, 100.000ms, U:0.625 */
    /* Minimum to maximum advertising interval in Non Connectable Mode when user initiated, in Limited Discoverable Mode and General Discoverable Mode when user initiated */

    HCI_TGAP_ADV_FAST_INTERVAL_NONCONN_MAX =         240, /* 0x00f0, 150.000ms, U:0.625 */
    /* Minimum to maximum advertising interval in Non Connectable Mode when user initiated, in Limited Discoverable Mode and General Discoverable Mode when user initiated */

    HCI_TGAP_ADV_FAST_INTERVAL_MIN =                 48, /* 0x0030, 30.000ms, U:0.625 */
    /* 30 ms to 60 ms Minimum to maximum advertising interval in Undirected Connectable Mode when user initiated */

    HCI_TGAP_ADV_FAST_INTERVAL_MAX =                 96, /* 0x0060, 60.000ms, U:0.625 */
    /* 30 ms to 60 ms Minimum to maximum advertising interval in Undirected Connectable Mode when user initiated */

    HCI_TGAP_ADV_SLOW_INTERVAL_MIN =                 1600, /* 0x0640, 1.000s, U:0.625 */
    /* 1s to 1.2s Minimum to maximum advertisement interval in any discoverable or connectable mode when background advertising */

    HCI_TGAP_ADV_SLOW_INTERVAL_MAX =                 1920, /* 0x0780, 1.200s, U:0.625 */
    /* 1s to 1.2s Minimum to maximum advertisement interval in any discoverable or connectable mode when background advertising */

    HCI_TGAP_INITIAL_CONN_INTERVAL_MIN =             24, /* 0x0018, 30.000ms, U:1.250 */
    /* 30ms to 50ms Minimum to maximum connection interval upon any connection establishment */

    HCI_TGAP_INITIAL_CONN_INTERVAL_MAX =             40, /* 0x0028, 50.000ms, U:1.250 */
    /* 30ms to 50ms Minimum to maximum connection interval upon any connection establishment */

    HCI_TGAP_CONN_PAUSE_CENTRAL =                    1000, /* 0x03e8, 1.000s, U:1.000 */
    /* Central idle timer */

    HCI_TGAP_CONN_PAUSE_PERIPHERAL =                 5000, /* 0x1388, 5.000s, U:1.000 */
    /* Minimum time upon connection establishment before the peripheral starts a connection update procedure */

    HCI_TGAP_PRIVATE_ADDR_INT =                      900000, /* 0xdbba0, 15.000min, U:1.000 */
    /* Minimum time interval between private address change */

};

/*---------------------------------------------------------------------------------*/
/*                       Supported Command Bitmask Gap Table                       */
/*---------------------------------------------------------------------------------*/

struct HCI_OpCodeGapStru
{
    UINT8 index;/* bitmask index */
    UINT16 opcode;
};



extern const UINT8 hci_table_coding_Event[];
extern const UINT8 hci_table_coding_Command[];
extern const UINT8 hci_table_codingoff_Event[];
extern const struct HCI_IndexGapStru hci_table_evgap[];
extern const struct HCI_EventCommandStru hci_table_evop[];
extern const UINT16 hci_table_supportcmd[];
extern const struct HCI_OpCodeGapStru hci_table_supportcmdgap[];



/* ----- [Convert_Info] ----- */
/* [Stru][CmdRet:178][Event:54][LEEv:5][OpEv:36][Par:435] */
/* [Stru:329][Macro:1248][TableOctets:1336] */

/* [2013/4/2][Week:2][20:35:59.328] */

#pragma __PRQA_IGNORE_END__

#endif /* G_HCI_STRU_H */


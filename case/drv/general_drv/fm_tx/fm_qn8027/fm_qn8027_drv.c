/******************************************************************************** *        Copyright(c) 2014-2016 Actions (Zhuhai) Technology Co., Limited, *                            All Rights Reserved. * * 描述：FM QN8027 发射模组驱动程序实现。 * 作者：cailizhen ********************************************************************************/#include "fm_tx_drv.h"#include "fm_qn8027.h"#if (SUPPORT_FM_TX == 1)/********************************************************************************* * \         int QND_WriteReg(uint8 RegAddr, uint8 Data) * \ * \Description : 写寄存器 * \ * \Arguments :  RegAddr:要写的寄存器;Data:要写入的寄存器值 * \Returns :   0 success -1 fail * \ * \Notes : * \*********************************************************************************/int QND_TX_WriteReg(uint8 RegAddr, uint8 Data){    uint8 i;    uint32 flags;    int result = 0;    uint8 tempbuf[2];    uint8 ret = 0;    //register addr    tempbuf[0] = RegAddr;    //register data    tempbuf[1] = Data;    for (i = 0; i < 10; i++)    {#if (TWI_MASTER_MULTY_CALLERS_AND_INT_CALL == 1)        flags = sys_local_intc_save(0x01|(1<<IRQ_TIMER3));//关中断#else        sys_os_sched_lock();#endif        ret = twi_write_bytes(FM_TWI_MASTER_MODE, fm_tx_twi_master_idx, tempbuf, I2C_WRITE_ADDR, 2, TWI_READ_MODE_NO);#if (TWI_MASTER_MULTY_CALLERS_AND_INT_CALL == 1)        sys_local_intc_restore(flags);//开中断#else        sys_os_sched_unlock();#endif        //send 3 byte to fm module        if (ret != 0)        {            break;        }    }    if (i == 10)    {        result = -1;    }    if (result == -1)    {        libc_printf_warning("QND_TX_WriteReg fail!\n");    }    return result;}/********************************************************************************* * \           uint8 QND_ReadReg(uint8 RegAddr) * \ * \Description : 读寄存器的值 * \ * \Arguments :  RegAddr:要读的寄存器 * \Returns :   读出的寄存器值 * \ * \Notes : * \*********************************************************************************/uint8 QND_TX_ReadReg(uint8 RegAddr){    uint8 i;    uint8 Data = 0;    uint32 flags;    uint8 tempbuf[2];    uint8 ret = 0;    for (i = 0; i < 10; i++)    {        tempbuf[0] = RegAddr;#if (TWI_MASTER_MULTY_CALLERS_AND_INT_CALL == 1)        flags = sys_local_intc_save(0x01|(1<<IRQ_TIMER3));//关中断#else        sys_os_sched_lock();#endif        ret = twi_write_bytes(FM_TWI_MASTER_MODE, fm_tx_twi_master_idx, tempbuf, I2C_WRITE_ADDR, 1, TWI_READ_MODE_YES);#if (TWI_MASTER_MULTY_CALLERS_AND_INT_CALL == 1)        sys_local_intc_restore(flags);//开中断#else        sys_os_sched_unlock();#endif        if (ret != 0)        {#if (TWI_MASTER_MULTY_CALLERS_AND_INT_CALL == 1)            flags = sys_local_intc_save(0x01|(1<<IRQ_TIMER3));//关中断#else            sys_os_sched_lock();#endif            ret = twi_read_bytes(FM_TWI_MASTER_MODE, fm_tx_twi_master_idx, tempbuf, I2C_READ_ADDR, 1);#if (TWI_MASTER_MULTY_CALLERS_AND_INT_CALL == 1)            sys_local_intc_restore(flags);//开中断#else            sys_os_sched_unlock();#endif            if (ret != 0)            {                Data = tempbuf[0];                break;            }        }    }    if (i == 10)    {        libc_printf_warning("QND_TX_ReadReg fail!\n");    }    return Data;}void QND_SetRegBit(BYTE reg, BYTE bitMask, BYTE data_val){    BYTE temp;    temp = QND_TX_ReadReg(reg);    temp &= (BYTE)(~bitMask);    temp |= data_val;    QND_TX_WriteReg(reg, temp);}void QN8027_SetMute(bool flag){    if(flag)        QND_SetRegBit(REG_SYSTEM,0x08,0x08); //bit3 = 1;    else        QND_SetRegBit(REG_SYSTEM,0x08,0x00); //bit3 = 0;    sys_mdelay(20);}void sFM_TX_SetFreq(uint16 frq){    BYTE temp1,freq_msb,freq_lsb;    uint16 temp;    if(frq > 1080 || frq < 875)    {        frq = 875;    }    temp=(frq-760)*2;    freq_msb=(BYTE)(temp>>8);    freq_lsb=(BYTE) temp;    temp1=QND_TX_ReadReg(REG_SYSTEM)&0xfc;    QND_TX_WriteReg(REG_SYSTEM,freq_msb|temp1);    QND_TX_WriteReg(REG_CH1,freq_lsb);}void sFM_TX_Init(uint16 frq){    QND_SetRegBit(REG_SYSTEM,0x80,0x80); //复位;    sys_mdelay(20);    QND_SetRegBit(REG_XTL,0xC0,0x40);     //inject single-end sin wave clock from XTAL1    QND_SetRegBit(REG_VGA,0x80,0x80);     //R04[7]=1,XTAL1 inject frequency is 24MHZ    //recalibration    QND_SetRegBit(REG_SYSTEM,0x40,0x40);  //R00[6]=1    QND_SetRegBit(REG_SYSTEM,0x40,0x00);  //R00[6]=0    sys_mdelay(20);//delay 20 ms Do recalibration    QND_TX_WriteReg(0x18,0xe4); //imporve SNR performance改善信噪比    QND_TX_WriteReg(0x1b,0xf0); //imporve SNR performance发射功率最大    QND_SetRegBit(REG_VGA,0x7F,0x32);     //RIN 10k, input gain 0dB, Tx gain 0dB//以上是按照pdf推荐的顺序初始化//设置频点    QND_TX_WriteReg(REG_GPLT,0xb9);   //disable RF PA off function关闭没有音频信号时自动关闭。    QND_TX_WriteReg(REG_SYSTEM,0x22); //transmitting    sys_mdelay(20);    sFM_TX_SetFreq(frq);    libc_printf("FM TX CID1 = 0x%x, CID2 = 0x%x\n", QND_TX_ReadReg(REG_CID1), QND_TX_ReadReg(REG_CID2));}#endif